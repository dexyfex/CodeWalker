using SharpDX;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using EXP = System.ComponentModel.ExpandableObjectConverter;
using TC = System.ComponentModel.TypeConverterAttribute;




/*

Parts of this are adapted from CamxxCore's RageAudioTool, although it's been completely reworked for CW.
-dexyfex


https://github.com/CamxxCore/RageAudioTool

MIT License

Copyright (c) 2017 Cameron Berry

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/



namespace CodeWalker.GameFiles
{
    public enum RelDatFileType : uint
    {
        Dat4 = 4,
        Dat10ModularSynth = 10,
        Dat15DynamicMixer = 15,
        Dat16Curves = 16,
        Dat22Categories = 22,
        Dat54DataEntries = 54,
        Dat149 = 149,
        Dat150 = 150,
        Dat151 = 151
    }

    [TC(typeof(EXP))]
    public class RelFile : GameFile, PackedFile
    {
        public byte[] RawFileData { get; set; }
        public RelDatFileType RelType { get; set; }
        public uint DataLength { get; set; }
        public byte[] DataBlock { get; set; }
        public uint DataUnkVal { get; set; }
        public uint NameTableLength { get; set; }
        public uint NameTableCount { get; set; }
        public uint[] NameTableOffsets { get; set; }
        public string[] NameTable { get; set; }
        public uint IndexCount { get; set; }
        public uint IndexStringFlags { get; set; } = 2524;
        public RelIndexHash[] IndexHashes { get; set; }
        public RelIndexString[] IndexStrings { get; set; }
        public uint HashTableCount { get; set; }
        public uint[] HashTableOffsets { get; set; }
        public MetaHash[] HashTable { get; set; }
        public uint PackTableCount { get; set; }
        public uint[] PackTableOffsets { get; set; }
        public MetaHash[] PackTable { get; set; }

        public RelData[] RelDatas { get; set; }
        public RelData[] RelDatasSorted { get; set; }
        public Dictionary<uint, RelData> RelDataDict { get; set; } = new Dictionary<uint, RelData>();

        public bool IsAudioConfig { get; set; }


        //fields used by the editor:
        public bool HasChanged { get; set; } = false;
        public List<string> SaveWarnings = null;


        public RelFile() : base(null, GameFileType.Rel)
        {
        }
        public RelFile(RpfFileEntry entry) : base(entry, GameFileType.Rel)
        {
            RpfFileEntry = entry;
        }

        public void Load(byte[] data, RpfFileEntry entry)
        {
            RawFileData = data;
            if (entry != null)
            {
                RpfFileEntry = entry;
                Name = entry.Name;
            }

            MemoryStream ms = new MemoryStream(data);
            BinaryReader br = new BinaryReader(ms);
            StringBuilder sb = new StringBuilder();

            RelType = (RelDatFileType)br.ReadUInt32(); //type

            DataLength = br.ReadUInt32(); //length of data block
            DataBlock = br.ReadBytes((int)DataLength); //main data block...


            NameTableLength = br.ReadUInt32();
            NameTableCount = br.ReadUInt32();
            if (NameTableCount > 0)
            {
                uint[] ntoffsets = new uint[NameTableCount];
                for (uint i = 0; i < NameTableCount; i++)
                {
                    ntoffsets[i] = br.ReadUInt32();
                }
                NameTableOffsets = ntoffsets;


                string[] names = new string[NameTableCount];
                for (uint i = 0; i < NameTableCount; i++)
                {
                    sb.Clear();
                    while (true)
                    {
                        char c = (char)br.ReadByte();
                        if (c != 0) sb.Append(c);
                        else break;
                    }
                    names[i] = sb.ToString();

                    JenkIndex.Ensure(names[i].ToLowerInvariant());
                }
                NameTable = names;
            }

            IndexCount = br.ReadUInt32(); //count of index items
            if (IndexCount > 0)
            {
                if ((RelType == RelDatFileType.Dat4) && (NameTableLength == 4))//audioconfig.dat4.rel    //checking NameTableLength here doesn't make sense!
                {
                    IsAudioConfig = true;
                    IndexStringFlags = br.ReadUInt32(); //what is this?  2524
                    if (IndexStringFlags != 2524)
                    { }
                    RelIndexString[] indexstrs = new RelIndexString[IndexCount];
                    for (uint i = 0; i < IndexCount; i++)
                    {
                        byte sl = br.ReadByte();
                        sb.Clear();
                        for (int j = 0; j < sl; j++)
                        {
                            char c = (char)br.ReadByte();
                            if (c != 0) sb.Append(c);
                        }
                        RelIndexString ristr = new RelIndexString();
                        ristr.Name = sb.ToString();
                        ristr.Offset = br.ReadUInt32();
                        ristr.Length = br.ReadUInt32();
                        indexstrs[i] = ristr;
                        JenkIndex.Ensure(ristr.Name.ToLowerInvariant());
                    }
                    IndexStrings = indexstrs;
                }
                else //for all other .rel files...
                {
                    RelIndexHash[] indexhashes = new RelIndexHash[IndexCount];
                    for (uint i = 0; i < IndexCount; i++)
                    {
                        RelIndexHash rihash = new RelIndexHash();
                        rihash.Name = new MetaHash(br.ReadUInt32());
                        rihash.Offset = br.ReadUInt32();
                        rihash.Length = br.ReadUInt32();
                        indexhashes[i] = rihash;
                    }
                    IndexHashes = indexhashes;
                }
            }


            HashTableCount = br.ReadUInt32();
            if (HashTableCount != 0)
            {
                uint[] htoffsets = new uint[HashTableCount];
                MetaHash[] hthashes = new MetaHash[HashTableCount];
                for (uint i = 0; i < HashTableCount; i++)
                {
                    htoffsets[i] = br.ReadUInt32();

                    var pos = ms.Position;
                    ms.Position = htoffsets[i];
                    hthashes[i] = new MetaHash(br.ReadUInt32());
                    ms.Position = pos;
                }
                HashTableOffsets = htoffsets;
                HashTable = hthashes;
            }

            PackTableCount = br.ReadUInt32();
            if (PackTableCount != 0)
            {
                uint[] ptoffsets = new uint[PackTableCount];
                MetaHash[] pthashes = new MetaHash[PackTableCount];
                for (uint i = 0; i < PackTableCount; i++)
                {
                    ptoffsets[i] = br.ReadUInt32();

                    var pos = ms.Position;
                    ms.Position = ptoffsets[i];
                    pthashes[i] = new MetaHash(br.ReadUInt32());
                    ms.Position = pos;
                }
                PackTableOffsets = ptoffsets;
                PackTable = pthashes;
            }

            if (ms.Position != ms.Length)
            { }
            //EOF!

            br.Dispose();
            ms.Dispose();


            ParseDataBlock();

            //BuildHashMaps();


            Loaded = true;
        }


        private void ParseDataBlock()
        {



            MemoryStream ms = new MemoryStream(DataBlock);
            BinaryReader br = new BinaryReader(ms);

            DataUnkVal = br.ReadUInt32(); //3 bytes used... for? ..version? flags?
            #region DataUnkVal unk values test
            //switch (DataUnkVal)
            //{
            //    case 5252715: //dlcbusiness_amp.dat10.rel
            //    case 5301323: //dlcbeach_game.dat149.rel
            //    case 5378673: //dlcmpheist_game.dat150.rel
            //    case 5750395: //dlcbeach_game.dat150.rel
            //    case 6353778: //dlcbeach_game.dat151.rel
            //    case 6894089: //dlcpilotschool_game.dat151.rel
            //    case 6978435: //dlcxmas2_amp.dat10.rel
            //    case 7126027: //audioconfig.dat4.rel
            //    case 7314721: //dlcmpheist_amp.dat10.rel
            //    case 7516460: //dlcpd03_game.dat151.rel
            //    case 7917027: //dlcluxe_amp.dat10.rel
            //    case 7921508: //dlcluxe_game.dat151.rel
            //    case 8149475: //dlcluxe2_amp.dat10.rel
            //    case 8751734: //dlcsfx1_game.dat151.rel
            //    case 9028036: //dlchalloween_amp.dat10.rel
            //    case 9037528: //dlclowrider_amp.dat10.rel
            //    case 9458585: //dlcapartment_amp.dat10.rel
            //    case 9486222: //dlcapartment_mix.dat15.rel
            //    case 9806108: //mpvalentines2_amp.dat10.rel
            //    case 9813679: //dlcjanuary2016_amp.dat10.rel
            //    case 10269543://dlclow2_amp.dat10.rel
            //    case 10891463://dlcexec1_amp.dat10.rel
            //    case 11171338://dlcstunt_amp.dat10.rel
            //    case 11918985://dlcbiker_amp.dat10.rel
            //    case 12470522://dlcimportexport_amp.dat10.rel
            //    case 12974726://audioconfig.dat4.rel
            //    case 13117164://dlcspecialraces_amp.dat10.rel
            //        break;
            //    default:
            //        break;
            //}
            #endregion


            List<RelData> reldatas = new List<RelData>();
            if (IndexHashes != null)
            {
                foreach (var indexhash in IndexHashes)
                {
                    reldatas.Add(ReadRelData(br, indexhash));
                }
            }
            else if (IndexStrings != null)
            {
                foreach (var indexstr in IndexStrings)
                {
                    reldatas.Add(ReadRelData(br, indexstr));
                }
            }
            RelDatas = reldatas.ToArray();

            reldatas.Sort((d1, d2) => d1.DataOffset.CompareTo(d2.DataOffset));
            RelDatasSorted = reldatas.ToArray();


            br.Dispose();
            ms.Dispose();




            RelDataDict.Clear();
            foreach (var reldata in RelDatas)
            {
                if ((reldata.NameHash == 0) && !string.IsNullOrEmpty(reldata.Name))
                {
                    reldata.NameHash = JenkHash.GenHash(reldata.Name); //should this be lower case?
                    JenkIndex.Ensure(reldata.Name);
                    JenkIndex.Ensure(reldata.Name.ToLowerInvariant()); //which one to use?
                }

                //if (reldata.NameHash == 0)
                //{ }//no hits here
                //if (RelDataDict.ContainsKey(reldata.NameHash))
                //{ }//no hits here

                RelDataDict[reldata.NameHash] = reldata;
            }
            foreach (var reldata in RelDatas)
            {
                RelSound snd = reldata as RelSound;
                if (snd != null)
                {
                    if (snd.ChildSoundsCount > 0)
                    {
                        snd.ChildSounds = new RelData[snd.ChildSoundsCount];
                        for (int i = 0; i < snd.ChildSoundsCount; i++)
                        {
                            var audhash = snd.ChildSoundsHashes[i];
                            RelData auddata = null;
                            if (RelDataDict.TryGetValue(audhash, out auddata))
                            {
                                snd.ChildSounds[i] = auddata;
                            }
                            else
                            { }
                        }
                    }
                    if (snd.AudioContainers != null)
                    {
                        foreach (var cnt in snd.AudioContainers)
                        {
                            string cname = JenkIndex.TryGetString(cnt.Hash);
                            if (!string.IsNullOrEmpty(cname))
                            { }
                            else
                            { }
                        }
                    }
                }
            }


            if ((RelType == RelDatFileType.Dat4) && (!IsAudioConfig))
            {
                //speech.dat4.rel

                var speechDict = new Dictionary<uint, Dat4SpeechData>();
                foreach (var reldata in RelDatasSorted)
                {
                    var speechData = reldata as Dat4SpeechData;
                    if (speechData != null)
                    {
                        speechDict[speechData.DataOffset] = speechData;
                    }
                    else
                    { }


                    speechData.Type = Dat4SpeechType.ByteArray;
                    speechData.TypeID = 0; //will be set again after this

                }
                for (uint i = 0; i < HashTableCount; i++)
                {
                    var hashOffset = HashTableOffsets[i];
                    var hash = HashTable[i];
                    var itemOffset = hashOffset - 8;
                    Dat4SpeechData speechData = null;
                    speechDict.TryGetValue(itemOffset, out speechData);
                    if (speechData != null)
                    {
                        speechData.Type = Dat4SpeechType.Hash;
                        speechData.TypeID = 4;
                        speechData.Hash = hash;
                    }
                    else
                    { }
                }
                for (uint i = 0; i < PackTableCount; i++)
                {
                    var packOffset = PackTableOffsets[i];
                    var pack = PackTable[i];
                    var itemOffset = packOffset - 12;
                    Dat4SpeechData speechData = null;
                    speechDict.TryGetValue(itemOffset, out speechData);
                    if (speechData != null)
                    {
                        speechData.Type = Dat4SpeechType.Container;
                        speechData.TypeID = 8;
                        speechData.ContainerHash = pack;
                    }
                    else
                    { }//shouldn't happen!
                }


            }


        }




        private RelData ReadRelData(BinaryReader br, RelIndexHash h)
        {
            return ReadRelData(br, null, h.Name, h.Offset, h.Length);
        }
        private RelData ReadRelData(BinaryReader br, RelIndexString s)
        {
            return ReadRelData(br, s.Name, JenkHash.GenHash(s.Name.ToLowerInvariant()), s.Offset, s.Length);
        }
        private RelData ReadRelData(BinaryReader br, string name, MetaHash hash, uint offset, uint length)
        {
            br.BaseStream.Position = offset;
            byte[] data = br.ReadBytes((int)length);


            RelData d = new RelData(this); //use this base object to construct the derived one...
            d.Name = name;
            d.NameHash = hash;
            d.DataOffset = offset;
            d.DataLength = length;
            d.Data = data;


            using (BinaryReader dbr = new BinaryReader(new MemoryStream(data)))
            {
                d.ReadType(dbr);

                switch (RelType)
                {
                    case RelDatFileType.Dat4:   //speech.dat4.rel, audioconfig.dat4.rel
                        return ReadData4(d, dbr);
                    case RelDatFileType.Dat10ModularSynth:  //amp.dat10.rel
                        return ReadData10(d, dbr);
                    case RelDatFileType.Dat15DynamicMixer:  //mix.dat15.rel
                        return ReadData15(d, dbr);
                    case RelDatFileType.Dat16Curves:  //curves.dat16.rel
                        return ReadData16(d, dbr);
                    case RelDatFileType.Dat22Categories:  //categories.dat22.rel
                        return ReadData22(d, dbr);
                    case RelDatFileType.Dat54DataEntries:  //sounds.dat54.rel
                        return ReadData54(d, dbr);
                    case RelDatFileType.Dat149: //game.dat149.rel
                        return ReadData149(d, dbr);
                    case RelDatFileType.Dat150: //game.dat150.rel
                        return ReadData150(d, dbr);
                    case RelDatFileType.Dat151: //game.dat151.rel
                        return ReadData151(d, dbr);
                    default:
                        return d; //shouldn't get here...
                }
            }
        }



        private RelData ReadData4(RelData d, BinaryReader br)
        {
            if (IsAudioConfig) //(for audioconfig.dat4.rel)
            {
                switch ((Dat4ConfigType)d.TypeID)
                {
                    case Dat4ConfigType.Int: return new Dat4ConfigInt(d, br);
                    case Dat4ConfigType.UnsignedInt: return new Dat4ConfigUnsignedInt(d, br);
                    case Dat4ConfigType.Float: return new Dat4ConfigFloat(d, br);
                    case Dat4ConfigType.String: return new Dat4ConfigString(d, br);
                    case Dat4ConfigType.Vector3: return new Dat4ConfigVector3(d, br);
                    case Dat4ConfigType.VariableList: return new Dat4ConfigVariableList(d, br);
                    case Dat4ConfigType.WaveSlot: return new Dat4ConfigWaveSlot(d, br);
                    case Dat4ConfigType.WaveSlotsList: return new Dat4ConfigWaveSlotsList(d, br);
                    case Dat4ConfigType.ERSettings: return new Dat4ConfigERSettings(d, br);
                    default:
                        break;
                }
            }
            else //(for eg speech.dat4.rel)
            {
                return new Dat4SpeechData(d, br);
            }
            return d;
        }
        private RelData ReadData10(RelData d, BinaryReader br)
        {
            switch ((Dat10RelType)d.TypeID)
            {
                case Dat10RelType.SynthPreset: return new Dat10SynthPreset(d, br);
                case Dat10RelType.Synth: return new Dat10Synth(d, br);
                default:
                    break;
            }

            return d;
        }
        private RelData ReadData15(RelData d, BinaryReader br)
        {
            switch ((Dat15RelType)d.TypeID)
            {
                case Dat15RelType.Patch: return new Dat15Patch(d, br);
                case Dat15RelType.SceneState: return new Dat15SceneState(d, br);
                case Dat15RelType.Scene: return new Dat15Scene(d, br);
                case Dat15RelType.Group: return new Dat15Group(d, br);
                case Dat15RelType.GroupList: return new Dat15GroupList(d, br);
                case Dat15RelType.DynamicMixModuleSettings: return new Dat15DynamicMixModuleSettings(d, br);
                case Dat15RelType.SceneVariableModuleSettings: return new Dat15SceneVariableModuleSettings(d, br);
                case Dat15RelType.SceneTransitionModuleSettings: return new Dat15SceneTransitionModuleSettings(d, br);
                case Dat15RelType.VehicleCollisionModuleSettings: return new Dat15VehicleCollisionModuleSettings(d, br);
                case Dat15RelType.GroupMap: return new Dat15GroupMap(d, br);
                default:
                    break;
            }

            return d;
        }
        private RelData ReadData16(RelData d, BinaryReader br)
        {
            switch ((Dat16RelType)d.TypeID)
            {
                case Dat16RelType.ConstantCurve: return new Dat16ConstantCurve(d, br);
                case Dat16RelType.LinearCurve: return new Dat16LinearCurve(d, br);
                case Dat16RelType.LinearDbCurve: return new Dat16LinearDbCurve(d, br);
                case Dat16RelType.PiecewiseLinearCurve: return new Dat16PiecewiseLinearCurve(d, br);
                case Dat16RelType.EqualPowerCurve: return new Dat16EqualPowerCurve(d, br);
                case Dat16RelType.ValueTableCurve: return new Dat16ValueTableCurve(d, br);
                case Dat16RelType.ExponentialCurve: return new Dat16ExponentialCurve(d, br);
                case Dat16RelType.DecayingExponentialCurve: return new Dat16DecayingExponentialCurve(d, br);
                case Dat16RelType.DecayingSquaredExponentialCurve: return new Dat16DecayingSquaredExponentialCurve(d, br);
                case Dat16RelType.SineCurve: return new Dat16SineCurve(d, br);
                case Dat16RelType.OneOverXSquaredCurve: return new Dat16OneOverXSquaredCurve(d, br);
                case Dat16RelType.DefaultDistanceAttenuationCurve: return new Dat16DefaultDistanceAttenuationCurve(d, br);
                case Dat16RelType.DistanceAttenuationValueTableCurve: return new Dat16DistanceAttenuationValueTableCurve(d, br);
                default:
                    break;
            }

            return d;
        }
        private RelData ReadData22(RelData d, BinaryReader br)
        {
            switch ((Dat22RelType)d.TypeID)
            {
                case Dat22RelType.Category: return new Dat22Category(d, br);
                default:
                    break;
            }

            return d;
        }
        private RelData ReadData54(RelData d, BinaryReader br)
        {
            switch ((Dat54SoundType)d.TypeID)
            {
                case Dat54SoundType.LoopingSound: return new Dat54LoopingSound(d, br);
                case Dat54SoundType.EnvelopeSound: return new Dat54EnvelopeSound(d, br);
                case Dat54SoundType.TwinLoopSound: return new Dat54TwinLoopSound(d, br);
                case Dat54SoundType.SpeechSound: return new Dat54SpeechSound(d, br);
                case Dat54SoundType.OnStopSound: return new Dat54OnStopSound(d, br);
                case Dat54SoundType.WrapperSound: return new Dat54WrapperSound(d, br);
                case Dat54SoundType.SequentialSound: return new Dat54SequentialSound(d, br);
                case Dat54SoundType.StreamingSound: return new Dat54StreamingSound(d, br);
                case Dat54SoundType.RetriggeredOverlappedSound: return new Dat54RetriggeredOverlappedSound(d, br);
                case Dat54SoundType.CrossfadeSound: return new Dat54CrossfadeSound(d, br);
                case Dat54SoundType.CollapsingStereoSound: return new Dat54CollapsingStereoSound(d, br);
                case Dat54SoundType.SimpleSound: return new Dat54SimpleSound(d, br);
                case Dat54SoundType.MultitrackSound: return new Dat54MultitrackSound(d, br);
                case Dat54SoundType.RandomizedSound: return new Dat54RandomizedSound(d, br);
                case Dat54SoundType.EnvironmentSound: return new Dat54EnvironmentSound(d, br);
                case Dat54SoundType.DynamicEntitySound: return new Dat54DynamicEntitySound(d, br);
                case Dat54SoundType.SequentialOverlapSound: return new Dat54SequentialOverlapSound(d, br);
                case Dat54SoundType.ModularSynthSound: return new Dat54ModularSynthSound(d, br);
                case Dat54SoundType.GranularSound: return new Dat54GranularSound(d, br);
                case Dat54SoundType.DirectionalSound: return new Dat54DirectionalSound(d, br);
                case Dat54SoundType.KineticSound: return new Dat54KineticSound(d, br);
                case Dat54SoundType.SwitchSound: return new Dat54SwitchSound(d, br);
                case Dat54SoundType.VariableCurveSound: return new Dat54VariableCurveSound(d, br);
                case Dat54SoundType.VariablePrintValueSound: return new Dat54VariablePrintValueSound(d, br);
                case Dat54SoundType.VariableBlockSound: return new Dat54VariableBlockSound(d, br);
                case Dat54SoundType.IfSound: return new Dat54IfSound(d, br);
                case Dat54SoundType.MathOperationSound: return new Dat54MathOperationSound(d, br);
                case Dat54SoundType.ParameterTransformSound: return new Dat54ParameterTransformSound(d, br);
                case Dat54SoundType.FluctuatorSound: return new Dat54FluctuatorSound(d, br);
                case Dat54SoundType.AutomationSound: return new Dat54AutomationSound(d, br);
                case Dat54SoundType.ExternalStreamSound: return new Dat54ExternalStreamSound(d, br);
                case Dat54SoundType.SoundSet: return new Dat54SoundSet(d, br);
                case Dat54SoundType.AutomationNoteMapSound: return new Dat54AutomationNoteMapSound(d, br);
                case Dat54SoundType.SoundSetList: return new Dat54SoundSetList(d, br);
                case Dat54SoundType.SoundHashList: return new Dat54SoundHashList(d, br);
                default:
                    return new Dat54Sound(d, br); //shouldn't get here
            }
        }
        private RelData ReadData149(RelData d, BinaryReader br)
        {
            return ReadData151(d, br);//same as 151?
        }
        private RelData ReadData150(RelData d, BinaryReader br)
        {
            return ReadData151(d, br);//same as 151?
        }
        private RelData ReadData151(RelData d, BinaryReader br)
        {
            switch ((Dat151RelType)d.TypeID)
            {
                case Dat151RelType.StaticEmitterList: return new Dat151StaticEmitterList(d, br);
                case Dat151RelType.AmbientZone: return new Dat151AmbientZone(d, br);
                case Dat151RelType.AmbientRule: return new Dat151AmbientRule(d, br);
                case Dat151RelType.AmbientZoneList: return new Dat151AmbientZoneList(d, br);
                case Dat151RelType.VehicleCollisionSettings: return new Dat151VehicleCollisionSettings(d, br);
                case Dat151RelType.ItemAudioSettings: return new Dat151ItemAudioSettings(d, br);
                case Dat151RelType.StartTrackAction: return new Dat151StartTrackAction(d, br);
                case Dat151RelType.StopTrackAction: return new Dat151StopTrackAction(d, br);
                case Dat151RelType.InteractiveMusicMood: return new Dat151InteractiveMusicMood(d, br);
                case Dat151RelType.SetMoodAction: return new Dat151SetMoodAction(d, br);
                case Dat151RelType.MusicEvent: return new Dat151MusicEvent(d, br);
                case Dat151RelType.StartOneShotAction: return new Dat151StartOneShotAction(d, br);
                case Dat151RelType.StopOneShotAction: return new Dat151StopOneShotAction(d, br);
                case Dat151RelType.FadeOutRadioAction: return new Dat151FadeOutRadioAction(d, br);
                case Dat151RelType.FadeInRadioAction: return new Dat151FadeInRadioAction(d, br);
                case Dat151RelType.ModelAudioCollisionSettings: return new Dat151ModelAudioCollisionSettings(d, br);
                case Dat151RelType.InteriorSettings: return new Dat151InteriorSettings(d, br);
                case Dat151RelType.InteriorRoom: return new Dat151InteriorRoom(d, br);
                case Dat151RelType.DoorAudioSettingsLink: return new Dat151DoorAudioSettingsLink(d, br);
                case Dat151RelType.CollisionMaterialSettings: return new Dat151CollisionMaterialSettings(d, br);
                case Dat151RelType.DoorAudioSettings: return new Dat151DoorAudioSettings(d, br);
                case Dat151RelType.AnimalFootstepReference: return new Dat151AnimalFootstepReference(d, br);
                case Dat151RelType.RadioDJSpeechAction: return new Dat151RadioDjSpeechAction(d, br);
                case Dat151RelType.ForceRadioTrackAction: return new Dat151ForceRadioTrackAction(d, br);
                case Dat151RelType.MicrophoneSettingsReference: return new Dat151MicrophoneSettingsReference(d, br);
                case Dat151RelType.RadioStationList: return new Dat151RadioStationList(d, br);
                case Dat151RelType.RadioStationSettings: return new Dat151RadioStationSettings(d, br);
                case Dat151RelType.RadioStationTrackList: return new Dat151RadioStationTrackList(d, br);
                case Dat151RelType.ReplayRadioStationTrackList: return new Dat151ReplayRadioStationTrackList(d, br);
                case Dat151RelType.DoorList: return new Dat151DoorList(d, br);
                case Dat151RelType.ShoeList: return new Dat151ShoeList(d, br);
                case Dat151RelType.ClothList: return new Dat151ClothList(d, br);
                case Dat151RelType.CarRecordingList: return new Dat151CarRecordingList(d, br);
                case Dat151RelType.WeatherTypeAudioReference: return new Dat151WeatherTypeAudioSettingsAudioReference(d, br);
                case Dat151RelType.ShoreLinePoolAudioSettings: return new Dat151ShoreLinePoolAudioSettings(d, br);
                case Dat151RelType.ShoreLineLakeAudioSettings: return new Dat151ShoreLineLakeAudioSettings(d, br);
                case Dat151RelType.ShoreLineRiverAudioSettings: return new Dat151ShoreLineRiverAudioSettings(d, br);
                case Dat151RelType.ShoreLineOceanAudioSettings: return new Dat151ShoreLineOceanAudioSettings(d, br);
                case Dat151RelType.ShoreLineList: return new Dat151ShoreLineList(d, br);
                case Dat151RelType.RadioTrackTextIDs: return new Dat151RadioTrackTextIDs(d, br);
                case Dat151RelType.GranularEngineAudioSettings: return new Dat151GranularEngineAudioSettings(d, br);
                case Dat151RelType.CarAudioSettings: return new Dat151CarAudioSettings(d, br);
                case Dat151RelType.VehicleEngineAudioSettings: return new Dat151VehicleEngineAudioSettings(d, br);
                case Dat151RelType.ScannerVehicleParams: return new Dat151ScannerVehicleParams(d, br);
                case Dat151RelType.StaticEmitter: return new Dat151StaticEmitter(d, br);
                case Dat151RelType.WeaponSettings: return new Dat151WeaponSettings(d, br);
                case Dat151RelType.ExplosionAudioSettings: return new Dat151ExplosionAudioSettings(d, br);
                case Dat151RelType.PedVoiceGroups: return new Dat151PedVoiceGroups(d, br);
                case Dat151RelType.EntityEmitter: return new Dat151EntityEmitter(d, br);
                case Dat151RelType.BoatAudioSettings: return new Dat151BoatAudioSettings(d, br);
                case Dat151RelType.BicycleAudioSettings: return new Dat151BicycleAudioSettings(d, br);
                case Dat151RelType.PlaneAudioSettings: return new Dat151PlaneAudioSettings(d, br);
                case Dat151RelType.HeliAudioSettings: return new Dat151HeliAudioSettings(d, br);
                case Dat151RelType.TrailerAudioSettings: return new Dat151TrailerAudioSettings(d, br);
                case Dat151RelType.TrainAudioSettings: return new Dat151TrainAudioSettings(d, br);
                case Dat151RelType.AnimalParams: return new Dat151AnimalParams(d, br);
                case Dat151RelType.SpeechParams: return new Dat151SpeechParams(d, br);
                case Dat151RelType.MeleeCombatSettings: return new Dat151MeleeCombatSettings(d, br);
                case Dat151RelType.TriggeredSpeechContext: return new Dat151TriggeredSpeechContext(d, br);
                case Dat151RelType.SpeechContext: return new Dat151SpeechContext(d, br);
                case Dat151RelType.SpeechContextVirtual: return new Dat151SpeechContextVirtual(d, br);
                case Dat151RelType.SpeechContextList: return new Dat151SpeechContextList(d, br);
                case Dat151RelType.ShoeAudioSettings: return new Dat151ShoeAudioSettings(d, br);
                case Dat151RelType.ModelPhysicsParams: return new Dat151ModelPhysicsParams(d, br);
                case Dat151RelType.SkiAudioSettings: return new Dat151SkiAudioSettings(d, br);
                case Dat151RelType.RadioTrackCategoryData: return new Dat151RadioTrackCategoryData(d, br);
                case Dat151RelType.ScannerCrimeReport: return new Dat151ScannerCrimeReport(d, br);
                case Dat151RelType.PedRaceToPedVoiceGroup: return new Dat151PedRaceToPedVoiceGroup(d, br);
                case Dat151RelType.FriendGroup: return new Dat151FriendGroup(d, br);
                case Dat151RelType.ScriptedScannerLine: return new Dat151ScriptedScannerLine(d, br);
                case Dat151RelType.ScannerSpecificLocation: return new Dat151ScannerSpecificLocation(d, br);
                case Dat151RelType.ScannerSpecificLocationList: return new Dat151ScannerSpecificLocationList(d, br);
                case Dat151RelType.AmbientSlotMap: return new Dat151AmbientSlotMap(d, br);
                case Dat151RelType.AmbientBankMap: return new Dat151AmbientBankMap(d, br);
                case Dat151RelType.EnvironmentRule: return new Dat151EnvironmentRule(d, br);
                case Dat151RelType.InteriorWeaponMetrics: return new Dat151InteriorWeaponMetrics(d, br);
                case Dat151RelType.DoorTuningParams: return new Dat151DoorTuningParams(d, br);
                case Dat151RelType.ClimbingAudioSettings: return new Dat151ClimbingAudioSettings(d, br);
                case Dat151RelType.WeatherAudioSettings: return new Dat151WeatherAudioSettings(d, br);
                case Dat151RelType.StemMix: return new Dat151StemMix(d, br);
                case Dat151RelType.BeatConstraint: return new Dat151BeatConstraint(d, br);
                case Dat151RelType.BarConstraint: return new Dat151BarConstraint(d, br);
                case Dat151RelType.DirectionalAmbience: return new Dat151DirectionalAmbience(d, br);
                case Dat151RelType.GunfightConductorIntensitySettings: return new Dat151GunfightConductorIntensitySettings(d, br);
                case Dat151RelType.AnimalVocalAnimTrigger: return new Dat151AnimalVocalAnimTrigger(d, br);
                case Dat151RelType.ScannerVoiceParams: return new Dat151ScannerVoiceParams(d, br);
                case Dat151RelType.AudioRoadInfo: return new Dat151AudioRoadInfo(d, br);
                case Dat151RelType.MicrophoneSettings: return new Dat151MicrophoneSettings(d, br);
                case Dat151RelType.CarRecordingAudioSettings: return new Dat151CarRecordingAudioSettings(d, br);
                case Dat151RelType.AnimalFootstepSettings: return new Dat151AnimalFootstepSettings(d, br);
                case Dat151RelType.ClothAudioSettings: return new Dat151ClothAudioSettings(d, br);
                case Dat151RelType.RadioTrackSettings: return new Dat151RadioTrackSettings(d, br);
                case Dat151RelType.ModelFootStepTuning: return new Dat151ModelFootStepTuning(d, br);
                case Dat151RelType.SilenceConstraint: return new Dat151SilenceConstraint(d, br);
                case Dat151RelType.ReflectionsSettings: return new Dat151ReflectionsSettings(d, br);
                case Dat151RelType.AlarmSettings: return new Dat151AlarmSettings(d, br);
                case Dat151RelType.SlowMoSettings: return new Dat151SlowMoSettings(d, br);
                case Dat151RelType.PedScenarioAudioSettings: return new Dat151PedScenarioAudioSettings(d, br);
                case Dat151RelType.PortalSettings: return new Dat151PortalSettings(d, br);
                case Dat151RelType.ElectricEngineAudioSettings: return new Dat151ElectricEngineAudioSettings(d, br);
                case Dat151RelType.PlayerBreathingSettings: return new Dat151PlayerBreathingSettings(d, br);
                case Dat151RelType.PedWallaSpeechSettings: return new Dat151PedWallaSpeechSettings(d, br);
                case Dat151RelType.AircraftWarningSettings: return new Dat151AircraftWarningSettings(d, br);
                case Dat151RelType.PedWallaSpeechSettingsList: return new Dat151PedWallaSpeechSettingsList(d, br);
                case Dat151RelType.CopDispatchInteractionSettings: return new Dat151CopDispatchInteractionSettings(d, br);
                case Dat151RelType.RandomisedRadioEmitterSettings: return new Dat151RandomisedRadioEmitterSettings(d, br);
                case Dat151RelType.TennisVocalizationSettings: return new Dat151TennisVocalizationSettings(d, br);
                case Dat151RelType.SportsCarRevsSettings: return new Dat151SportsCarRevsSettings(d, br);
                case Dat151RelType.FoliageSettings: return new Dat151FoliageSettings(d, br);
                case Dat151RelType.ModelAudioCollisionSettingsOverrideList: return new Dat151ModelAudioCollisionSettingsOverrideList(d, br);
                case Dat151RelType.GameObjectHashList: return new Dat151GameObjectHashList(d, br);
                default:
                    return new Dat151RelData(d, br); //shouldn't get here
            }
        }


        public RelData CreateRelData(RelDatFileType relType, int dataType)
        {
            RelData d = null;
            switch (relType)
            {
                case RelDatFileType.Dat54DataEntries:
                    switch ((Dat54SoundType)dataType)
                    {
                        case Dat54SoundType.LoopingSound: return new Dat54LoopingSound(this);
                        case Dat54SoundType.EnvelopeSound: return new Dat54EnvelopeSound(this);
                        case Dat54SoundType.TwinLoopSound: return new Dat54TwinLoopSound(this);
                        case Dat54SoundType.SpeechSound: return new Dat54SpeechSound(this);
                        case Dat54SoundType.OnStopSound: return new Dat54OnStopSound(this);
                        case Dat54SoundType.WrapperSound: return new Dat54WrapperSound(this);
                        case Dat54SoundType.SequentialSound: return new Dat54SequentialSound(this);
                        case Dat54SoundType.StreamingSound: return new Dat54StreamingSound(this);
                        case Dat54SoundType.RetriggeredOverlappedSound: return new Dat54RetriggeredOverlappedSound(this);
                        case Dat54SoundType.CrossfadeSound: return new Dat54CrossfadeSound(this);
                        case Dat54SoundType.CollapsingStereoSound: return new Dat54CollapsingStereoSound(this);
                        case Dat54SoundType.SimpleSound: return new Dat54SimpleSound(this);
                        case Dat54SoundType.MultitrackSound: return new Dat54MultitrackSound(this);
                        case Dat54SoundType.RandomizedSound: return new Dat54RandomizedSound(this);
                        case Dat54SoundType.EnvironmentSound: return new Dat54EnvironmentSound(this);
                        case Dat54SoundType.DynamicEntitySound: return new Dat54DynamicEntitySound(this);
                        case Dat54SoundType.SequentialOverlapSound: return new Dat54SequentialOverlapSound(this);
                        case Dat54SoundType.ModularSynthSound: return new Dat54ModularSynthSound(this);
                        case Dat54SoundType.GranularSound: return new Dat54GranularSound(this);
                        case Dat54SoundType.DirectionalSound: return new Dat54DirectionalSound(this);
                        case Dat54SoundType.KineticSound: return new Dat54KineticSound(this);
                        case Dat54SoundType.SwitchSound: return new Dat54SwitchSound(this);
                        case Dat54SoundType.VariableCurveSound: return new Dat54VariableCurveSound(this);
                        case Dat54SoundType.VariablePrintValueSound: return new Dat54VariablePrintValueSound(this);
                        case Dat54SoundType.VariableBlockSound: return new Dat54VariableBlockSound(this);
                        case Dat54SoundType.IfSound: return new Dat54IfSound(this);
                        case Dat54SoundType.MathOperationSound: return new Dat54MathOperationSound(this);
                        case Dat54SoundType.ParameterTransformSound: return new Dat54ParameterTransformSound(this);
                        case Dat54SoundType.FluctuatorSound: return new Dat54FluctuatorSound(this);
                        case Dat54SoundType.AutomationSound: return new Dat54AutomationSound(this);
                        case Dat54SoundType.ExternalStreamSound: return new Dat54ExternalStreamSound(this);
                        case Dat54SoundType.SoundSet: return new Dat54SoundSet(this);
                        case Dat54SoundType.AutomationNoteMapSound: return new Dat54AutomationNoteMapSound(this);
                        case Dat54SoundType.SoundSetList: return new Dat54SoundSetList(this);
                        case Dat54SoundType.SoundHashList: return new Dat54SoundHashList(this);
                        default:
                            return new Dat54Sound(this, (Dat54SoundType)d.TypeID); //shouldn't get here
                    }
                case RelDatFileType.Dat149:
                case RelDatFileType.Dat150:
                case RelDatFileType.Dat151:
                    switch ((Dat151RelType)dataType)
                    {
                        case Dat151RelType.StaticEmitterList: return new Dat151StaticEmitterList(this);
                        case Dat151RelType.AmbientZone: return new Dat151AmbientZone(this);
                        case Dat151RelType.AmbientRule: return new Dat151AmbientRule(this);
                        case Dat151RelType.AmbientZoneList: return new Dat151AmbientZoneList(this);
                        case Dat151RelType.VehicleCollisionSettings: return new Dat151VehicleCollisionSettings(this);
                        case Dat151RelType.ItemAudioSettings: return new Dat151ItemAudioSettings(this);
                        case Dat151RelType.StartTrackAction: return new Dat151StartTrackAction(this);
                        case Dat151RelType.StopTrackAction: return new Dat151StopTrackAction(this);
                        case Dat151RelType.InteractiveMusicMood: return new Dat151InteractiveMusicMood(this);
                        case Dat151RelType.SetMoodAction: return new Dat151SetMoodAction(this);
                        case Dat151RelType.MusicEvent: return new Dat151MusicEvent(this);
                        case Dat151RelType.StartOneShotAction: return new Dat151StartOneShotAction(this);
                        case Dat151RelType.StopOneShotAction: return new Dat151StopOneShotAction(this);
                        case Dat151RelType.FadeOutRadioAction: return new Dat151FadeOutRadioAction(this);
                        case Dat151RelType.FadeInRadioAction: return new Dat151FadeInRadioAction(this);
                        case Dat151RelType.ModelAudioCollisionSettings: return new Dat151ModelAudioCollisionSettings(this);
                        case Dat151RelType.InteriorSettings: return new Dat151InteriorSettings(this);
                        case Dat151RelType.InteriorRoom: return new Dat151InteriorRoom(this);
                        case Dat151RelType.DoorAudioSettingsLink: return new Dat151DoorAudioSettingsLink(this);
                        case Dat151RelType.CollisionMaterialSettings: return new Dat151CollisionMaterialSettings(this);
                        case Dat151RelType.DoorAudioSettings: return new Dat151DoorAudioSettings(this);
                        case Dat151RelType.AnimalFootstepReference: return new Dat151AnimalFootstepReference(this);
                        case Dat151RelType.RadioDJSpeechAction: return new Dat151RadioDjSpeechAction(this);
                        case Dat151RelType.ForceRadioTrackAction: return new Dat151ForceRadioTrackAction(this);
                        case Dat151RelType.MicrophoneSettingsReference: return new Dat151MicrophoneSettingsReference(this);
                        case Dat151RelType.RadioStationList: return new Dat151RadioStationList(this);
                        case Dat151RelType.RadioStationSettings: return new Dat151RadioStationSettings(this);
                        case Dat151RelType.RadioStationTrackList: return new Dat151RadioStationTrackList(this);
                        case Dat151RelType.ReplayRadioStationTrackList: return new Dat151ReplayRadioStationTrackList(this);
                        case Dat151RelType.DoorList: return new Dat151DoorList(this);
                        case Dat151RelType.ShoeList: return new Dat151ShoeList(this);
                        case Dat151RelType.ClothList: return new Dat151ClothList(this);
                        case Dat151RelType.CarRecordingList: return new Dat151CarRecordingList(this);
                        case Dat151RelType.WeatherTypeAudioReference: return new Dat151WeatherTypeAudioSettingsAudioReference(this);
                        case Dat151RelType.ShoreLinePoolAudioSettings: return new Dat151ShoreLinePoolAudioSettings(this);
                        case Dat151RelType.ShoreLineLakeAudioSettings: return new Dat151ShoreLineLakeAudioSettings(this);
                        case Dat151RelType.ShoreLineRiverAudioSettings: return new Dat151ShoreLineRiverAudioSettings(this);
                        case Dat151RelType.ShoreLineOceanAudioSettings: return new Dat151ShoreLineOceanAudioSettings(this);
                        case Dat151RelType.ShoreLineList: return new Dat151ShoreLineList(this);
                        case Dat151RelType.RadioTrackTextIDs: return new Dat151RadioTrackTextIDs(this);
                        case Dat151RelType.GranularEngineAudioSettings: return new Dat151GranularEngineAudioSettings(this);
                        case Dat151RelType.CarAudioSettings: return new Dat151CarAudioSettings(this);
                        case Dat151RelType.VehicleEngineAudioSettings: return new Dat151VehicleEngineAudioSettings(this);
                        case Dat151RelType.ScannerVehicleParams: return new Dat151ScannerVehicleParams(this);
                        case Dat151RelType.StaticEmitter: return new Dat151StaticEmitter(this);
                        case Dat151RelType.WeaponSettings: return new Dat151WeaponSettings(this);
                        case Dat151RelType.ExplosionAudioSettings: return new Dat151ExplosionAudioSettings(this);
                        case Dat151RelType.PedVoiceGroups: return new Dat151PedVoiceGroups(this);
                        case Dat151RelType.EntityEmitter: return new Dat151EntityEmitter(this);
                        case Dat151RelType.BoatAudioSettings: return new Dat151BoatAudioSettings(this);
                        case Dat151RelType.BicycleAudioSettings: return new Dat151BicycleAudioSettings(this);
                        case Dat151RelType.PlaneAudioSettings: return new Dat151PlaneAudioSettings(this);
                        case Dat151RelType.HeliAudioSettings: return new Dat151HeliAudioSettings(this);
                        case Dat151RelType.TrailerAudioSettings: return new Dat151TrailerAudioSettings(this);
                        case Dat151RelType.TrainAudioSettings: return new Dat151TrainAudioSettings(this);
                        case Dat151RelType.AnimalParams: return new Dat151AnimalParams(this);
                        case Dat151RelType.SpeechParams: return new Dat151SpeechParams(this);
                        case Dat151RelType.MeleeCombatSettings: return new Dat151MeleeCombatSettings(this);
                        case Dat151RelType.TriggeredSpeechContext: return new Dat151TriggeredSpeechContext(this);
                        case Dat151RelType.SpeechContext: return new Dat151SpeechContext(this);
                        case Dat151RelType.SpeechContextVirtual: return new Dat151SpeechContextVirtual(this);
                        case Dat151RelType.SpeechContextList: return new Dat151SpeechContextList(this);
                        case Dat151RelType.ShoeAudioSettings: return new Dat151ShoeAudioSettings(this);
                        case Dat151RelType.ModelPhysicsParams: return new Dat151ModelPhysicsParams(this);
                        case Dat151RelType.SkiAudioSettings: return new Dat151SkiAudioSettings(this);
                        case Dat151RelType.RadioTrackCategoryData: return new Dat151RadioTrackCategoryData(this);
                        case Dat151RelType.ScannerCrimeReport: return new Dat151ScannerCrimeReport(this);
                        case Dat151RelType.PedRaceToPedVoiceGroup: return new Dat151PedRaceToPedVoiceGroup(this);
                        case Dat151RelType.FriendGroup: return new Dat151FriendGroup(this);
                        case Dat151RelType.ScriptedScannerLine: return new Dat151ScriptedScannerLine(this);
                        case Dat151RelType.ScannerSpecificLocation: return new Dat151ScannerSpecificLocation(this);
                        case Dat151RelType.ScannerSpecificLocationList: return new Dat151ScannerSpecificLocationList(this);
                        case Dat151RelType.AmbientSlotMap: return new Dat151AmbientSlotMap(this);
                        case Dat151RelType.AmbientBankMap: return new Dat151AmbientBankMap(this);
                        case Dat151RelType.EnvironmentRule: return new Dat151EnvironmentRule(this);
                        case Dat151RelType.InteriorWeaponMetrics: return new Dat151InteriorWeaponMetrics(this);
                        case Dat151RelType.DoorTuningParams: return new Dat151DoorTuningParams(this);
                        case Dat151RelType.ClimbingAudioSettings: return new Dat151ClimbingAudioSettings(this);
                        case Dat151RelType.WeatherAudioSettings: return new Dat151WeatherAudioSettings(this);
                        case Dat151RelType.StemMix: return new Dat151StemMix(this);
                        case Dat151RelType.BeatConstraint: return new Dat151BeatConstraint(this);
                        case Dat151RelType.BarConstraint: return new Dat151BarConstraint(this);
                        case Dat151RelType.DirectionalAmbience: return new Dat151DirectionalAmbience(this);
                        case Dat151RelType.GunfightConductorIntensitySettings: return new Dat151GunfightConductorIntensitySettings(this);
                        case Dat151RelType.AnimalVocalAnimTrigger: return new Dat151AnimalVocalAnimTrigger(this);
                        case Dat151RelType.ScannerVoiceParams: return new Dat151ScannerVoiceParams(this);
                        case Dat151RelType.AudioRoadInfo: return new Dat151AudioRoadInfo(this);
                        case Dat151RelType.MicrophoneSettings: return new Dat151MicrophoneSettings(this);
                        case Dat151RelType.CarRecordingAudioSettings: return new Dat151CarRecordingAudioSettings(this);
                        case Dat151RelType.AnimalFootstepSettings: return new Dat151AnimalFootstepSettings(this);
                        case Dat151RelType.ClothAudioSettings: return new Dat151ClothAudioSettings(this);
                        case Dat151RelType.RadioTrackSettings: return new Dat151RadioTrackSettings(this);
                        case Dat151RelType.ModelFootStepTuning: return new Dat151ModelFootStepTuning(this);
                        case Dat151RelType.SilenceConstraint: return new Dat151SilenceConstraint(this);
                        case Dat151RelType.ReflectionsSettings: return new Dat151ReflectionsSettings(this);
                        case Dat151RelType.AlarmSettings: return new Dat151AlarmSettings(this);
                        case Dat151RelType.SlowMoSettings: return new Dat151SlowMoSettings(this);
                        case Dat151RelType.PedScenarioAudioSettings: return new Dat151PedScenarioAudioSettings(this);
                        case Dat151RelType.PortalSettings: return new Dat151PortalSettings(this);
                        case Dat151RelType.ElectricEngineAudioSettings: return new Dat151ElectricEngineAudioSettings(this);
                        case Dat151RelType.PlayerBreathingSettings: return new Dat151PlayerBreathingSettings(this);
                        case Dat151RelType.PedWallaSpeechSettings: return new Dat151PedWallaSpeechSettings(this);
                        case Dat151RelType.AircraftWarningSettings: return new Dat151AircraftWarningSettings(this);
                        case Dat151RelType.PedWallaSpeechSettingsList: return new Dat151PedWallaSpeechSettingsList(this);
                        case Dat151RelType.CopDispatchInteractionSettings: return new Dat151CopDispatchInteractionSettings(this);
                        case Dat151RelType.RandomisedRadioEmitterSettings: return new Dat151RandomisedRadioEmitterSettings(this);
                        case Dat151RelType.TennisVocalizationSettings: return new Dat151TennisVocalizationSettings(this);
                        case Dat151RelType.SportsCarRevsSettings: return new Dat151SportsCarRevsSettings(this);
                        case Dat151RelType.FoliageSettings: return new Dat151FoliageSettings(this);
                        case Dat151RelType.ModelAudioCollisionSettingsOverrideList: return new Dat151ModelAudioCollisionSettingsOverrideList(this);
                        case Dat151RelType.GameObjectHashList: return new Dat151GameObjectHashList(this);
                        default:
                            return new Dat151RelData(this, (Dat151RelType)dataType); //shouldn't get here
                    }
                case RelDatFileType.Dat4:
                    if (IsAudioConfig)
                    {
                        switch ((Dat4ConfigType)dataType)
                        {
                            case Dat4ConfigType.Int: return new Dat4ConfigInt(this);
                            case Dat4ConfigType.UnsignedInt: return new Dat4ConfigUnsignedInt(this);
                            case Dat4ConfigType.Float: return new Dat4ConfigFloat(this);
                            case Dat4ConfigType.String: return new Dat4ConfigString(this);
                            case Dat4ConfigType.Vector3: return new Dat4ConfigVector3(this);
                            case Dat4ConfigType.VariableList: return new Dat4ConfigVariableList(this);
                            case Dat4ConfigType.WaveSlot: return new Dat4ConfigWaveSlot(this);
                            case Dat4ConfigType.WaveSlotsList: return new Dat4ConfigWaveSlotsList(this);
                            case Dat4ConfigType.ERSettings: return new Dat4ConfigERSettings(this);
                            default:
                                d = new RelData(this);
                                d.TypeID = (byte)dataType;
                                return d;
                        }
                    }
                    else
                    {
                        d = new Dat4SpeechData(this);
                        d.TypeID = (byte)dataType;
                        (d as Dat4SpeechData).Type = (Dat4SpeechType)dataType;
                        return d;
                    }
                case RelDatFileType.Dat10ModularSynth:
                    switch ((Dat10RelType)dataType)
                    {
                        case Dat10RelType.SynthPreset: return new Dat10SynthPreset(this);
                        case Dat10RelType.Synth: return new Dat10Synth(this);
                        default:
                            return new Dat10RelData(this);//shouldn't get here
                    }
                case RelDatFileType.Dat15DynamicMixer:
                    switch ((Dat15RelType)dataType)
                    {
                        case Dat15RelType.Patch: return new Dat15Patch(this);
                        case Dat15RelType.SceneState: return new Dat15SceneState(this);
                        case Dat15RelType.Scene: return new Dat15Scene(this);
                        case Dat15RelType.Group: return new Dat15Group(this);
                        case Dat15RelType.GroupList: return new Dat15GroupList(this);
                        case Dat15RelType.DynamicMixModuleSettings: return new Dat15DynamicMixModuleSettings(this);
                        case Dat15RelType.SceneVariableModuleSettings: return new Dat15SceneVariableModuleSettings(this);
                        case Dat15RelType.SceneTransitionModuleSettings: return new Dat15SceneTransitionModuleSettings(this);
                        case Dat15RelType.VehicleCollisionModuleSettings: return new Dat15VehicleCollisionModuleSettings(this);
                        case Dat15RelType.GroupMap: return new Dat15GroupMap(this);
                        default:
                            return new Dat15RelData(this);//shouldn't get here
                    }
                case RelDatFileType.Dat16Curves:
                    switch ((Dat16RelType)dataType)
                    {
                        case Dat16RelType.ConstantCurve: return new Dat16ConstantCurve(this);
                        case Dat16RelType.LinearCurve: return new Dat16LinearCurve(this);
                        case Dat16RelType.LinearDbCurve: return new Dat16LinearDbCurve(this);
                        case Dat16RelType.PiecewiseLinearCurve: return new Dat16PiecewiseLinearCurve(this);
                        case Dat16RelType.EqualPowerCurve: return new Dat16EqualPowerCurve(this);
                        case Dat16RelType.ValueTableCurve: return new Dat16ValueTableCurve(this);
                        case Dat16RelType.ExponentialCurve: return new Dat16ExponentialCurve(this);
                        case Dat16RelType.DecayingExponentialCurve: return new Dat16DecayingExponentialCurve(this);
                        case Dat16RelType.DecayingSquaredExponentialCurve: return new Dat16DecayingSquaredExponentialCurve(this);
                        case Dat16RelType.SineCurve: return new Dat16SineCurve(this);
                        case Dat16RelType.OneOverXSquaredCurve: return new Dat16OneOverXSquaredCurve(this);
                        case Dat16RelType.DefaultDistanceAttenuationCurve: return new Dat16DefaultDistanceAttenuationCurve(this);
                        case Dat16RelType.DistanceAttenuationValueTableCurve: return new Dat16DistanceAttenuationValueTableCurve(this);
                        default:
                            return new Dat16RelData(this);//shouldn't get here
                    }
                case RelDatFileType.Dat22Categories:
                    switch ((Dat22RelType)dataType)
                    {
                        case Dat22RelType.Category: return new Dat22Category(this);
                        default:
                            return new Dat22RelData(this);//shouldn't get here
                    }
                default:
                    d = new RelData(this);
                    d.TypeID = (byte)dataType;
                    return d;
            }
        }



        private void BuildNameTable()
        {
            //TODO!
            //need to do this before building the data block since nametable offsets are in there!






            if (NameTable != null)
            {
                NameTableCount = (uint)NameTable.Length;
                uint ntlength = 4 + (4 * NameTableCount);
                foreach (var name in NameTable)
                {
                    ntlength += (uint)name.Length + 1;
                }
                if ((NameTableLength != ntlength) && (NameTableLength != 0))
                { }
                NameTableLength = ntlength;
            }
            else
            {
                if ((NameTableLength != 4) && (NameTableLength != 0))
                { }
                NameTableCount = 0;
                NameTableLength = 4;
            }


        }
        private void BuildDataBlock()
        {
            if (RelDatas == null) return;
            if (RelDatasSorted == null) return;



            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter(ms);

            bw.Write(DataUnkVal);


            RelData lastrd = null;//debug

            for (int i = 0; i < RelDatasSorted.Length; i++)
            {

                var rd = RelDatasSorted[i];

                switch (RelType)
                {
                    case RelDatFileType.Dat10ModularSynth:
                        while ((ms.Position & 3) != 0) bw.Write((byte)0); //align these to nearest 4 bytes
                        break;
                    case RelDatFileType.Dat15DynamicMixer:
                        switch (rd.TypeID)
                        {
                            case 0:
                            case 6:
                            case 5:
                            case 7:
                            case 8:
                                while ((ms.Position & 3) != 0) bw.Write((byte)0); //align these to nearest 4 bytes
                                break;
                            default:
                                break;
                        }
                        break;
                    case RelDatFileType.Dat149:
                    case RelDatFileType.Dat150:
                    case RelDatFileType.Dat151:
                        switch ((Dat151RelType)rd.TypeID)//must be a better way of doing this!
                        {
                            case Dat151RelType.AmbientRule:
                            case Dat151RelType.AmbientZone:
                            case Dat151RelType.AlarmSettings:
                            case Dat151RelType.ScannerSpecificLocation:
                                while ((ms.Position & 0xF) != 0) bw.Write((byte)0); //align to nearest 16 bytes
                                break;
                            case Dat151RelType.InteractiveMusicMood:
                            case Dat151RelType.BarConstraint:
                            case Dat151RelType.PedRaceToPedVoiceGroup:
                            case Dat151RelType.SpeechParams:
                            case Dat151RelType.TriggeredSpeechContext:
                            case Dat151RelType.AmbientBankMap:
                            case Dat151RelType.TrailerAudioSettings:
                            case Dat151RelType.StaticEmitterList:
                            case Dat151RelType.WeaponSettings:
                            case Dat151RelType.CarAudioSettings:
                            case Dat151RelType.StopTrackAction:
                                while ((ms.Position & 3) != 0) bw.Write((byte)0); //align these to nearest 4 bytes
                                break;
                        }
                        break;
                    case RelDatFileType.Dat4:
                        if (IsAudioConfig)
                        {
                            switch ((Dat4ConfigType)rd.TypeID)
                            {
                                case Dat4ConfigType.Vector3:
                                    while ((ms.Position & 0xF) != 0) bw.Write((byte)0); //align to nearest 16 bytes
                                    break;
                            }
                        }
                        break;
                }


                var pos = ms.Position;
                if ((ms.Position != rd.DataOffset) && (rd.DataOffset != 0))
                { }
                rd.DataOffset = (uint)ms.Position;
                rd.Write(bw);
                var lengthwritten = ms.Position - pos;
                if ((lengthwritten != rd.DataLength) && (rd.DataLength != 0))
                { }
                rd.DataLength = (uint)lengthwritten;

                lastrd = rd;
            }

            var buf = new byte[ms.Length];
            ms.Position = 0;
            ms.Read(buf, 0, buf.Length);

            if ((DataBlock != null) && (DataBlock.Length != buf.Length))
            { }

            DataBlock = buf;

            DataLength = (uint)(DataBlock?.Length ?? 0);
        }
        private void BuildIndex()
        {
            if (RelDatas == null) return;
            if (RelDatasSorted == null) return;



            //for the correct index ordering, needs to be in order of hashes, but with bits rotated right by 8 (why!?)
            var sorted = RelDatasSorted.ToList();
            switch (RelType)
            {
                case RelDatFileType.Dat15DynamicMixer:
                case RelDatFileType.Dat149:
                case RelDatFileType.Dat150:
                case RelDatFileType.Dat151:
                case RelDatFileType.Dat10ModularSynth:
                case RelDatFileType.Dat22Categories:
                case RelDatFileType.Dat16Curves:
                case RelDatFileType.Dat54DataEntries:
                    sorted.Sort((a, b) =>
                    {
                        var ah = (uint)a.NameHash;
                        var bh = (uint)b.NameHash;
                        var av = (ah >> 8) | (ah << 24);
                        var bv = (bh >> 8) | (bh << 24);
                        return av.CompareTo(bv);
                    });
                    break;
                default:
                    if (!IsAudioConfig)//don't sort audioconfig (only sort speech dat4's)
                    {
                        sorted.Sort((a, b) => { return ((uint)a.NameHash).CompareTo((uint)b.NameHash); });
                    }
                    break;
            }
            RelDatas = sorted.ToArray();


            if (IsAudioConfig)
            {
                var strs = new RelIndexString[RelDatas.Length];
                for (int i = 0; i < RelDatas.Length; i++)
                {
                    var rd = RelDatas[i];
                    strs[i] = new RelIndexString() { Name = rd.Name, Offset = rd.DataOffset, Length = rd.DataLength };
                }
                IndexStrings = strs;
                IndexCount = (uint)(IndexStrings?.Length ?? 0);
            }
            else
            {

                var hashes = new RelIndexHash[RelDatas.Length];
                for (int i = 0; i < RelDatas.Length; i++)
                {
                    var rd = RelDatas[i];
                    hashes[i] = new RelIndexHash() { Name = rd.NameHash, Offset = rd.DataOffset, Length = rd.DataLength };
                }
                //if (hashes.Length != IndexHashes.Length)
                //{ }

                IndexHashes = hashes;
                IndexCount = (uint)(IndexHashes?.Length ?? 0);
            }
        }
        private void BuildHashTable()
        {
            if (RelDatasSorted == null) return;

            var htoffsets = new List<uint>();
            foreach (var rd in RelDatasSorted)
            {
                var offsets = rd.GetHashTableOffsets();
                if (offsets == null) continue;
                var rdoffset = rd.DataOffset + 8;
                var rs = rd as RelSound;
                var ss = rd as Dat4SpeechData;
                if (rs?.Header != null)
                {
                    rdoffset += 1 + rs.Header.CalcHeaderLength();
                }
                else if (ss == null)//don't add 4 for speech!
                {
                    rdoffset += 4; //typeid + nt offset
                }
                for (int i = 0; i < offsets.Length; i++)
                {
                    htoffsets.Add(rdoffset + offsets[i]);

                    int idx = htoffsets.Count - 1;
                    if ((HashTableOffsets != null) && (idx < HashTableOffsets.Length))
                    {
                        if (htoffsets[idx] != HashTableOffsets[idx])
                        { }
                    }
                }
            }
            if (htoffsets.Count > 0)
            {
                if (HashTableOffsets != null)
                {
                    if (HashTableOffsets.Length != htoffsets.Count)
                    { }
                    else
                    {
                        for (int i = 0; i < htoffsets.Count; i++)
                        {
                            if (htoffsets[i] != HashTableOffsets[i])
                            { }
                        }
                    }
                }
                HashTableOffsets = htoffsets.ToArray();
            }
            else
            {
                HashTableOffsets = null;
            }

            HashTableCount = (uint)(HashTableOffsets?.Length ?? 0);
        }
        private void BuildPackTable()
        {

            var ptoffsets = new List<uint>();
            foreach (var rd in RelDatasSorted)
            {
                var offsets = rd.GetPackTableOffsets();
                if (offsets == null) continue;
                var rdoffset = rd.DataOffset + 8;
                var rs = rd as RelSound;
                var ss = rd as Dat4SpeechData;
                if (rs?.Header != null)
                {
                    rdoffset += 1 + rs.Header.CalcHeaderLength();
                }
                else if (ss == null)//don't add 4 for speech!
                {
                    rdoffset += 4; //typeid + nt offset
                }
                for (int i = 0; i < offsets.Length; i++)
                {
                    ptoffsets.Add(rdoffset + offsets[i]);
                }
            }
            if (ptoffsets.Count > 0)
            {
                if (PackTableOffsets != null)
                {
                    if (PackTableOffsets.Length != ptoffsets.Count)
                    { }
                    else
                    {
                        for (int i = 0; i < ptoffsets.Count; i++)
                        {
                            if (ptoffsets[i] != PackTableOffsets[i])
                            { }
                        }
                    }
                }
                PackTableOffsets = ptoffsets.ToArray();
            }
            else
            {
                PackTableOffsets = null;
            }

            PackTableCount = (uint)(PackTableOffsets?.Length ?? 0);
        }



        private void BuildHashMaps()
        {
            //for discovering "HashTable" offsets

            var relType = RelType;
            switch (RelType)
            {
                case RelDatFileType.Dat149:
                case RelDatFileType.Dat150://treat these same as 151
                case RelDatFileType.Dat151:
                    relType = RelDatFileType.Dat151;
                    break;
                default:
                    break;
            }

            if (relType != RelDatFileType.Dat4)
            { return; }


            if (HashTableOffsets != null)
            {
                foreach (var htoffset in HashTableOffsets)
                {
                    var dboffset = htoffset - 8;
                    for (int i = 0; i < RelDatasSorted.Length; i++)
                    {
                        var rd = RelDatasSorted[i];

                        if ((dboffset >= rd.DataOffset) && (dboffset < rd.DataOffset + rd.DataLength))
                        {
                            var rdoffset = rd.DataOffset;
                            var rs = rd as RelSound;
                            if (rs != null)
                            {
                                rdoffset += 1 + rs.Header.HeaderLength;
                            }
                            var key = new HashesMapKey()
                            {
                                FileType = relType,
                                ItemType = rd.TypeID,
                                IsContainer = false
                            };
                            var val = new HashesMapValue()
                            {
                                Item = rd,
                                Hash = BitConverter.ToUInt32(DataBlock, (int)dboffset),
                                Offset = dboffset - rdoffset,
                                Count = 1
                            };
                            AddHashesMapItem(ref key, val);
                            break;
                        }
                    }
                }
            }
            if (PackTableOffsets != null)
            {
                foreach (var wcoffset in PackTableOffsets)
                {
                    var dboffset = wcoffset - 8;
                    for (int i = 0; i < RelDatasSorted.Length; i++)
                    {
                        var rd = RelDatasSorted[i];
                        if ((dboffset >= rd.DataOffset) && (dboffset < rd.DataOffset + rd.DataLength))
                        {
                            var rdoffset = rd.DataOffset;
                            var rs = rd as RelSound;
                            if (rs != null)
                            {
                                rdoffset += 1 + rs.Header.HeaderLength;
                            }
                            var key = new HashesMapKey()
                            {
                                FileType = relType,
                                ItemType = rd.TypeID,
                                IsContainer = true
                            };
                            var val = new HashesMapValue()
                            {
                                Item = rd,
                                Hash = BitConverter.ToUInt32(DataBlock, (int)dboffset),
                                Offset = dboffset - rdoffset,
                                Count = 1
                            };
                            AddHashesMapItem(ref key, val);
                            break;
                        }
                    }
                }
            }


        }
        public struct HashesMapKey
        {
            public RelDatFileType FileType { get; set; }
            public uint ItemType { get; set; }
            public bool IsContainer { get; set; }

            public override string ToString()
            {
                var cstr = IsContainer ? "Container: " : "";
                var fcstr = cstr + FileType.ToString() + ": ";
                switch (FileType)
                {
                    case RelDatFileType.Dat54DataEntries:
                        return fcstr + ((Dat54SoundType)ItemType).ToString();
                    case RelDatFileType.Dat149:
                    case RelDatFileType.Dat150:
                    case RelDatFileType.Dat151:
                        return fcstr + ((Dat151RelType)ItemType).ToString();
                }

                return fcstr + ItemType.ToString();
            }
        }
        public class HashesMapValue
        {
            public RelData Item { get; set; }
            public MetaHash Hash { get; set; }
            public uint Offset { get; set; }
            public uint Count { get; set; }

            public override string ToString()
            {
                return Offset.ToString() + ": " + Count.ToString();
            }
        }
        public static Dictionary<HashesMapKey, List<HashesMapValue>> HashesMap { get; set; } = new Dictionary<HashesMapKey, List<HashesMapValue>>();
        private static void AddHashesMapItem(ref HashesMapKey key, HashesMapValue val)
        {
            List<HashesMapValue> values = null;
            if (!HashesMap.TryGetValue(key, out values))
            {
                values = new List<HashesMapValue>();
                HashesMap[key] = values;
            }
            if (values != null)
            {
                foreach (var xval in values)
                {
                    if (xval.Offset == val.Offset)
                    {
                        xval.Count++;
                        return;//same key, same offset, it's a match...
                    }
                }
                values.Add(val);
            }
            else
            { }
        }




        public byte[] Save()
        {

            BuildNameTable();
            BuildDataBlock();
            BuildIndex();
            BuildHashTable();
            BuildPackTable();


            if (DataBlock == null) return null;



            //write the file data.

            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter(ms);


            bw.Write((uint)RelType);
            bw.Write(DataLength);
            bw.Write(DataBlock);

            bw.Write(NameTableLength);
            bw.Write(NameTableCount);
            if (NameTableCount > 0)
            {
                uint offset = 0;
                foreach (var name in NameTable)
                {
                    bw.Write(offset);
                    offset += (uint)name.Length + 1;
                }
                foreach (var name in NameTable)
                {
                    foreach (var c in name)
                    {
                        bw.Write(c);
                    }
                    bw.Write((byte)0);
                }

            }

            bw.Write(IndexCount);
            if (IndexCount > 0)
            {
                if (IsAudioConfig)//audioconfig.dat4.rel
                {
                    bw.Write(IndexStringFlags); //should be 2524..? could be a length?
                    for (uint i = 0; i < IndexCount; i++)
                    {
                        var ristr = IndexStrings[i];
                        var name = ristr.Name;
                        bw.Write((byte)name.Length);
                        for (int j = 0; j < name.Length; j++)
                        {
                            bw.Write((byte)name[j]);
                        }
                        bw.Write(ristr.Offset);
                        bw.Write(ristr.Length);
                    }
                }
                else //for all other .rel files...
                {
                    for (uint i = 0; i < IndexCount; i++)
                    {
                        var rihash = IndexHashes[i];
                        bw.Write(rihash.Name);
                        bw.Write(rihash.Offset);
                        bw.Write(rihash.Length);
                    }
                }
            }

            bw.Write(HashTableCount);
            if (HashTableCount != 0)
            {
                for (uint i = 0; i < HashTableCount; i++)
                {
                    bw.Write(HashTableOffsets[i]);
                }
            }

            bw.Write(PackTableCount);
            if (PackTableCount != 0)
            {
                for (uint i = 0; i < PackTableCount; i++)
                {
                    bw.Write(PackTableOffsets[i]);
                }
            }


            var buf = new byte[ms.Length];
            ms.Position = 0;
            ms.Read(buf, 0, buf.Length);
            return buf;

        }







        public void AddRelData(RelData d)
        {
            var newRelDatas = new List<RelData>();
            var newRelDatasSorted = new List<RelData>();

            if (RelDatas != null) newRelDatas.AddRange(RelDatas);
            if (RelDatasSorted != null) newRelDatasSorted.AddRange(RelDatasSorted);

            newRelDatas.Add(d);
            newRelDatasSorted.Add(d);

            RelDatas = newRelDatas.ToArray();
            RelDatasSorted = newRelDatasSorted.ToArray();
            //RelDataDict[d.NameHash] = d;
        }
        public bool RemoveRelData(RelData d)
        {
            var newRelDatas = new List<RelData>();
            var newRelDatasSorted = new List<RelData>();

            if (RelDatas != null)
            {
                foreach (var relData in RelDatas)
                {
                    if (relData != d)
                    {
                        newRelDatas.Add(relData);
                    }
                }
            }
            if (RelDatasSorted != null)
            {
                foreach (var relData in RelDatasSorted)
                {
                    if (relData != d)
                    {
                        newRelDatasSorted.Add(relData);
                    }
                }
            }

            if (newRelDatas.Count < RelDatas.Length)
            {
                RelDatas = newRelDatas.ToArray();
                RelDatasSorted = newRelDatasSorted.ToArray();
                RelDataDict.Remove(d.NameHash);
                return true;
            }

            return false;
        }



        public override string ToString()
        {
            return Name;
        }
    }

    [TC(typeof(EXP))]
    public struct RelIndexHash
    {
        public MetaHash Name { get; set; }
        public uint Offset { get; set; }
        public uint Length { get; set; }

        public override string ToString()
        {
            return Name.ToString() + ", " + Offset.ToString() + ", " + Length.ToString();
        }
    }


    [TC(typeof(EXP))]
    public struct RelIndexString
    {
        public string Name { get; set; }
        public uint Offset { get; set; }
        public uint Length { get; set; }

        public override string ToString()
        {
            return Name + ", " + Offset.ToString() + ", " + Length.ToString();
        }
    }


    [TC(typeof(EXP))]
    public class RelData
    {
        public MetaHash NameHash { get; set; }
        public string Name { get; set; }
        public uint DataOffset { get; set; }
        public uint DataLength { get; set; }
        public byte[] Data { get; set; }
        public byte TypeID { get; set; }

        public RelFile Rel { get; set; }

        public RelData(RelFile rel) { Rel = rel; }
        public RelData(RelData d)
        {
            NameHash = d.NameHash;
            Name = d.Name;
            DataOffset = d.DataOffset;
            DataLength = d.DataLength;
            Data = d.Data;
            TypeID = d.TypeID;
            Rel = d.Rel;
        }

        public void ReadType(BinaryReader br)
        {
            TypeID = br.ReadByte();
        }

        public virtual uint[] GetHashTableOffsets()
        {
            return null;
        }
        public virtual uint[] GetPackTableOffsets()
        {
            return null;
        }

        public virtual MetaHash[] GetSpeechHashes()
        {
            return null;
        }
        public virtual MetaHash[] GetSynthHashes()
        {
            return null;
        }
        public virtual MetaHash[] GetMixerHashes()
        {
            return null;
        }
        public virtual MetaHash[] GetCurveHashes()
        {
            return null;
        }
        public virtual MetaHash[] GetCategoryHashes()
        {
            return null;
        }
        public virtual MetaHash[] GetSoundHashes()
        {
            return null;
        }
        public virtual MetaHash[] GetGameHashes()
        {
            return null;
        }


        public virtual void Write(BinaryWriter bw)
        {
            bw.Write(Data); //fallback for default byte array data writing...
        }

        public virtual void WriteXml(StringBuilder sb, int indent)
        {
            //default fallback to write raw data to XML...

            RelXml.WriteRawArray(sb, Data, indent, "RawData", "", RelXml.FormatHexByte, 16);

        }

        public virtual void ReadXml(XmlNode node)
        {
            var rawnode = node.SelectSingleNode("RawData");
            if (rawnode != null)
            {
                Data = Xml.GetRawByteArray(rawnode);
                DataLength = (uint)Data.Length;
            }
        }


        public string GetNameString()
        {
            return (string.IsNullOrEmpty(Name)) ? NameHash.ToString() : Name;
        }
        public string GetBaseString()
        {
            return DataOffset.ToString() + ", " + DataLength.ToString() + ": " + GetNameString();
        }
        public override string ToString()
        {
            return GetBaseString() + ": " + TypeID.ToString();
        }

        public static bool Bit(uint f, int b)
        {
            return ((f & (1u << b)) != 0); //just for handyness... maybe move this?
        }
        public static bool BadF(float f)
        {
            return ((f < -15000) || (f > 15000));
        }
    }




    #region dat54



    [TC(typeof(EXP))]
    public class RelSoundHeader
    {
        public FlagsUint Flags { get; set; }

        public FlagsUint Flags2 { get; set; }
        public ushort MaxHeaderSize { get; set; }
        public short Volume { get; set; }
        public ushort VolumeVariance { get; set; } //0xD-0xF
        public short Pitch { get; set; } //0xF-0x11
        public ushort PitchVariance { get; set; } //0x11-0x13
        public ushort Pan { get; set; } //0x13-0x15
        public ushort PanVariance { get; set; } //0x15-0x17
        public short PreDelay { get; set; } //0x17-0x19
        public ushort PreDelayVariance { get; set; } //0x19-0x1B
        public int StartOffset { get; set; } //0x1B-0x1F
        public int StartOffsetVariance { get; set; } //0x1F-0x23
        public ushort AttackTime { get; set; } //0x23-0x25
        public ushort ReleaseTime { get; set; } //0x25-0x27
        public ushort DopplerFactor { get; set; } //0x27-0x29
        public MetaHash Category { get; set; } //0x29-0x2D
        public ushort LPFCutoff { get; set; } //0x2D-0x2F
        public ushort LPFCutoffVariance { get; set; } //0x2F-0x31
        public ushort HPFCutoff { get; set; } //0x31-0x33
        public ushort HPFCutoffVariance { get; set; } //0x33-0x35
        public MetaHash VolumeCurve { get; set; } //0x35-0x39
        public short VolumeCurveScale { get; set; } //0x39-0x3B
        public byte VolumeCurvePlateau { get; set; } //0x3B-0x3C
        public byte SpeakerMask { get; set; } //0x3C-0x3D
        public byte EffectRoute { get; set; } //0x3D-0x3E
        public MetaHash PreDelayVariable { get; set; } //0x3E-0x42
        public MetaHash StartOffsetVariable { get; set; } //0x42-0x46
        public ushort SmallReverbSend { get; set; } //0x46-0x48
        public ushort MediumReverbSend { get; set; } //0x48-0x4A
        public ushort LargeReverbSend { get; set; } //0x4A-0x4C
        public ushort Unk25 { get; set; } //0x4A-0x4C
        public ushort Unk26 { get; set; } //0x4A-0x4C

        public uint HeaderLength { get; set; } = 0;


        public RelSoundHeader(XmlNode node)
        {
            ReadXml(node);
            HeaderLength = CalcHeaderLength();
        }
        public RelSoundHeader(BinaryReader br)
        {
            var pos = br.BaseStream.Position;

            Flags = br.ReadUInt32();

            //if (Flags.Value != 0xAAAAAAAA)
            if ((Flags & 0xFF) != 0xAA)
            {
                if (Bit(0)) Flags2 = br.ReadUInt32();
                if (Bit(1)) MaxHeaderSize = br.ReadUInt16();
                if (Bit(2)) Volume = br.ReadInt16();
                if (Bit(3)) VolumeVariance = br.ReadUInt16();
                if (Bit(4)) Pitch = br.ReadInt16();
                if (Bit(5)) PitchVariance = br.ReadUInt16();
                if (Bit(6)) Pan = br.ReadUInt16();
                if (Bit(7)) PanVariance = br.ReadUInt16();
            }
            if ((Flags & 0xFF00) != 0xAA00)
            {
                if (Bit(8)) PreDelay = br.ReadInt16();
                if (Bit(9)) PreDelayVariance = br.ReadUInt16();
                if (Bit(10)) StartOffset = br.ReadInt32();
                if (Bit(11)) StartOffsetVariance = br.ReadInt32();
                if (Bit(12)) AttackTime = br.ReadUInt16();
                if (Bit(13)) ReleaseTime = br.ReadUInt16();
                if (Bit(14)) DopplerFactor = br.ReadUInt16();
                if (Bit(15)) Category = br.ReadUInt32();
            }
            if ((Flags & 0xFF0000) != 0xAA0000)
            {
                if (Bit(16)) LPFCutoff = br.ReadUInt16();
                if (Bit(17)) LPFCutoffVariance = br.ReadUInt16();
                if (Bit(18)) HPFCutoff = br.ReadUInt16();
                if (Bit(19)) HPFCutoffVariance = br.ReadUInt16();
                if (Bit(20)) VolumeCurve = br.ReadUInt32();
                if (Bit(21)) VolumeCurveScale = br.ReadInt16();
                if (Bit(22)) VolumeCurvePlateau = br.ReadByte();
                if (Bit(23)) SpeakerMask = br.ReadByte();
            }
            if ((Flags & 0xFF000000) != 0xAA000000)
            {
                if (Bit(24)) EffectRoute = br.ReadByte();
                if (Bit(25)) PreDelayVariable = br.ReadUInt32();
                if (Bit(26)) StartOffsetVariable = br.ReadUInt32();
                if (Bit(27)) SmallReverbSend = br.ReadUInt16();
                if (Bit(28)) MediumReverbSend = br.ReadUInt16();
                if (Bit(29)) LargeReverbSend = br.ReadUInt16();
                if (Bit(30)) Unk25 = br.ReadUInt16(); //maybe not
                if (Bit(31)) Unk26 = br.ReadUInt16(); //maybe not
            }

            HeaderLength = (uint)(br.BaseStream.Position - pos);

        }

        public void Write(BinaryWriter bw)
        {
            bw.Write(Flags);

            //if (Flags.Value != 0xAAAAAAAA)
            if ((Flags & 0xFF) != 0xAA)
            {
                if (Bit(0)) bw.Write(Flags2);
                if (Bit(1)) bw.Write(MaxHeaderSize);
                if (Bit(2)) bw.Write(Volume);
                if (Bit(3)) bw.Write(VolumeVariance);
                if (Bit(4)) bw.Write(Pitch);
                if (Bit(5)) bw.Write(PitchVariance);
                if (Bit(6)) bw.Write(Pan);
                if (Bit(7)) bw.Write(PanVariance);
            }
            if ((Flags & 0xFF00) != 0xAA00)
            {
                if (Bit(8)) bw.Write(PreDelay);
                if (Bit(9)) bw.Write(PreDelayVariance);
                if (Bit(10)) bw.Write(StartOffset);
                if (Bit(11)) bw.Write(StartOffsetVariance);
                if (Bit(12)) bw.Write(AttackTime);
                if (Bit(13)) bw.Write(ReleaseTime);
                if (Bit(14)) bw.Write(DopplerFactor);
                if (Bit(15)) bw.Write(Category);
            }
            if ((Flags & 0xFF0000) != 0xAA0000)
            {
                if (Bit(16)) bw.Write(LPFCutoff);
                if (Bit(17)) bw.Write(LPFCutoffVariance);
                if (Bit(18)) bw.Write(HPFCutoff);
                if (Bit(19)) bw.Write(HPFCutoffVariance);
                if (Bit(20)) bw.Write(VolumeCurve);
                if (Bit(21)) bw.Write(VolumeCurveScale);
                if (Bit(22)) bw.Write(VolumeCurvePlateau);
                if (Bit(23)) bw.Write(SpeakerMask);
            }
            if ((Flags & 0xFF000000) != 0xAA000000)
            {
                if (Bit(24)) bw.Write(EffectRoute);
                if (Bit(25)) bw.Write(PreDelayVariable);
                if (Bit(26)) bw.Write(StartOffsetVariable);
                if (Bit(27)) bw.Write(SmallReverbSend);
                if (Bit(28)) bw.Write(MediumReverbSend);
                if (Bit(29)) bw.Write(LargeReverbSend);
                if (Bit(30)) bw.Write(Unk25); //maybe not
                if (Bit(31)) bw.Write(Unk26); //maybe not
            }

        }

        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);

            if ((Flags & 0xFF) != 0xAA)
            {
                if (Bit(0)) RelXml.ValueTag(sb, indent, "Flags2", "0x" + Flags2.Hex);
                if (Bit(1)) RelXml.ValueTag(sb, indent, "MaxHeaderSize", MaxHeaderSize.ToString());
                if (Bit(2)) RelXml.ValueTag(sb, indent, "Volume", Volume.ToString());
                if (Bit(3)) RelXml.ValueTag(sb, indent, "VolumeVariance", VolumeVariance.ToString());
                if (Bit(4)) RelXml.ValueTag(sb, indent, "Pitch", Pitch.ToString());
                if (Bit(5)) RelXml.ValueTag(sb, indent, "PitchVariance", PitchVariance.ToString());
                if (Bit(6)) RelXml.ValueTag(sb, indent, "Pan", Pan.ToString());
                if (Bit(7)) RelXml.ValueTag(sb, indent, "PanVariance", PanVariance.ToString());
            }
            if ((Flags & 0xFF00) != 0xAA00)
            {
                if (Bit(8)) RelXml.ValueTag(sb, indent, "PreDelay", PreDelay.ToString());
                if (Bit(9)) RelXml.ValueTag(sb, indent, "PreDelayVariance", PreDelayVariance.ToString());
                if (Bit(10)) RelXml.ValueTag(sb, indent, "StartOffset", StartOffset.ToString());
                if (Bit(11)) RelXml.ValueTag(sb, indent, "StartOffsetVariance", StartOffsetVariance.ToString());
                if (Bit(12)) RelXml.ValueTag(sb, indent, "AttackTime", AttackTime.ToString());
                if (Bit(13)) RelXml.ValueTag(sb, indent, "ReleaseTime", ReleaseTime.ToString());
                if (Bit(14)) RelXml.ValueTag(sb, indent, "DopplerFactor", DopplerFactor.ToString());
                if (Bit(15)) RelXml.StringTag(sb, indent, "Category", RelXml.HashString(Category));
            }
            if ((Flags & 0xFF0000) != 0xAA0000)
            {
                if (Bit(16)) RelXml.ValueTag(sb, indent, "LPFCutoff", LPFCutoff.ToString());
                if (Bit(17)) RelXml.ValueTag(sb, indent, "LPFCutoffVariance", LPFCutoffVariance.ToString());
                if (Bit(18)) RelXml.ValueTag(sb, indent, "HPFCutoff", HPFCutoff.ToString());
                if (Bit(19)) RelXml.ValueTag(sb, indent, "HPFCutoffVariance", HPFCutoffVariance.ToString());
                if (Bit(20)) RelXml.StringTag(sb, indent, "VolumeCurve", RelXml.HashString(VolumeCurve));
                if (Bit(21)) RelXml.ValueTag(sb, indent, "VolumeCurveScale", VolumeCurveScale.ToString());
                if (Bit(22)) RelXml.ValueTag(sb, indent, "VolumeCurvePlateau", VolumeCurvePlateau.ToString());
                if (Bit(23)) RelXml.ValueTag(sb, indent, "SpeakerMask", SpeakerMask.ToString());
            }
            if ((Flags & 0xFF000000) != 0xAA000000)
            {
                if (Bit(24)) RelXml.ValueTag(sb, indent, "EffectRoute", EffectRoute.ToString());
                if (Bit(25)) RelXml.StringTag(sb, indent, "PreDelayVariable", RelXml.HashString(PreDelayVariable));
                if (Bit(26)) RelXml.StringTag(sb, indent, "StartOffsetVariable", RelXml.HashString(StartOffsetVariable));
                if (Bit(27)) RelXml.ValueTag(sb, indent, "SmallReverbSend", SmallReverbSend.ToString());
                if (Bit(28)) RelXml.ValueTag(sb, indent, "MediumReverbSend", MediumReverbSend.ToString());
                if (Bit(29)) RelXml.ValueTag(sb, indent, "LargeReverbSend", LargeReverbSend.ToString());
                if (Bit(30)) RelXml.ValueTag(sb, indent, "Unk25", Unk25.ToString()); //maybe not
                if (Bit(31)) RelXml.ValueTag(sb, indent, "Unk26", Unk26.ToString()); //maybe not
            }

        }
        public void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");

            if ((Flags & 0xFF) != 0xAA)
            {
                if (Bit(0)) Flags2 = Xml.GetChildUIntAttribute(node, "Flags2", "value");
                if (Bit(1)) MaxHeaderSize = (ushort)Xml.GetChildUIntAttribute(node, "MaxHeaderSize", "value");
                if (Bit(2)) Volume = (short)Xml.GetChildIntAttribute(node, "Volume", "value");
                if (Bit(3)) VolumeVariance = (ushort)Xml.GetChildUIntAttribute(node, "VolumeVariance", "value");
                if (Bit(4)) Pitch = (short)Xml.GetChildIntAttribute(node, "Pitch", "value");
                if (Bit(5)) PitchVariance = (ushort)Xml.GetChildUIntAttribute(node, "PitchVariance", "value");
                if (Bit(6)) Pan = (ushort)Xml.GetChildUIntAttribute(node, "Pan", "value");
                if (Bit(7)) PanVariance = (ushort)Xml.GetChildUIntAttribute(node, "PanVariance", "value");
            }
            if ((Flags & 0xFF00) != 0xAA00)
            {
                if (Bit(8)) PreDelay = (short)Xml.GetChildIntAttribute(node, "PreDelay", "value");
                if (Bit(9)) PreDelayVariance = (ushort)Xml.GetChildUIntAttribute(node, "PreDelayVariance", "value");
                if (Bit(10)) StartOffset = Xml.GetChildIntAttribute(node, "StartOffset", "value");
                if (Bit(11)) StartOffsetVariance = Xml.GetChildIntAttribute(node, "StartOffsetVariance", "value");
                if (Bit(12)) AttackTime = (ushort)Xml.GetChildUIntAttribute(node, "AttackTime", "value");
                if (Bit(13)) ReleaseTime = (ushort)Xml.GetChildUIntAttribute(node, "ReleaseTime", "value");
                if (Bit(14)) DopplerFactor = (ushort)Xml.GetChildUIntAttribute(node, "DopplerFactor", "value");
                if (Bit(15)) Category = XmlRel.GetHash(Xml.GetChildInnerText(node, "Category"));
            }
            if ((Flags & 0xFF0000) != 0xAA0000)
            {
                if (Bit(16)) LPFCutoff = (ushort)Xml.GetChildUIntAttribute(node, "LPFCutoff", "value");
                if (Bit(17)) LPFCutoffVariance = (ushort)Xml.GetChildUIntAttribute(node, "LPFCutoffVariance", "value");
                if (Bit(18)) HPFCutoff = (ushort)Xml.GetChildUIntAttribute(node, "HPFCutoff", "value");
                if (Bit(19)) HPFCutoffVariance = (ushort)Xml.GetChildUIntAttribute(node, "HPFCutoffVariance", "value");
                if (Bit(20)) VolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "VolumeCurve"));
                if (Bit(21)) VolumeCurveScale = (short)Xml.GetChildIntAttribute(node, "VolumeCurveScale", "value");
                if (Bit(22)) VolumeCurvePlateau = (byte)Xml.GetChildUIntAttribute(node, "VolumeCurvePlateau", "value");
                if (Bit(23)) SpeakerMask = (byte)Xml.GetChildUIntAttribute(node, "SpeakerMask", "value");
            }
            if ((Flags & 0xFF000000) != 0xAA000000)
            {
                if (Bit(24)) EffectRoute = (byte)Xml.GetChildUIntAttribute(node, "EffectRoute", "value");
                if (Bit(25)) PreDelayVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "PreDelayVariable"));
                if (Bit(26)) StartOffsetVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "StartOffsetVariable"));
                if (Bit(27)) SmallReverbSend = (ushort)Xml.GetChildUIntAttribute(node, "SmallReverbSend", "value");
                if (Bit(28)) MediumReverbSend = (ushort)Xml.GetChildUIntAttribute(node, "MediumReverbSend", "value");
                if (Bit(29)) LargeReverbSend = (ushort)Xml.GetChildUIntAttribute(node, "LargeReverbSend", "value");
                if (Bit(30)) Unk25 = (ushort)Xml.GetChildUIntAttribute(node, "Unk25", "value");
                if (Bit(31)) Unk26 = (ushort)Xml.GetChildUIntAttribute(node, "Unk26", "value");
            }

        }


        public uint CalcHeaderLength()
        {
            uint length = 4;
            if ((Flags & 0xFF) != 0xAA)
            {
                if (Bit(0)) length += 4;// Flags2 = br.ReadUInt32();
                if (Bit(1)) length += 2;// MaxHeaderSize = br.ReadUInt16();
                if (Bit(2)) length += 2;// Volume = br.ReadUInt16();
                if (Bit(3)) length += 2;// VolumeVariance = br.ReadUInt16();
                if (Bit(4)) length += 2;// Pitch = br.ReadUInt16();
                if (Bit(5)) length += 2;// PitchVariance = br.ReadUInt16();
                if (Bit(6)) length += 2;// Pan = br.ReadUInt16();
                if (Bit(7)) length += 2;// PanVariance = br.ReadUInt16();
            }
            if ((Flags & 0xFF00) != 0xAA00)
            {
                if (Bit(8)) length += 2;// PreDelay = br.ReadUInt16();
                if (Bit(9)) length += 2;// PreDelayVariance = br.ReadUInt16();
                if (Bit(10)) length += 4;// StartOffset = br.ReadUInt32();
                if (Bit(11)) length += 4;// StartOffsetVariance = br.ReadUInt32();
                if (Bit(12)) length += 2;// AttackTime = br.ReadUInt16();
                if (Bit(13)) length += 2;// ReleaseTime = br.ReadUInt16();
                if (Bit(14)) length += 2;// DopplerFactor = br.ReadUInt16();
                if (Bit(15)) length += 4;// CategoryHash = br.ReadUInt32();
            }
            if ((Flags & 0xFF0000) != 0xAA0000)
            {
                if (Bit(16)) length += 2;// LPFCutoff = br.ReadUInt16();
                if (Bit(17)) length += 2;// LPFCutoffVariance = br.ReadUInt16();
                if (Bit(18)) length += 2;// HPFCutoff = br.ReadUInt16();
                if (Bit(19)) length += 2;// HPFCutoffVariance = br.ReadUInt16();
                if (Bit(20)) length += 4;// VolumeCurve = br.ReadUInt32();
                if (Bit(21)) length += 2;// VolumeCurveScale = br.ReadUInt16();
                if (Bit(22)) length += 1;// VolumeCurvePlateau = br.ReadByte();
                if (Bit(23)) length += 1;// SpeakerMask = br.ReadByte();
            }
            if ((Flags & 0xFF000000) != 0xAA000000)
            {
                if (Bit(24)) length += 1;// EffectRoute = br.ReadByte();
                if (Bit(25)) length += 4;// PreDelayVariable = br.ReadUInt32();
                if (Bit(26)) length += 4;// StartOffsetVariable = br.ReadUInt32();
                if (Bit(27)) length += 2;// SmallReverbSend = br.ReadUInt16();
                if (Bit(28)) length += 2;// MediumReverbSend = br.ReadUInt16();
                if (Bit(29)) length += 2;// LargeReverbSend = br.ReadUInt16();
                if (Bit(30)) length += 2;// Unk25 = br.ReadUInt16(); //maybe not
                if (Bit(31)) length += 2;// Unk26 = br.ReadUInt16(); //maybe not
            }

            return length;
        }

        private bool Bit(int b)
        {
            return ((Flags & (1u << b)) != 0);
        }

        public override string ToString()
        {
            return string.Format("{0}: {1}, {2}, {3}, {4}, {5}, {6}, {7}", Flags.Hex, Flags2.Hex, Category, StartOffset, StartOffsetVariance, VolumeCurve, PreDelayVariable, StartOffsetVariable);
        }
    }

    [TC(typeof(EXP))]
    public class RelSound : RelData
    {
        public RelSoundHeader Header { get; set; }
        public byte ChildSoundsCount { get; set; }
        public RelData[] ChildSounds { get; set; }
        public MetaHash[] ChildSoundsHashes { get; set; }
        public MetaHash[] AudioContainers { get; set; } //Relative path to parent wave container (i.e. "RESIDENT/animals")

        public RelSound(RelFile rel) : base(rel)
        {
        }
        public RelSound(RelData d, BinaryReader br) : base(d)
        {
            Header = new RelSoundHeader(br);
        }

        public void ReadChildSoundsHashes(BinaryReader br)
        {
            ChildSoundsCount = br.ReadByte();
            ChildSoundsHashes = new MetaHash[ChildSoundsCount];
            for (int i = 0; i < ChildSoundsCount; i++)
            {
                ChildSoundsHashes[i] = br.ReadUInt32();
            }
        }
        public void WriteChildSoundsHashes(BinaryWriter bw)
        {
            bw.Write(ChildSoundsCount);
            for (int i = 0; i < ChildSoundsCount; i++)
            {
                bw.Write(ChildSoundsHashes[i]);
            }
        }

        public override void Write(BinaryWriter bw)
        {
            bw.Write(TypeID);
            Header?.Write(bw);
        }

        public override void WriteXml(StringBuilder sb, int indent)
        {
            WriteHeaderXml(sb, indent);
            base.WriteXml(sb, indent);//fallback case
        }

        public void WriteHeaderXml(StringBuilder sb, int indent)
        {
            if (Header == null) return;
            RelXml.OpenTag(sb, indent, "Header");// flags=\"0x" + Header.Flags.Hex + "\"");
            Header.WriteXml(sb, indent + 1);
            RelXml.CloseTag(sb, indent, "Header");
        }

        public void WriteChildSoundsXml(StringBuilder sb, int indent, string nodeName = "ChildSounds")
        {
            if (ChildSoundsHashes == null) return;
            if (ChildSoundsHashes.Length > 0)
            {
                RelXml.OpenTag(sb, indent, nodeName);
                var cind = indent + 1;
                foreach (var hash in ChildSoundsHashes)
                {
                    RelXml.StringTag(sb, cind, "Item", RelXml.HashString(hash));
                }
                RelXml.CloseTag(sb, indent, nodeName);
            }
            else
            {
                RelXml.SelfClosingTag(sb, indent, nodeName);
            }
        }


        public void ReadHeaderXml(XmlNode node)
        {
            var hnode = node.SelectSingleNode("Header");
            if (hnode == null) return;

            Header = new RelSoundHeader(hnode);
        }

        public void ReadChildSoundsXml(XmlNode node, string nodeName = "ChildSounds")
        {
            var atnode = node.SelectSingleNode(nodeName);
            if (atnode == null) return;

            var childnodes = atnode.SelectNodes("Item");
            var childlist = new List<MetaHash>();
            foreach (XmlNode childnode in childnodes)
            {
                childlist.Add(XmlRel.GetHash(childnode.InnerText));
            }
            ChildSoundsHashes = childlist.ToArray();
            ChildSoundsCount = (byte)childlist.Count;
        }

        public uint[] GetChildSoundsHashTableOffsets(uint offset = 0)
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < ChildSoundsCount; i++)
            {
                offsets.Add(offset + 1 + i * 4);
            }
            return offsets.ToArray();
        }

        public override MetaHash[] GetSoundHashes()
        {
            return ChildSoundsHashes;
        }
        public override MetaHash[] GetCurveHashes()
        {
            if ((Header != null) && (Header.VolumeCurve != 0)) return new[] { Header.VolumeCurve };
            return null;
        }
        public override MetaHash[] GetCategoryHashes()
        {
            if ((Header != null) && (Header.Category != 0)) return new[] { Header.Category };
            return null;
        }
    }



    public enum Dat54SoundType : byte
    {
        LoopingSound = 1,
        EnvelopeSound = 2,
        TwinLoopSound = 3,
        SpeechSound = 4,
        OnStopSound = 5,
        WrapperSound = 6,
        SequentialSound = 7,
        StreamingSound = 8,
        RetriggeredOverlappedSound = 9,
        CrossfadeSound = 10,
        CollapsingStereoSound = 11,
        SimpleSound = 12,
        MultitrackSound = 13,
        RandomizedSound = 14,
        EnvironmentSound = 15,
        DynamicEntitySound = 16,
        SequentialOverlapSound = 17,
        ModularSynthSound = 18,
        GranularSound = 19,
        DirectionalSound = 20,
        KineticSound = 21,
        SwitchSound = 22,
        VariableCurveSound = 23,
        VariablePrintValueSound = 24,
        VariableBlockSound = 25,
        IfSound = 26,
        MathOperationSound = 27,
        ParameterTransformSound = 28,
        FluctuatorSound = 29,
        AutomationSound = 30,
        ExternalStreamSound = 31,
        SoundSet = 32,
        AutomationNoteMapSound = 33,
        SoundSetList = 34,
        SoundHashList = 35
    }

    [TC(typeof(EXP))]
    public class Dat54Sound : RelSound
    {
        public Dat54SoundType Type { get; set; }

        public Dat54Sound(RelFile rel, Dat54SoundType t) : base(rel)
        {
            Type = t;
            TypeID = (byte)t;
        }
        public Dat54Sound(RelData d, BinaryReader br) : base(d, br)
        {
            Type = (Dat54SoundType)TypeID;
        }

        public override void ReadXml(XmlNode node)
        {
            //don't use this as a fallback case! only for reading the header, for use with all defined Dat54Sounds!
            ReadHeaderXml(node);
            //base.ReadXml(node);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            //don't use this as a fallback case! only for writing the header, for use with all defined Dat54Sounds!
            WriteHeaderXml(sb, indent);
            //base.WriteXml(sb, indent);
        }

        public override string ToString()
        {
            return GetBaseString() + ": " + Type.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54LoopingSound : Dat54Sound
    {
        public short LoopCount { get; set; } //0x0-0x2 number of times looped
        public short LoopCountVariance { get; set; } //0x2-0x4 loop variance; + or - LoopCount
        public short LoopPoint { get; set; } //0x4-0x6 almost always 0? 1 on synths?
        public MetaHash ChildSound { get; set; } //0x6-0xA
        public MetaHash LoopCountVariable { get; set; } //0xA-0xE

        public Dat54LoopingSound(RelFile rel) : base(rel, Dat54SoundType.LoopingSound)
        { }
        public Dat54LoopingSound(RelData d, BinaryReader br) : base(d, br)
        {
            LoopCount = br.ReadInt16();
            LoopCountVariance = br.ReadInt16();
            LoopPoint = br.ReadInt16();
            ChildSound = br.ReadUInt32();
            ChildSoundsHashes = new[] { ChildSound };
            LoopCountVariable = br.ReadUInt32();
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            LoopCount = (short)Xml.GetChildIntAttribute(node, "LoopCount", "value");
            LoopCountVariance = (short)Xml.GetChildIntAttribute(node, "LoopCountVariance", "value");
            LoopPoint = (short)Xml.GetChildIntAttribute(node, "LoopPoint", "value");
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
            LoopCountVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "LoopCountVariable"));
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "LoopCount", LoopCount.ToString());
            RelXml.ValueTag(sb, indent, "LoopCountVariance", LoopCountVariance.ToString());
            RelXml.ValueTag(sb, indent, "LoopPoint", LoopPoint.ToString());
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
            RelXml.StringTag(sb, indent, "LoopCountVariable", RelXml.HashString(LoopCountVariable));
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(LoopCount);
            bw.Write(LoopCountVariance);
            bw.Write(LoopPoint);
            bw.Write(ChildSound);
            bw.Write(LoopCountVariable);
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 6 };
        }
    }
    [TC(typeof(EXP))]
    public class Dat54EnvelopeSound : Dat54Sound
    {
        public ushort Attack { get; set; } //0x0-0x2 ADSHR attack in ms. used by PTS or other types.
        public ushort AttackVariance { get; set; } //0x2-0x4 variance of attack in ms.
        public ushort Decay { get; set; } //0x4-0x6 ADSHR decay in ms.
        public ushort DecayVariance { get; set; } //0x6-0x8 variance of decay in ms.
        public byte Sustain { get; set; } //0x8-0x9 ADSHR sustain percentage
        public byte SustainVariance { get; set; } //0x9-0xA variance of sustain percentage.
        public int Hold { get; set; } //0xA-0xE ADSHR hold in ms.
        public ushort HoldVariance { get; set; } //0xE-0x10 variance of hold in ms.
        public int Release { get; set; } //0x10-0x14 ADSHR release in ms.
        public int ReleaseVariance { get; set; } //0x14-0x18 variance of release in ms.
        public MetaHash AttackCurve { get; set; } //0x18-0x1C curves.dat curve shape for attack.
        public MetaHash DecayCurve { get; set; } //0x1C-0x20 curves.dat curve shape for decay.
        public MetaHash ReleaseCurve { get; set; } //0x20-0x24 curves.dat curve shape for release.
        public MetaHash AttackVariable { get; set; } //0x24-0x28 parameter override for attack.
        public MetaHash DecayVariable { get; set; } //0x28-0x2C parameter override for decay.
        public MetaHash SustainVariable { get; set; } //0x2C-0x30 parameter override for sustain.
        public MetaHash HoldVariable { get; set; } //0x30-0x34 parameter override for hold.
        public MetaHash ReleaseVariable { get; set; } //0x34-0x38 parameter override for release.
        public MetaHash ChildSound { get; set; }// audio track 0x38-0x3C
        public int Mode { get; set; } //0x3C-0x40 type of envelope (0 volume, 1 pitch, 2 pan, etc)
        public MetaHash OutputVariable { get; set; } //0x40-0x44 envelope parameter override (mode 5)
        public float OutputRangeMin { get; set; } //0x44-0x48 level min (controls level min before/after attack/release)
        public float OutputRangeMax { get; set; } //0x48-0x4C level max (controls level max between attack/decay)

        public Dat54EnvelopeSound(RelFile rel) : base(rel, Dat54SoundType.EnvelopeSound)
        { }
        public Dat54EnvelopeSound(RelData d, BinaryReader br) : base(d, br)
        {
            Attack = br.ReadUInt16(); //0x0-0x2
            AttackVariance = br.ReadUInt16(); //0x2-0x4
            Decay = br.ReadUInt16(); //0x4-0x6
            DecayVariance = br.ReadUInt16(); //0x6-0x8
            Sustain = br.ReadByte(); //0x8-0x9
            SustainVariance = br.ReadByte(); //0x9-0xA
            Hold = br.ReadInt32(); //0xA-0xE
            HoldVariance = br.ReadUInt16(); //0xE-0x10
            Release = br.ReadInt32(); //0x10-0x14
            ReleaseVariance = br.ReadInt32(); //0x14-0x18
            AttackCurve = br.ReadUInt32(); //0x18-0x1C
            DecayCurve = br.ReadUInt32(); //0x1C-0x20
            ReleaseCurve = br.ReadUInt32(); //0x20-0x24
            AttackVariable = br.ReadUInt32(); //0x24-0x28
            DecayVariable = br.ReadUInt32(); //0x28-0x2C
            SustainVariable = br.ReadUInt32(); //0x2C-0x30
            HoldVariable = br.ReadUInt32(); //0x30-0x34
            ReleaseVariable = br.ReadUInt32(); //0x34-0x38
            ChildSound = br.ReadUInt32(); //0x38-0x3C
            Mode = br.ReadInt32(); //0x3C-0x40
            OutputVariable = br.ReadUInt32(); //0x40-0x44
            OutputRangeMin = br.ReadSingle(); //0x44-0x48
            OutputRangeMax = br.ReadSingle(); //0x48-0x4C
            ChildSoundsHashes = new[] { ChildSound };
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            Attack = (ushort)Xml.GetChildUIntAttribute(node, "Attack", "value");
            AttackVariance = (ushort)Xml.GetChildUIntAttribute(node, "AttackVariance", "value");
            Decay = (ushort)Xml.GetChildUIntAttribute(node, "Decay", "value");
            DecayVariance = (ushort)Xml.GetChildUIntAttribute(node, "DecayVariance", "value");
            Sustain = (byte)Xml.GetChildUIntAttribute(node, "Sustain", "value");
            SustainVariance = (byte)Xml.GetChildUIntAttribute(node, "SustainVariance", "value");
            Hold = Xml.GetChildIntAttribute(node, "Hold", "value");
            HoldVariance = (ushort)Xml.GetChildUIntAttribute(node, "HoldVariance", "value");
            Release = Xml.GetChildIntAttribute(node, "Release", "value");
            ReleaseVariance = Xml.GetChildIntAttribute(node, "ReleaseVariance", "value");
            AttackCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "AttackCurve"));
            DecayCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DecayCurve"));
            ReleaseCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ReleaseCurve"));
            AttackVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "AttackVariable"));
            DecayVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "DecayVariable"));
            SustainVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "SustainVariable"));
            HoldVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "HoldVariable"));
            ReleaseVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "ReleaseVariable"));
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
            Mode = Xml.GetChildIntAttribute(node, "Mode", "value");
            OutputVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "OutputVariable"));
            OutputRangeMin = Xml.GetChildFloatAttribute(node, "OutputRangeMin", "value");
            OutputRangeMax = Xml.GetChildFloatAttribute(node, "OutputRangeMax", "value");
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "Attack", Attack.ToString());
            RelXml.ValueTag(sb, indent, "AttackVariance", AttackVariance.ToString());
            RelXml.ValueTag(sb, indent, "Decay", Decay.ToString());
            RelXml.ValueTag(sb, indent, "DecayVariance", DecayVariance.ToString());
            RelXml.ValueTag(sb, indent, "Sustain", Sustain.ToString());
            RelXml.ValueTag(sb, indent, "SustainVariance", SustainVariance.ToString());
            RelXml.ValueTag(sb, indent, "Hold", Hold.ToString());
            RelXml.ValueTag(sb, indent, "HoldVariance", HoldVariance.ToString());
            RelXml.ValueTag(sb, indent, "Release", Release.ToString());
            RelXml.ValueTag(sb, indent, "ReleaseVariance", ReleaseVariance.ToString());
            RelXml.StringTag(sb, indent, "AttackCurve", RelXml.HashString(AttackCurve));
            RelXml.StringTag(sb, indent, "DecayCurve", RelXml.HashString(DecayCurve));
            RelXml.StringTag(sb, indent, "ReleaseCurve", RelXml.HashString(ReleaseCurve));
            RelXml.StringTag(sb, indent, "AttackVariable", RelXml.HashString(AttackVariable));
            RelXml.StringTag(sb, indent, "DecayVariable", RelXml.HashString(DecayVariable));
            RelXml.StringTag(sb, indent, "SustainVariable", RelXml.HashString(SustainVariable));
            RelXml.StringTag(sb, indent, "HoldVariable", RelXml.HashString(HoldVariable));
            RelXml.StringTag(sb, indent, "ReleaseVariable", RelXml.HashString(ReleaseVariable));
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
            RelXml.ValueTag(sb, indent, "Mode", Mode.ToString());
            RelXml.StringTag(sb, indent, "OutputVariable", RelXml.HashString(OutputVariable));
            RelXml.ValueTag(sb, indent, "OutputRangeMin", FloatUtil.ToString(OutputRangeMin));
            RelXml.ValueTag(sb, indent, "OutputRangeMax", FloatUtil.ToString(OutputRangeMax));
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(Attack); //0x0-0x2
            bw.Write(AttackVariance); //0x2-0x4
            bw.Write(Decay); //0x4-0x6
            bw.Write(DecayVariance); //0x6-0x8
            bw.Write(Sustain); //0x8-0x9
            bw.Write(SustainVariance); //0x9-0xA
            bw.Write(Hold); //0xA-0xE
            bw.Write(HoldVariance); //0xE-0x10
            bw.Write(Release); //0x10-0x14
            bw.Write(ReleaseVariance); //0x14-0x18
            bw.Write(AttackCurve); //0x18-0x1C
            bw.Write(DecayCurve); //0x1C-0x20
            bw.Write(ReleaseCurve); //0x20-0x24
            bw.Write(AttackVariable); //0x24-0x28
            bw.Write(DecayVariable); //0x28-0x2C
            bw.Write(SustainVariable); //0x2C-0x30
            bw.Write(HoldVariable); //0x30-0x34
            bw.Write(ReleaseVariable); //0x34-0x38
            bw.Write(ChildSound); //0x38-0x3C
            bw.Write(Mode); //0x3C-0x40
            bw.Write(OutputVariable); //0x40-0x44
            bw.Write(OutputRangeMin); //0x44-0x48
            bw.Write(OutputRangeMax); //0x48-0x4C
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 56 };
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { AttackCurve, DecayCurve, ReleaseCurve };
        }
    }
    [TC(typeof(EXP))]
    class Dat54TwinLoopSound : Dat54Sound
    {
        public ushort MinSwapTime { get; set; } //0x0-0x2 //minimum duration in ms of the two samples, if they are longer they are shortened to this value.
        public ushort MaxSwapTime { get; set; } //0x2-0x4 //maximum duration in ms of the two samples, if they are longer they are shortened to this value.
        public ushort MinCrossfadeTime { get; set; } //0x4-0x6 //minimum amount of crossfade in ms between the two samples. requires a valid crossfade curve.
        public ushort MaxCrossfadeTime { get; set; } //0x6-0x8 //maximum amount of crossfade in ms between the two samples. requires a valid crosfade curve.
        public MetaHash CrossfadeCurve { get; set; } //0x8-0xC //curves.dat curve shape for crossfade between the two samples.
        public MetaHash MinSwapTimeVariable { get; set; } //0xC-0x10 //parameter override for duration min.
        public MetaHash MaxSwapTimeVariable { get; set; } //0x10-0x14 //parameter override for duration max.
        public MetaHash MinCrossfadeTimeVariable { get; set; } //0x14-0x18 //parameter override for crossfade min.
        public MetaHash MaxCrossfadeTimeVariable { get; set; } //0x18-0x1C //parameter override for crossfade max.

        public Dat54TwinLoopSound(RelFile rel) : base(rel, Dat54SoundType.TwinLoopSound)
        { }
        public Dat54TwinLoopSound(RelData d, BinaryReader br) : base(d, br)
        {
            MinSwapTime = br.ReadUInt16();
            MaxSwapTime = br.ReadUInt16();
            MinCrossfadeTime = br.ReadUInt16();
            MaxCrossfadeTime = br.ReadUInt16();
            CrossfadeCurve = br.ReadUInt32();
            MinSwapTimeVariable = br.ReadUInt32();
            MaxSwapTimeVariable = br.ReadUInt32();
            MinCrossfadeTimeVariable = br.ReadUInt32();
            MaxCrossfadeTimeVariable = br.ReadUInt32();

            ReadChildSoundsHashes(br);
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            MinSwapTime = (ushort)Xml.GetChildUIntAttribute(node, "MinSwapTime", "value");
            MaxSwapTime = (ushort)Xml.GetChildUIntAttribute(node, "MaxSwapTime", "value");
            MinCrossfadeTime = (ushort)Xml.GetChildUIntAttribute(node, "MinCrossfadeTime", "value");
            MaxCrossfadeTime = (ushort)Xml.GetChildUIntAttribute(node, "MaxCrossfadeTime", "value");
            CrossfadeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "CrossfadeCurve"));
            MinSwapTimeVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "MinSwapTimeVariable"));
            MaxSwapTimeVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "MaxSwapTimeVariable"));
            MinCrossfadeTimeVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "MinCrossfadeTimeVariable"));
            MaxCrossfadeTimeVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "MaxCrossfadeTimeVariable"));
            ReadChildSoundsXml(node);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "MinSwapTime", MinSwapTime.ToString());
            RelXml.ValueTag(sb, indent, "MaxSwapTime", MaxSwapTime.ToString());
            RelXml.ValueTag(sb, indent, "MinCrossfadeTime", MinCrossfadeTime.ToString());
            RelXml.ValueTag(sb, indent, "MaxCrossfadeTime", MaxCrossfadeTime.ToString());
            RelXml.StringTag(sb, indent, "CrossfadeCurve", RelXml.HashString(CrossfadeCurve));
            RelXml.StringTag(sb, indent, "MinSwapTimeVariable", RelXml.HashString(MinSwapTimeVariable));
            RelXml.StringTag(sb, indent, "MaxSwapTimeVariable", RelXml.HashString(MaxSwapTimeVariable));
            RelXml.StringTag(sb, indent, "MinCrossfadeTimeVariable", RelXml.HashString(MinCrossfadeTimeVariable));
            RelXml.StringTag(sb, indent, "MaxCrossfadeTimeVariable", RelXml.HashString(MaxCrossfadeTimeVariable));
            WriteChildSoundsXml(sb, indent);
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(MinSwapTime);
            bw.Write(MaxSwapTime);
            bw.Write(MinCrossfadeTime);
            bw.Write(MaxCrossfadeTime);
            bw.Write(CrossfadeCurve);
            bw.Write(MinSwapTimeVariable);
            bw.Write(MaxSwapTimeVariable);
            bw.Write(MinCrossfadeTimeVariable);
            bw.Write(MaxCrossfadeTimeVariable);

            WriteChildSoundsHashes(bw);
        }
        public override uint[] GetHashTableOffsets()
        {
            return GetChildSoundsHashTableOffsets(28);
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { CrossfadeCurve };
        }
    }
    [TC(typeof(EXP))]
    class Dat54SpeechSound : Dat54Sound
    {
        public int LastVariation { get; set; }
        public MetaHash DynamicFieldName { get; set; } //0x4-0x8
        public MetaHash VoiceName { get; set; } //0x8-0xC
        public string ContextName { get; set; } //0xD-...

        public Dat54SpeechSound(RelFile rel) : base(rel, Dat54SoundType.SpeechSound)
        { }
        public Dat54SpeechSound(RelData d, BinaryReader br) : base(d, br)
        {
            LastVariation = br.ReadInt32();
            DynamicFieldName = br.ReadUInt32();
            VoiceName = br.ReadUInt32();
            ContextName = br.ReadString();
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            LastVariation = Xml.GetChildIntAttribute(node, "LastVariation", "value");
            DynamicFieldName = XmlRel.GetHash(Xml.GetChildInnerText(node, "DynamicFieldName"));
            VoiceName = XmlRel.GetHash(Xml.GetChildInnerText(node, "VoiceName"));
            ContextName = Xml.GetChildInnerText(node, "ContextName");
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "LastVariation", LastVariation.ToString());
            RelXml.StringTag(sb, indent, "DynamicFieldName", RelXml.HashString(DynamicFieldName));
            RelXml.StringTag(sb, indent, "VoiceName", RelXml.HashString(VoiceName));
            RelXml.StringTag(sb, indent, "ContextName", ContextName);
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(LastVariation);
            bw.Write(DynamicFieldName);
            bw.Write(VoiceName);
            bw.Write(ContextName);
        }
    }

    [TC(typeof(EXP))]
    public class Dat54OnStopSound : Dat54Sound
    {
        public MetaHash ChildSound { get; set; }
        public MetaHash StopSound { get; set; } //plays once childsound is finished playing (enveloped or single sample, no loops)
        public MetaHash FinishedSound { get; set; } //plays when the onstop entry is empty or invalid

        public Dat54OnStopSound(RelFile rel) : base(rel, Dat54SoundType.OnStopSound)
        { }
        public Dat54OnStopSound(RelData d, BinaryReader br) : base(d, br)
        {
            ChildSound = br.ReadUInt32();
            StopSound = br.ReadUInt32();
            FinishedSound = br.ReadUInt32();
            ChildSoundsHashes = new[] { ChildSound, StopSound, FinishedSound };
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
            StopSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "StopSound"));
            FinishedSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "FinishedSound"));
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
            RelXml.StringTag(sb, indent, "StopSound", RelXml.HashString(StopSound));
            RelXml.StringTag(sb, indent, "FinishedSound", RelXml.HashString(FinishedSound));
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(ChildSound);
            bw.Write(StopSound);
            bw.Write(FinishedSound);
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0, 4, 8 };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54WrapperSound : Dat54Sound
    {
        public MetaHash ChildSound { get; set; } //0x0-0x4
        public int LastPlayTime { get; set; } //0x4-0x8  // maybe start delay?
        public MetaHash FallBackSound { get; set; } //0x8-0xC sound falled back on if main sound not found
        public short MinRepeatTime { get; set; } //0xC-0xE  // [camxx:] My guess is that this is related to the time at which a child sound should start playin (or the length of the sound).
        public byte VariableCount { get; set; }
        public MetaHash[] VariableNames { get; set; } //0xF // apply any variables here. seems to have been a header field in IV but merged only with wrapper sound in V.
        public byte[] VariableValues { get; set; } // ...

        public Dat54WrapperSound(RelFile rel) : base(rel, Dat54SoundType.WrapperSound)
        { }
        public Dat54WrapperSound(RelData d, BinaryReader br) : base(d, br)
        {
            ChildSound = br.ReadUInt32();
            LastPlayTime = br.ReadInt32();
            FallBackSound = br.ReadUInt32();
            MinRepeatTime = br.ReadInt16();
            VariableCount = br.ReadByte();
            VariableNames = new MetaHash[VariableCount];
            VariableValues = new byte[VariableCount];
            for (int i = 0; i < VariableCount; i++)
            {
                VariableNames[i] = br.ReadUInt32();
                VariableValues[i] = br.ReadByte();
            }

            ChildSoundsHashes = new[] { ChildSound, FallBackSound };
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
            LastPlayTime = Xml.GetChildIntAttribute(node, "LastPlayTime", "value");
            FallBackSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "FallBackSound"));
            MinRepeatTime = (short)Xml.GetChildIntAttribute(node, "MinRepeatTime", "value");
            var vnode = node.SelectSingleNode("Variables");
            if (vnode != null)
            {
                var inodes = vnode.SelectNodes("Item");
                if (inodes?.Count > 0)
                {
                    var nlist = new List<MetaHash>();
                    var vlist = new List<byte>();
                    foreach (XmlNode inode in inodes)
                    {
                        nlist.Add(XmlRel.GetHash(Xml.GetStringAttribute(inode, "name")));
                        vlist.Add((byte)Xml.GetIntAttribute(inode, "value"));
                    }
                    VariableCount = (byte)nlist.Count;
                    VariableNames = nlist.ToArray();
                    VariableValues = vlist.ToArray();
                }
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
            RelXml.ValueTag(sb, indent, "LastPlayTime", LastPlayTime.ToString());
            RelXml.StringTag(sb, indent, "FallBackSound", RelXml.HashString(FallBackSound));
            RelXml.ValueTag(sb, indent, "MinRepeatTime", MinRepeatTime.ToString());
            if (VariableNames?.Length > 0)
            {
                RelXml.OpenTag(sb, indent, "Variables");
                var cind = indent + 1;
                for (int i = 0; i < VariableCount; i++)
                {
                    var iname = RelXml.HashString(VariableNames[i]);
                    var ival = VariableValues[i].ToString();
                    RelXml.SelfClosingTag(sb, cind, "Item name=\"" + iname + "\" value=\"" + ival + "\"");
                }
                RelXml.CloseTag(sb, indent, "Variables");
            }
            else
            {
                RelXml.SelfClosingTag(sb, indent, "Variables");
            }
            WriteChildSoundsXml(sb, indent);
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(ChildSound);
            bw.Write(LastPlayTime);
            bw.Write(FallBackSound);
            bw.Write(MinRepeatTime);
            bw.Write(VariableCount);
            for (int i = 0; i < VariableCount; i++)
            {
                bw.Write(VariableNames[i]);
                bw.Write(VariableValues[i]);
            }
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0, 8 };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54SequentialSound : Dat54Sound
    {
        public Dat54SequentialSound(RelFile rel) : base(rel, Dat54SoundType.SequentialSound)
        { }
        public Dat54SequentialSound(RelData d, BinaryReader br) : base(d, br)
        {
            ReadChildSoundsHashes(br);
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ReadChildSoundsXml(node);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            WriteChildSoundsXml(sb, indent);
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            WriteChildSoundsHashes(bw);
        }
        public override uint[] GetHashTableOffsets()
        {
            return GetChildSoundsHashTableOffsets();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54StreamingSound : Dat54Sound
    {
        public int Duration { get; set; } //0x0-0x4

        public Dat54StreamingSound(RelFile rel) : base(rel, Dat54SoundType.StreamingSound)
        { }
        public Dat54StreamingSound(RelData d, BinaryReader br) : base(d, br)
        {
            Duration = br.ReadInt32();

            ReadChildSoundsHashes(br);
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            Duration = Xml.GetChildIntAttribute(node, "Duration", "value");
            ReadChildSoundsXml(node);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "Duration", Duration.ToString());
            WriteChildSoundsXml(sb, indent);
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(Duration);
            WriteChildSoundsHashes(bw);
        }
        public override uint[] GetHashTableOffsets()
        {
            return GetChildSoundsHashTableOffsets(4);
        }
    }

    [TC(typeof(EXP))]
    public class Dat54RetriggeredOverlappedSound : Dat54Sound
    {
        public short LoopCount { get; set; } //0x0-0x2 number of times to repeat. includes start and tail sounds if defined
        public ushort LoopCountVariance { get; set; } //0x2-0x4 variance of retrigger count
        public ushort DelayTime { get; set; } //0x4-0x6 amount of delay in ms between the start of the retriggers
        public ushort DelayTimeVariance { get; set; } // 0x6-0x8 variance of delay
        public MetaHash LoopCountVariable { get; set; } //0x8-0xC parameter override for retrigger count
        public MetaHash DelayTimeVariable { get; set; } //0xC-0x10 parameter override for delay
        public MetaHash StartSound { get; set; } // sound to play on first instance
        public MetaHash RetriggerSound { get; set; } //sound to retrigger
        public MetaHash StopSound { get; set; }  //sound to play on last instance

        public Dat54RetriggeredOverlappedSound(RelFile rel) : base(rel, Dat54SoundType.RetriggeredOverlappedSound)
        { }
        public Dat54RetriggeredOverlappedSound(RelData d, BinaryReader br) : base(d, br)
        {
            LoopCount = br.ReadInt16();
            LoopCountVariance = br.ReadUInt16();
            DelayTime = br.ReadUInt16();
            DelayTimeVariance = br.ReadUInt16();
            LoopCountVariable = br.ReadUInt32();
            DelayTimeVariable = br.ReadUInt32();
            StartSound = br.ReadUInt32();
            RetriggerSound = br.ReadUInt32();
            StopSound = br.ReadUInt32();
            ChildSoundsHashes = new[] { StartSound, RetriggerSound, StopSound };
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            LoopCount = (short)Xml.GetChildIntAttribute(node, "LoopCount", "value");
            LoopCountVariance = (ushort)Xml.GetChildUIntAttribute(node, "LoopCountVariance", "value");
            DelayTime = (ushort)Xml.GetChildUIntAttribute(node, "DelayTime", "value");
            DelayTimeVariance = (ushort)Xml.GetChildUIntAttribute(node, "DelayTimeVariance", "value");
            LoopCountVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "LoopCountVariable"));
            DelayTimeVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "DelayTimeVariable"));
            StartSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "StartSound"));
            RetriggerSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RetriggerSound"));
            StopSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "StopSound"));
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "LoopCount", LoopCount.ToString());
            RelXml.ValueTag(sb, indent, "LoopCountVariance", LoopCountVariance.ToString());
            RelXml.ValueTag(sb, indent, "DelayTime", DelayTime.ToString());
            RelXml.ValueTag(sb, indent, "DelayTimeVariance", DelayTimeVariance.ToString());
            RelXml.StringTag(sb, indent, "LoopCountVariable", RelXml.HashString(LoopCountVariable));
            RelXml.StringTag(sb, indent, "DelayTimeVariable", RelXml.HashString(DelayTimeVariable));
            RelXml.StringTag(sb, indent, "StartSound", RelXml.HashString(StartSound));
            RelXml.StringTag(sb, indent, "RetriggerSound", RelXml.HashString(RetriggerSound));
            RelXml.StringTag(sb, indent, "StopSound", RelXml.HashString(StopSound));
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(LoopCount);
            bw.Write(LoopCountVariance);
            bw.Write(DelayTime);
            bw.Write(DelayTimeVariance);
            bw.Write(LoopCountVariable);
            bw.Write(DelayTimeVariable);
            bw.Write(StartSound);
            bw.Write(RetriggerSound);
            bw.Write(StopSound);
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 16, 20, 24 };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54CrossfadeSound : Dat54Sound
    {
        public MetaHash NearSound { get; set; }
        public MetaHash FarSound { get; set; }
        public byte Mode { get; set; } //0x8-0x9
        public float MinDistance { get; set; } //0x9-0xD
        public float MaxDistance { get; set; } //0xD-0x11
        public int Hysteresis { get; set; } //0xD-0x15
        public MetaHash CrossfadeCurve { get; set; } //0x15-0x19
        public MetaHash DistanceVariable { get; set; } //0x19-0x1D
        public MetaHash MinDistanceVariable { get; set; } //0x1D-0x21
        public MetaHash MaxDistanceVariable { get; set; } //0x21-0x25
        public MetaHash HysteresisVariable { get; set; } //0x25-0x29
        public MetaHash CrossfadeVariable { get; set; } //0x29-0x2D

        public Dat54CrossfadeSound(RelFile rel) : base(rel, Dat54SoundType.CrossfadeSound)
        { }
        public Dat54CrossfadeSound(RelData d, BinaryReader br) : base(d, br)
        {
            NearSound = br.ReadUInt32();
            FarSound = br.ReadUInt32();
            ChildSoundsHashes = new[] { NearSound, FarSound };
            Mode = br.ReadByte();
            MinDistance = br.ReadSingle();
            MaxDistance = br.ReadSingle();
            Hysteresis = br.ReadInt32();
            CrossfadeCurve = br.ReadUInt32();
            DistanceVariable = br.ReadUInt32();
            MinDistanceVariable = br.ReadUInt32();
            MaxDistanceVariable = br.ReadUInt32();
            HysteresisVariable = br.ReadUInt32();
            CrossfadeVariable = br.ReadUInt32();
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            NearSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "NearSound"));
            FarSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "FarSound"));
            Mode = (byte)Xml.GetChildUIntAttribute(node, "Mode", "value");
            MinDistance = Xml.GetChildFloatAttribute(node, "MinDistance", "value");
            MaxDistance = Xml.GetChildFloatAttribute(node, "MaxDistance", "value");
            Hysteresis = Xml.GetChildIntAttribute(node, "Hysteresis", "value");
            CrossfadeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "CrossfadeCurve"));
            DistanceVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "DistanceVariable"));
            MinDistanceVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "MinDistanceVariable"));
            MaxDistanceVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "MaxDistanceVariable"));
            HysteresisVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "HysteresisVariable"));
            CrossfadeVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "CrossfadeVariable"));
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "NearSound", RelXml.HashString(NearSound));
            RelXml.StringTag(sb, indent, "FarSound", RelXml.HashString(FarSound));
            RelXml.ValueTag(sb, indent, "Mode", Mode.ToString());
            RelXml.ValueTag(sb, indent, "MinDistance", FloatUtil.ToString(MinDistance));
            RelXml.ValueTag(sb, indent, "MaxDistance", FloatUtil.ToString(MaxDistance));
            RelXml.ValueTag(sb, indent, "Hysteresis", Hysteresis.ToString());
            RelXml.StringTag(sb, indent, "CrossfadeCurve", RelXml.HashString(CrossfadeCurve));
            RelXml.StringTag(sb, indent, "DistanceVariable", RelXml.HashString(DistanceVariable));
            RelXml.StringTag(sb, indent, "MinDistanceVariable", RelXml.HashString(MinDistanceVariable));
            RelXml.StringTag(sb, indent, "MaxDistanceVariable", RelXml.HashString(MaxDistanceVariable));
            RelXml.StringTag(sb, indent, "HysteresisVariable", RelXml.HashString(HysteresisVariable));
            RelXml.StringTag(sb, indent, "CrossfadeVariable", RelXml.HashString(CrossfadeVariable));
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(NearSound);
            bw.Write(FarSound);
            bw.Write(Mode);
            bw.Write(MinDistance);
            bw.Write(MaxDistance);
            bw.Write(Hysteresis);
            bw.Write(CrossfadeCurve);
            bw.Write(DistanceVariable);
            bw.Write(MinDistanceVariable);
            bw.Write(MaxDistanceVariable);
            bw.Write(HysteresisVariable);
            bw.Write(CrossfadeVariable);
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0, 4 };
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { CrossfadeCurve };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54CollapsingStereoSound : Dat54Sound
    {
        public MetaHash LeftSound { get; set; }
        public MetaHash RightSound { get; set; }
        public float MinDistance { get; set; }
        public float MaxDistance { get; set; }
        public MetaHash MinDistanceVariable { get; set; } //0x10-0x14
        public MetaHash MaxDistanceVariable { get; set; } //0x14-0x18
        public MetaHash CrossfadeOverrideVariable { get; set; } //0x18-0x1C
        public MetaHash FrontendLeftPanVariable { get; set; } //0x1C-0x20
        public MetaHash FrontendRightPanVariable { get; set; } //0x20-0x24
        public float PositionRelativePanDamping { get; set; } //0x24-0x28
        public MetaHash PositionRelativePanDampingVariable { get; set; } //0x28-0x2C
        public byte Mode { get; set; } //0x2c-0x2D

        public Dat54CollapsingStereoSound(RelFile rel) : base(rel, Dat54SoundType.CollapsingStereoSound)
        { }
        public Dat54CollapsingStereoSound(RelData d, BinaryReader br) : base(d, br)
        {
            LeftSound = br.ReadUInt32();
            RightSound = br.ReadUInt32();
            ChildSoundsHashes = new[] { LeftSound, RightSound };
            MinDistance = br.ReadSingle(); //0x8
            MaxDistance = br.ReadSingle(); //0xC
            MinDistanceVariable = br.ReadUInt32(); //0x10
            MaxDistanceVariable = br.ReadUInt32(); //0x14
            CrossfadeOverrideVariable = br.ReadUInt32(); //0x18
            FrontendLeftPanVariable = br.ReadUInt32(); //0x1C
            FrontendRightPanVariable = br.ReadUInt32(); //0x20
            PositionRelativePanDamping = br.ReadSingle(); //0x24-0x28
            PositionRelativePanDampingVariable = br.ReadUInt32(); //0x28-0x2C
            Mode = br.ReadByte(); //0x2C-0x2D
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            LeftSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "LeftSound"));
            RightSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RightSound"));
            MinDistance = Xml.GetChildFloatAttribute(node, "MinDistance", "value");
            MaxDistance = Xml.GetChildFloatAttribute(node, "MaxDistance", "value");
            MinDistanceVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "MinDistanceVariable"));
            MaxDistanceVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "MaxDistanceVariable"));
            CrossfadeOverrideVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "CrossfadeOverrideVariable"));
            FrontendLeftPanVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "FrontendLeftPanVariable"));
            FrontendRightPanVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "FrontendRightPanVariable"));
            PositionRelativePanDamping = Xml.GetChildFloatAttribute(node, "PositionRelativePanDamping", "value");
            PositionRelativePanDampingVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "PositionRelativePanDampingVariable"));
            Mode = (byte)Xml.GetChildUIntAttribute(node, "Mode", "value");
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "LeftSound", RelXml.HashString(LeftSound));
            RelXml.StringTag(sb, indent, "RightSound", RelXml.HashString(RightSound));
            RelXml.ValueTag(sb, indent, "MinDistance", FloatUtil.ToString(MinDistance));
            RelXml.ValueTag(sb, indent, "MaxDistance", FloatUtil.ToString(MaxDistance));
            RelXml.StringTag(sb, indent, "MinDistanceVariable", RelXml.HashString(MinDistanceVariable));
            RelXml.StringTag(sb, indent, "MaxDistanceVariable", RelXml.HashString(MaxDistanceVariable));
            RelXml.StringTag(sb, indent, "CrossfadeOverrideVariable", RelXml.HashString(CrossfadeOverrideVariable));
            RelXml.StringTag(sb, indent, "FrontendLeftPanVariable", RelXml.HashString(FrontendLeftPanVariable));
            RelXml.StringTag(sb, indent, "FrontendRightPanVariable", RelXml.HashString(FrontendRightPanVariable));
            RelXml.ValueTag(sb, indent, "PositionRelativePanDamping", FloatUtil.ToString(PositionRelativePanDamping));
            RelXml.StringTag(sb, indent, "PositionRelativePanDampingVariable", RelXml.HashString(PositionRelativePanDampingVariable));
            RelXml.ValueTag(sb, indent, "Mode", Mode.ToString());
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(LeftSound);
            bw.Write(RightSound);
            bw.Write(MinDistance); //0x8
            bw.Write(MaxDistance); //0xC
            bw.Write(MinDistanceVariable); //0x10
            bw.Write(MaxDistanceVariable); //0x14
            bw.Write(CrossfadeOverrideVariable); //0x18
            bw.Write(FrontendLeftPanVariable); //0x1C
            bw.Write(FrontendRightPanVariable); //0x20
            bw.Write(PositionRelativePanDamping); //0x24-0x28
            bw.Write(PositionRelativePanDampingVariable); //0x28-0x2C
            bw.Write(Mode); //0x2C-0x2D
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0, 4 };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54SimpleSound : Dat54Sound
    {
        public MetaHash ContainerName { get; set; } //Relative path to parent wave container (i.e. "RESIDENT/animals")
        public MetaHash FileName { get; set; } //Name of the .wav file
        public byte WaveSlotIndex { get; set; } //Internal index of wave (.awc) container

        public Dat54SimpleSound(RelFile rel) : base(rel, Dat54SoundType.SimpleSound)
        { }
        public Dat54SimpleSound(RelData d, BinaryReader br) : base(d, br)
        {
            ContainerName = br.ReadUInt32();
            AudioContainers = new[] { ContainerName };
            FileName = br.ReadUInt32();
            WaveSlotIndex = br.ReadByte();
            if (br.BaseStream.Position < br.BaseStream.Length)
            { }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ContainerName = XmlRel.GetHash(Xml.GetChildInnerText(node, "ContainerName"));
            FileName = XmlRel.GetHash(Xml.GetChildInnerText(node, "FileName"));
            WaveSlotIndex = (byte)Xml.GetChildUIntAttribute(node, "WaveSlotIndex", "value");
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "ContainerName", RelXml.HashString(ContainerName));
            RelXml.StringTag(sb, indent, "FileName", RelXml.HashString(FileName));
            RelXml.ValueTag(sb, indent, "WaveSlotIndex", WaveSlotIndex.ToString());
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(ContainerName);
            bw.Write(FileName);
            bw.Write(WaveSlotIndex);
        }
        public override uint[] GetPackTableOffsets()
        {
            return new uint[] { 0 };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54MultitrackSound : Dat54Sound
    {
        public Dat54MultitrackSound(RelFile rel) : base(rel, Dat54SoundType.MultitrackSound)
        { }
        public Dat54MultitrackSound(RelData d, BinaryReader br) : base(d, br)
        {
            ReadChildSoundsHashes(br);
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ReadChildSoundsXml(node);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            WriteChildSoundsXml(sb, indent);
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            WriteChildSoundsHashes(bw);
        }
        public override uint[] GetHashTableOffsets()
        {
            return GetChildSoundsHashTableOffsets();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54RandomizedSound : Dat54Sound
    {
        public byte HistoryIndex { get; set; } //0x0-0x1 retricts the randomization range?
        public byte HistorySpaceCount { get; set; } //0x1-0x2
        public byte[] HistorySpace { get; set; } //seem to prevent randomization from playing the same sound twice in a row?
        public byte VariationsCount { get; set; }
        public float[] VariationsValues { get; set; } //probability..?

        public Dat54RandomizedSound(RelFile rel) : base(rel, Dat54SoundType.RandomizedSound)
        { }
        public Dat54RandomizedSound(RelData d, BinaryReader br) : base(d, br)
        {
            HistoryIndex = br.ReadByte();
            HistorySpaceCount = br.ReadByte();
            HistorySpace = br.ReadBytes(HistorySpaceCount);
            VariationsCount = br.ReadByte();
            ChildSoundsHashes = new MetaHash[VariationsCount];
            VariationsValues = new float[VariationsCount];
            for (int i = 0; i < VariationsCount; i++)
            {
                ChildSoundsHashes[i] = br.ReadUInt32();
                VariationsValues[i] = br.ReadSingle();
            }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            HistoryIndex = (byte)Xml.GetChildUIntAttribute(node, "HistoryIndex", "value");
            HistorySpace = Xml.GetChildRawByteArray(node, "HistorySpace");
            HistorySpaceCount = (byte)HistorySpace.Length;
            var vnode = node.SelectSingleNode("Variations");
            if (vnode != null)
            {
                var inodes = vnode.SelectNodes("Item");
                if (inodes?.Count > 0)
                {
                    var nlist = new List<MetaHash>();
                    var vlist = new List<float>();
                    foreach (XmlNode inode in inodes)
                    {
                        nlist.Add(XmlRel.GetHash(Xml.GetStringAttribute(inode, "name")));
                        vlist.Add(Xml.GetFloatAttribute(inode, "value"));
                    }
                    VariationsCount = (byte)nlist.Count;
                    ChildSoundsHashes = nlist.ToArray();
                    VariationsValues = vlist.ToArray();
                }
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "HistoryIndex", HistoryIndex.ToString());
            RelXml.WriteRawArray(sb, HistorySpace, indent, "HistorySpace", "", RelXml.FormatHexByte, 16);
            if (VariationsCount > 0)
            {
                RelXml.OpenTag(sb, indent, "Variations");
                var cind = indent + 1;
                for (int i = 0; i < VariationsCount; i++)
                {
                    var iname = RelXml.HashString(ChildSoundsHashes[i]);
                    var ival = FloatUtil.ToString(VariationsValues[i]);
                    RelXml.SelfClosingTag(sb, cind, "Item name=\"" + iname + "\" value=\"" + ival + "\"");
                }
                RelXml.CloseTag(sb, indent, "Variations");
            }
            else
            {
                RelXml.SelfClosingTag(sb, indent, "Variations");
            }
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(HistoryIndex);
            bw.Write(HistorySpaceCount);
            bw.Write(HistorySpace);
            bw.Write(VariationsCount);
            for (int i = 0; i < VariationsCount; i++)
            {
                bw.Write(ChildSoundsHashes[i]);
                bw.Write(VariationsValues[i]);
            }
        }
        public override uint[] GetHashTableOffsets()
        {
            var offset = 3u + HistorySpaceCount;
            var offsets = new List<uint>();
            for (uint i = 0; i < VariationsCount; i++)
            {
                offsets.Add(offset + i * 8);
            }
            return offsets.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54EnvironmentSound : Dat54Sound
    {
        public byte ChannelID { get; set; }

        public Dat54EnvironmentSound(RelFile rel) : base(rel, Dat54SoundType.EnvironmentSound)
        { }
        public Dat54EnvironmentSound(RelData d, BinaryReader br) : base(d, br)
        {
            ChannelID = br.ReadByte();
            if (br.BaseStream.Position < br.BaseStream.Length)
            { }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ChannelID = (byte)Xml.GetChildUIntAttribute(node, "ChannelID", "value");
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "ChannelID", ChannelID.ToString());
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(ChannelID);
        }
    }

    [TC(typeof(EXP))]
    public class Dat54DynamicEntitySound : Dat54Sound
    {
        public byte EntitiesCount { get; set; }
        public MetaHash[] Entities { get; set; }

        public Dat54DynamicEntitySound(RelFile rel) : base(rel, Dat54SoundType.DynamicEntitySound)
        { }
        public Dat54DynamicEntitySound(RelData d, BinaryReader br) : base(d, br)
        {
            EntitiesCount = br.ReadByte();
            Entities = new MetaHash[EntitiesCount];
            for (int i = 0; i < EntitiesCount; i++)
            {
                Entities[i] = br.ReadUInt32();
            }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            Entities = XmlRel.ReadHashItemArray(node, "Entities");
            EntitiesCount = (byte)(Entities?.Length ?? 0);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.WriteHashItemArray(sb, Entities, indent, "Entities");
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(EntitiesCount);
            for (int i = 0; i < EntitiesCount; i++)
            {
                bw.Write(Entities[i]);
            }
        }
    }

    [TC(typeof(EXP))]
    public class Dat54SequentialOverlapSound : Dat54Sound
    {
        public ushort DelayTime { get; set; }
        public MetaHash DelayTimeVariable { get; set; } //0x2-0x6
        public MetaHash SequenceDirection { get; set; } //0x6-0xA

        public Dat54SequentialOverlapSound(RelFile rel) : base(rel, Dat54SoundType.SequentialOverlapSound)
        { }
        public Dat54SequentialOverlapSound(RelData d, BinaryReader br) : base(d, br)
        {
            DelayTime = br.ReadUInt16();
            DelayTimeVariable = br.ReadUInt32();
            SequenceDirection = br.ReadUInt32();

            ReadChildSoundsHashes(br);
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            DelayTime = (ushort)Xml.GetChildUIntAttribute(node, "DelayTime", "value");
            DelayTimeVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "DelayTimeVariable"));
            SequenceDirection = XmlRel.GetHash(Xml.GetChildInnerText(node, "SequenceDirection"));

            ReadChildSoundsXml(node);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "DelayTime", DelayTime.ToString());
            RelXml.StringTag(sb, indent, "DelayTimeVariable", RelXml.HashString(DelayTimeVariable));
            RelXml.StringTag(sb, indent, "SequenceDirection", RelXml.HashString(SequenceDirection));

            WriteChildSoundsXml(sb, indent);
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(DelayTime);
            bw.Write(DelayTimeVariable);
            bw.Write(SequenceDirection);
            WriteChildSoundsHashes(bw);
        }
        public override uint[] GetHashTableOffsets()
        {
            return GetChildSoundsHashTableOffsets(10);
        }
    }

    [TC(typeof(EXP))]
    public class Dat54ModularSynthSound : Dat54Sound
    {
        public MetaHash SynthSound { get; set; } //0x0-0x4
        public MetaHash SynthPreset { get; set; } //0x4-0x8
        public float PlaybackTimeLimit { get; set; } //0x8-0xC
        public int VirtualisationMode { get; set; } //0xC-0x10
        public int TrackCount { get; set; }
        public int ExposedVariablesCount { get; set; }
        public Dat54ModularSynthSoundVariable[] ExposedVariables { get; set; } //0x28-..

        public Dat54ModularSynthSound(RelFile rel) : base(rel, Dat54SoundType.ModularSynthSound)
        { }
        public Dat54ModularSynthSound(RelData d, BinaryReader br) : base(d, br)
        {
            SynthSound = br.ReadUInt32(); //0x0-0x4
            SynthPreset = br.ReadUInt32(); //0x4-0x8
            PlaybackTimeLimit = br.ReadSingle(); //0x8-0xC
            VirtualisationMode = br.ReadInt32(); //0xC-0x10
            TrackCount = br.ReadInt32(); //0x10-0x14
            ChildSoundsHashes = new MetaHash[4];
            for (int i = 0; i < 4; i++)
            {
                ChildSoundsHashes[i] = br.ReadUInt32();
            }
            ExposedVariablesCount = br.ReadInt32();
            ExposedVariables = new Dat54ModularSynthSoundVariable[ExposedVariablesCount];
            for (int i = 0; i < ExposedVariablesCount; i++)
            {
                ExposedVariables[i] = new Dat54ModularSynthSoundVariable(br);
            }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            SynthSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SynthSound"));
            SynthPreset = XmlRel.GetHash(Xml.GetChildInnerText(node, "SynthPreset"));
            PlaybackTimeLimit = Xml.GetChildFloatAttribute(node, "PlaybackTimeLimit", "value");
            VirtualisationMode = Xml.GetChildIntAttribute(node, "VirtualisationMode", "value");
            TrackCount = Xml.GetChildIntAttribute(node, "TrackCount", "value");
            ReadChildSoundsXml(node, "EnvironmentSounds");
            ExposedVariables = XmlRel.ReadItemArray<Dat54ModularSynthSoundVariable>(node, "ExposedVariables");
            ExposedVariablesCount = (ExposedVariables?.Length ?? 0);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "SynthSound", RelXml.HashString(SynthSound));
            RelXml.StringTag(sb, indent, "SynthPreset", RelXml.HashString(SynthPreset));
            RelXml.ValueTag(sb, indent, "PlaybackTimeLimit", FloatUtil.ToString(PlaybackTimeLimit));
            RelXml.ValueTag(sb, indent, "VirtualisationMode", VirtualisationMode.ToString());
            RelXml.ValueTag(sb, indent, "TrackCount", TrackCount.ToString());
            WriteChildSoundsXml(sb, indent, "EnvironmentSounds");
            RelXml.WriteItemArray(sb, ExposedVariables, indent, "ExposedVariables");
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(SynthSound); //0x0-0x4
            bw.Write(SynthPreset); //0x4-0x8
            bw.Write(PlaybackTimeLimit); //0x8-0xC
            bw.Write(VirtualisationMode); //0xC-0x10
            bw.Write(TrackCount); //0x10-0x14
            for (int i = 0; i < 4; i++)
            {
                bw.Write(ChildSoundsHashes[i]);
            }
            bw.Write(ExposedVariablesCount);
            for (int i = 0; i < ExposedVariablesCount; i++)
            {
                ExposedVariables[i].Write(bw);
            }
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < 4; i++)
            {
                offsets.Add(20 + i * 4);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetSynthHashes()
        {
            return new[] { SynthSound, SynthPreset };
        }
    }
    [TC(typeof(EXP))]
    public class Dat54ModularSynthSoundVariable : IMetaXmlItem
    {
        public MetaHash VariableName { get; set; }
        public MetaHash ParameterName { get; set; }
        public float Value { get; set; }

        public Dat54ModularSynthSoundVariable()
        { }
        public Dat54ModularSynthSoundVariable(BinaryReader br)
        {
            VariableName = br.ReadUInt32();
            ParameterName = br.ReadUInt32();
            Value = br.ReadSingle();
        }
        public void ReadXml(XmlNode node)
        {
            VariableName = XmlRel.GetHash(Xml.GetChildInnerText(node, "VariableName"));
            ParameterName = XmlRel.GetHash(Xml.GetChildInnerText(node, "ParameterName"));
            Value = Xml.GetChildFloatAttribute(node, "Value", "value");
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "VariableName", RelXml.HashString(VariableName));
            RelXml.StringTag(sb, indent, "ParameterName", RelXml.HashString(ParameterName));
            RelXml.ValueTag(sb, indent, "Value", FloatUtil.ToString(Value));
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(VariableName);
            bw.Write(ParameterName);
            bw.Write(Value);
        }
        public override string ToString()
        {
            return VariableName.ToString() + ": " + ParameterName.ToString() + ": " + FloatUtil.ToString(Value);
        }
    }

    [TC(typeof(EXP))]
    public class Dat54GranularSound : Dat54Sound
    {
        public int WaveSlotIndex { get; set; } //0x0-0x4
        public Dat54GranularSoundFile Channel0 { get; set; }
        public Dat54GranularSoundFile Channel1 { get; set; }
        public Dat54GranularSoundFile Channel2 { get; set; }
        public Dat54GranularSoundFile Channel3 { get; set; }
        public Dat54GranularSoundFile Channel4 { get; set; }
        public Dat54GranularSoundFile Channel5 { get; set; }
        public Dat54GranularSoundData ChannelSettings0 { get; set; } //0x34-0x3C
        public Dat54GranularSoundData ChannelSettings1 { get; set; } //0x3C-0x44
        public Dat54GranularSoundData ChannelSettings2 { get; set; } //0x44-0x4C
        public Dat54GranularSoundData ChannelSettings3 { get; set; } //0x4C-0x54
        public Dat54GranularSoundData ChannelSettings4 { get; set; } //0x54-0x5C
        public Dat54GranularSoundData ChannelSettings5 { get; set; } //0x5C-0x64
        public float LoopRandomisationChangeRate { get; set; } //0x64-0x68
        public float LoopRandomisationPitchFraction { get; set; } //0x68-0x6C
        public short ChannelVolume0 { get; set; } //0x6C-0x6E
        public short ChannelVolume1 { get; set; } //0x6E-0x70
        public short ChannelVolume2 { get; set; } //0x70-0x72
        public short ChannelVolume3 { get; set; } //0x72-0x74
        public short ChannelVolume4 { get; set; } //0x74-0x76
        public short ChannelVolume5 { get; set; } //0x76-0x78
        public MetaHash ParentSound { get; set; } //0x78-0x7C
        public byte GranularClockCount { get; set; } //0x7C-0x7D
        public Vector2[] GranularClock { get; set; } //0x7D-...

        public Dat54GranularSound(RelFile rel) : base(rel, Dat54SoundType.GranularSound)
        { }
        public Dat54GranularSound(RelData d, BinaryReader br) : base(d, br)
        {
            WaveSlotIndex = br.ReadInt32();

            Channel0 = new Dat54GranularSoundFile(br);
            Channel1 = new Dat54GranularSoundFile(br);
            Channel2 = new Dat54GranularSoundFile(br);
            Channel3 = new Dat54GranularSoundFile(br);
            Channel4 = new Dat54GranularSoundFile(br);
            Channel5 = new Dat54GranularSoundFile(br);

            AudioContainers = new[] {
                Channel0.ContainerName,
                Channel1.ContainerName,
                Channel2.ContainerName,
                Channel3.ContainerName,
                Channel4.ContainerName,
                Channel5.ContainerName
            };

            ChannelSettings0 = new Dat54GranularSoundData(br);
            ChannelSettings1 = new Dat54GranularSoundData(br);
            ChannelSettings2 = new Dat54GranularSoundData(br);
            ChannelSettings3 = new Dat54GranularSoundData(br);
            ChannelSettings4 = new Dat54GranularSoundData(br);
            ChannelSettings5 = new Dat54GranularSoundData(br);

            LoopRandomisationChangeRate = br.ReadSingle();
            LoopRandomisationPitchFraction = br.ReadSingle();
            ChannelVolume0 = br.ReadInt16();
            ChannelVolume1 = br.ReadInt16();
            ChannelVolume2 = br.ReadInt16();
            ChannelVolume3 = br.ReadInt16();
            ChannelVolume4 = br.ReadInt16();
            ChannelVolume5 = br.ReadInt16();

            ParentSound = br.ReadUInt32();

            ChildSoundsHashes = new[] { ParentSound };

            GranularClockCount = br.ReadByte();
            GranularClock = new Vector2[GranularClockCount];
            for (int i = 0; i < GranularClockCount; i++)
            {
                GranularClock[i] = new Vector2(br.ReadSingle(), br.ReadSingle());
            }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            WaveSlotIndex = (byte)Xml.GetChildIntAttribute(node, "WaveSlotIndex", "value");
            Channel0 = new Dat54GranularSoundFile(node, "Channel0");
            Channel1 = new Dat54GranularSoundFile(node, "Channel1");
            Channel2 = new Dat54GranularSoundFile(node, "Channel2");
            Channel3 = new Dat54GranularSoundFile(node, "Channel3");
            Channel4 = new Dat54GranularSoundFile(node, "Channel4");
            Channel5 = new Dat54GranularSoundFile(node, "Channel5");
            ChannelSettings0 = new Dat54GranularSoundData(node, "ChannelSettings0");
            ChannelSettings1 = new Dat54GranularSoundData(node, "ChannelSettings1");
            ChannelSettings2 = new Dat54GranularSoundData(node, "ChannelSettings2");
            ChannelSettings3 = new Dat54GranularSoundData(node, "ChannelSettings3");
            ChannelSettings4 = new Dat54GranularSoundData(node, "ChannelSettings4");
            ChannelSettings5 = new Dat54GranularSoundData(node, "ChannelSettings5");
            LoopRandomisationChangeRate = Xml.GetChildFloatAttribute(node, "LoopRandomisationChangeRate", "value");
            LoopRandomisationPitchFraction = Xml.GetChildFloatAttribute(node, "LoopRandomisationPitchFraction", "value");
            ChannelVolume0 = (short)Xml.GetChildIntAttribute(node, "ChannelVolume0", "value");
            ChannelVolume1 = (short)Xml.GetChildIntAttribute(node, "ChannelVolume1", "value");
            ChannelVolume2 = (short)Xml.GetChildIntAttribute(node, "ChannelVolume2", "value");
            ChannelVolume3 = (short)Xml.GetChildIntAttribute(node, "ChannelVolume3", "value");
            ChannelVolume4 = (short)Xml.GetChildIntAttribute(node, "ChannelVolume4", "value");
            ChannelVolume5 = (short)Xml.GetChildIntAttribute(node, "ChannelVolume5", "value");
            ParentSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ParentSound"));
            GranularClock = Xml.GetChildRawVector2Array(node, "GranularClock");
            GranularClockCount = (byte)GranularClock?.Length;
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "WaveSlotIndex", WaveSlotIndex.ToString());
            Channel0.WriteXml(sb, indent, "Channel0");
            Channel1.WriteXml(sb, indent, "Channel1");
            Channel2.WriteXml(sb, indent, "Channel2");
            Channel3.WriteXml(sb, indent, "Channel3");
            Channel4.WriteXml(sb, indent, "Channel4");
            Channel5.WriteXml(sb, indent, "Channel5");
            ChannelSettings0.WriteXml(sb, indent, "ChannelSettings0");
            ChannelSettings1.WriteXml(sb, indent, "ChannelSettings1");
            ChannelSettings2.WriteXml(sb, indent, "ChannelSettings2");
            ChannelSettings3.WriteXml(sb, indent, "ChannelSettings3");
            ChannelSettings4.WriteXml(sb, indent, "ChannelSettings4");
            ChannelSettings5.WriteXml(sb, indent, "ChannelSettings5");
            RelXml.ValueTag(sb, indent, "LoopRandomisationChangeRate", FloatUtil.ToString(LoopRandomisationChangeRate));
            RelXml.ValueTag(sb, indent, "LoopRandomisationPitchFraction", FloatUtil.ToString(LoopRandomisationPitchFraction));
            RelXml.ValueTag(sb, indent, "ChannelVolume0", ChannelVolume0.ToString());
            RelXml.ValueTag(sb, indent, "ChannelVolume1", ChannelVolume1.ToString());
            RelXml.ValueTag(sb, indent, "ChannelVolume2", ChannelVolume2.ToString());
            RelXml.ValueTag(sb, indent, "ChannelVolume3", ChannelVolume3.ToString());
            RelXml.ValueTag(sb, indent, "ChannelVolume4", ChannelVolume4.ToString());
            RelXml.ValueTag(sb, indent, "ChannelVolume5", ChannelVolume5.ToString());
            RelXml.StringTag(sb, indent, "ParentSound", RelXml.HashString(ParentSound));
            RelXml.WriteRawArray(sb, GranularClock, indent, "GranularClock", "", RelXml.FormatVector2, 1);
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);

            bw.Write(WaveSlotIndex);

            Channel0.Write(bw);
            Channel1.Write(bw);
            Channel2.Write(bw);
            Channel3.Write(bw);
            Channel4.Write(bw);
            Channel5.Write(bw);

            ChannelSettings0.Write(bw);
            ChannelSettings1.Write(bw);
            ChannelSettings2.Write(bw);
            ChannelSettings3.Write(bw);
            ChannelSettings4.Write(bw);
            ChannelSettings5.Write(bw);

            bw.Write(LoopRandomisationChangeRate);
            bw.Write(LoopRandomisationPitchFraction);
            bw.Write(ChannelVolume0);
            bw.Write(ChannelVolume1);
            bw.Write(ChannelVolume2);
            bw.Write(ChannelVolume3);
            bw.Write(ChannelVolume4);
            bw.Write(ChannelVolume5);

            bw.Write(ParentSound);

            bw.Write(GranularClockCount);
            for (int i = 0; i < GranularClockCount; i++)
            {
                bw.Write(GranularClock[i].X);
                bw.Write(GranularClock[i].Y);
            }
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 120 };
        }
        public override uint[] GetPackTableOffsets()
        {
            return new uint[] { 4, 12, 20, 28, 36, 44 };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54GranularSoundFile
    {
        public MetaHash ContainerName { get; set; } //0x0-0x4
        public MetaHash FileName { get; set; } //0x4-0x8

        public Dat54GranularSoundFile(XmlNode node, string varName)
        {
            ReadXml(node, varName);
        }
        public Dat54GranularSoundFile(BinaryReader br)
        {
            ContainerName = br.ReadUInt32();
            FileName = br.ReadUInt32();
        }
        public void ReadXml(XmlNode node, string varName)
        {
            var cnode = node.SelectSingleNode(varName);
            ContainerName = XmlRel.GetHash(Xml.GetChildInnerText(cnode, "ContainerName"));
            FileName = XmlRel.GetHash(Xml.GetChildInnerText(cnode, "FileName"));
        }
        public void WriteXml(StringBuilder sb, int indent, string varName)
        {
            var cind = indent + 1;
            RelXml.OpenTag(sb, indent, varName);
            RelXml.StringTag(sb, cind, "ContainerName", RelXml.HashString(ContainerName));
            RelXml.StringTag(sb, cind, "FileName", RelXml.HashString(FileName));
            RelXml.CloseTag(sb, indent, varName);
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(ContainerName);
            bw.Write(FileName);
        }
        public override string ToString()
        {
            return ContainerName.ToString() + ": " + FileName.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54GranularSoundData
    {
        public byte OutputBuffer { get; set; } //0x0-0x1
        public byte GranularClockIndex { get; set; } //0x1-0x2
        public byte StretchToMinPitch { get; set; } //0x2-0x3
        public byte StretchToMaxPitch { get; set; } //0x3-0x4
        public float MaxLoopProportion { get; set; } //0x4-0x8

        public Dat54GranularSoundData(XmlNode node, string varName)
        {
            ReadXml(node, varName);
        }
        public Dat54GranularSoundData(BinaryReader br)
        {
            OutputBuffer = br.ReadByte();
            GranularClockIndex = br.ReadByte();
            StretchToMinPitch = br.ReadByte();
            StretchToMaxPitch = br.ReadByte();
            MaxLoopProportion = br.ReadSingle();
        }
        public void ReadXml(XmlNode node, string varName)
        {
            var cnode = node.SelectSingleNode(varName);
            OutputBuffer = (byte)Xml.GetChildIntAttribute(cnode, "OutputBuffer", "value");
            GranularClockIndex = (byte)Xml.GetChildIntAttribute(cnode, "GranularClockIndex", "value");
            StretchToMinPitch = (byte)Xml.GetChildIntAttribute(cnode, "StretchToMinPitch", "value");
            StretchToMaxPitch = (byte)Xml.GetChildIntAttribute(cnode, "StretchToMaxPitch", "value");
            MaxLoopProportion = Xml.GetChildFloatAttribute(cnode, "MaxLoopProportion", "value");
        }
        public void WriteXml(StringBuilder sb, int indent, string varName)
        {
            var cind = indent + 1;
            RelXml.OpenTag(sb, indent, varName);
            RelXml.ValueTag(sb, cind, "OutputBuffer", OutputBuffer.ToString());
            RelXml.ValueTag(sb, cind, "GranularClockIndex", GranularClockIndex.ToString());
            RelXml.ValueTag(sb, cind, "StretchToMinPitch", StretchToMinPitch.ToString());
            RelXml.ValueTag(sb, cind, "StretchToMaxPitch", StretchToMaxPitch.ToString());
            RelXml.ValueTag(sb, cind, "MaxLoopProportion", FloatUtil.ToString(MaxLoopProportion));
            RelXml.CloseTag(sb, indent, varName);
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(OutputBuffer);
            bw.Write(GranularClockIndex);
            bw.Write(StretchToMinPitch);
            bw.Write(StretchToMaxPitch);
            bw.Write(MaxLoopProportion);
        }
        public override string ToString()
        {
            return OutputBuffer.ToString() + ": " + GranularClockIndex.ToString() + ": " + StretchToMinPitch.ToString() + ": " + StretchToMaxPitch.ToString() + ": " + FloatUtil.ToString(MaxLoopProportion);
        }
    }

    [TC(typeof(EXP))]
    public class Dat54DirectionalSound : Dat54Sound
    {
        public MetaHash ChildSound { get; set; }
        public float InnerAngle { get; set; } //0x4-0x8
        public float OuterAngle { get; set; } //0x8-0xC
        public float RearAttenuation { get; set; } //0xC-0x10
        public float YawAngle { get; set; } //0x10-0x14
        public float PitchAngle { get; set; } //0x14-0x18

        public Dat54DirectionalSound(RelFile rel) : base(rel, Dat54SoundType.DirectionalSound)
        { }
        public Dat54DirectionalSound(RelData d, BinaryReader br) : base(d, br)
        {
            ChildSound = br.ReadUInt32();
            ChildSoundsHashes = new[] { ChildSound };
            InnerAngle = br.ReadSingle();
            OuterAngle = br.ReadSingle();
            RearAttenuation = br.ReadSingle();
            YawAngle = br.ReadSingle();
            PitchAngle = br.ReadSingle();
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
            InnerAngle = Xml.GetChildFloatAttribute(node, "InnerAngle", "value");
            OuterAngle = Xml.GetChildFloatAttribute(node, "OuterAngle", "value");
            RearAttenuation = Xml.GetChildFloatAttribute(node, "RearAttenuation", "value");
            YawAngle = Xml.GetChildFloatAttribute(node, "YawAngle", "value");
            PitchAngle = Xml.GetChildFloatAttribute(node, "PitchAngle", "value");
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
            RelXml.ValueTag(sb, indent, "InnerAngle", FloatUtil.ToString(InnerAngle));
            RelXml.ValueTag(sb, indent, "OuterAngle", FloatUtil.ToString(OuterAngle));
            RelXml.ValueTag(sb, indent, "RearAttenuation", FloatUtil.ToString(RearAttenuation));
            RelXml.ValueTag(sb, indent, "YawAngle", FloatUtil.ToString(YawAngle));
            RelXml.ValueTag(sb, indent, "PitchAngle", FloatUtil.ToString(PitchAngle));
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(ChildSound);
            bw.Write(InnerAngle);
            bw.Write(OuterAngle);
            bw.Write(RearAttenuation);
            bw.Write(YawAngle);
            bw.Write(PitchAngle);
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0 };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54KineticSound : Dat54Sound
    {
        public MetaHash ChildSound { get; set; }
        public float Mass { get; set; } //according to GDC presentation
        public float YawAngle { get; set; } //according to GDC presentation
        public float PitchAngle { get; set; } //according to GDC presentation

        public Dat54KineticSound(RelFile rel) : base(rel, Dat54SoundType.KineticSound)
        { }
        public Dat54KineticSound(RelData d, BinaryReader br) : base(d, br)
        {
            ChildSound = br.ReadUInt32();
            ChildSoundsHashes = new[] { ChildSound };
            Mass = br.ReadSingle();
            YawAngle = br.ReadSingle();
            PitchAngle = br.ReadSingle();
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
            Mass = Xml.GetChildFloatAttribute(node, "Mass", "value");
            YawAngle = Xml.GetChildFloatAttribute(node, "YawAngle", "value");
            PitchAngle = Xml.GetChildFloatAttribute(node, "PitchAngle", "value");
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
            RelXml.ValueTag(sb, indent, "Mass", FloatUtil.ToString(Mass));
            RelXml.ValueTag(sb, indent, "YawAngle", FloatUtil.ToString(YawAngle));
            RelXml.ValueTag(sb, indent, "PitchAngle", FloatUtil.ToString(PitchAngle));
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(ChildSound);
            bw.Write(Mass);
            bw.Write(YawAngle);
            bw.Write(PitchAngle);
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0 };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54SwitchSound : Dat54Sound
    {
        public MetaHash Variable { get; set; } //0x0-0x4

        public Dat54SwitchSound(RelFile rel) : base(rel, Dat54SoundType.SwitchSound)
        { }
        public Dat54SwitchSound(RelData d, BinaryReader br) : base(d, br)
        {
            Variable = br.ReadUInt32();

            ReadChildSoundsHashes(br);
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            Variable = XmlRel.GetHash(Xml.GetChildInnerText(node, "Variable"));
            ReadChildSoundsXml(node);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "Variable", RelXml.HashString(Variable));
            WriteChildSoundsXml(sb, indent);
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(Variable);
            WriteChildSoundsHashes(bw);
        }
        public override uint[] GetHashTableOffsets()
        {
            return GetChildSoundsHashTableOffsets(4);
        }
    }

    [TC(typeof(EXP))]
    public class Dat54VariableCurveSound : Dat54Sound
    {
        public MetaHash ChildSound { get; set; }
        public MetaHash InputVariable { get; set; } //0x4-0x8
        public MetaHash OutputVariable { get; set; } //0x8-0xC
        public MetaHash Curve { get; set; } //0xC-0x10

        public Dat54VariableCurveSound(RelFile rel) : base(rel, Dat54SoundType.VariableCurveSound)
        { }
        public Dat54VariableCurveSound(RelData d, BinaryReader br) : base(d, br)
        {
            ChildSound = br.ReadUInt32();
            ChildSoundsHashes = new[] { ChildSound };
            InputVariable = br.ReadUInt32();
            OutputVariable = br.ReadUInt32();
            Curve = br.ReadUInt32();
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
            InputVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "InputVariable"));
            OutputVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "OutputVariable"));
            Curve = XmlRel.GetHash(Xml.GetChildInnerText(node, "Curve"));
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
            RelXml.StringTag(sb, indent, "InputVariable", RelXml.HashString(InputVariable));
            RelXml.StringTag(sb, indent, "OutputVariable", RelXml.HashString(OutputVariable));
            RelXml.StringTag(sb, indent, "Curve", RelXml.HashString(Curve));
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(ChildSound);
            bw.Write(InputVariable);
            bw.Write(OutputVariable);
            bw.Write(Curve);
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0 };
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { Curve };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54VariablePrintValueSound : Dat54Sound
    {
        public MetaHash Variable { get; set; } //0x0-0x4
        public string Value { get; set; }

        public Dat54VariablePrintValueSound(RelFile rel) : base(rel, Dat54SoundType.VariablePrintValueSound)
        { }
        public Dat54VariablePrintValueSound(RelData d, BinaryReader br) : base(d, br)
        {
            Variable = br.ReadUInt32();
            Value = br.ReadString();
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            Variable = XmlRel.GetHash(Xml.GetChildInnerText(node, "Variable"));
            Value = Xml.GetChildInnerText(node, "Value");
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "Variable", RelXml.HashString(Variable));
            RelXml.StringTag(sb, indent, "Value", Value);
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(Variable);
            bw.Write(Value);
        }
    }

    [TC(typeof(EXP))]
    public class Dat54VariableBlockSound : Dat54Sound
    {
        public MetaHash ChildSound { get; set; }
        public byte VariableCount { get; set; }
        public Dat54VariableData[] Variables { get; set; }

        public Dat54VariableBlockSound(RelFile rel) : base(rel, Dat54SoundType.VariableBlockSound)
        { }
        public Dat54VariableBlockSound(RelData d, BinaryReader br) : base(d, br)
        {
            ChildSound = br.ReadUInt32();
            ChildSoundsHashes = new[] { ChildSound };
            VariableCount = br.ReadByte();
            Variables = new Dat54VariableData[VariableCount];
            for (int i = 0; i < VariableCount; i++)
            {
                Variables[i] = new Dat54VariableData(br);
            }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
            Variables = XmlRel.ReadItemArray<Dat54VariableData>(node, "Variables");
            VariableCount = (byte)(Variables?.Length ?? 0);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
            RelXml.WriteItemArray(sb, Variables, indent, "Variables");
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(ChildSound);
            bw.Write(VariableCount);
            for (int i = 0; i < VariableCount; i++)
            {
                Variables[i].Write(bw);
            }
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0 };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54VariableData : IMetaXmlItem
    {
        public MetaHash Name { get; set; }
        public float Value { get; set; } //the value this variable is set to.
        public float ValueVariance { get; set; } //variance of the value
        public byte VariableType { get; set; } //type of variable... sound, code, constant

        public Dat54VariableData()
        { }
        public Dat54VariableData(BinaryReader br)
        {
            Name = br.ReadUInt32();
            Value = br.ReadSingle();
            ValueVariance = br.ReadSingle();
            VariableType = br.ReadByte();
        }
        public void ReadXml(XmlNode node)
        {
            Name = XmlRel.GetHash(Xml.GetChildInnerText(node, "Name"));
            Value = Xml.GetChildFloatAttribute(node, "Value", "value");
            ValueVariance = Xml.GetChildFloatAttribute(node, "ValueVariance", "value");
            VariableType = (byte)Xml.GetChildIntAttribute(node, "VariableType", "value");
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Name", RelXml.HashString(Name));
            RelXml.ValueTag(sb, indent, "Value", FloatUtil.ToString(Value));
            RelXml.ValueTag(sb, indent, "ValueVariance", FloatUtil.ToString(ValueVariance));
            RelXml.ValueTag(sb, indent, "VariableType", VariableType.ToString());
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Name);
            bw.Write(Value);
            bw.Write(ValueVariance);
            bw.Write(VariableType);
        }
        public override string ToString()
        {
            return Name + ": " + FloatUtil.ToString(Value) + ": " + FloatUtil.ToString(ValueVariance) + ": " + VariableType.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54IfSound : Dat54Sound
    {
        public MetaHash TrueSound { get; set; } //sound played if the condition is true
        public MetaHash FalseSound { get; set; } //sound played if the condition is false/invalid
        public MetaHash ConditionVariable { get; set; } //the parameter used to make the choise
        public byte ConditionType { get; set; } //equal to, less than, greater than, etc...
        public float ConditionValue { get; set; } //the value its comparing the parameter to.
        public MetaHash RHS { get; set; } //right hand side, fallback

        public Dat54IfSound(RelFile rel) : base(rel, Dat54SoundType.IfSound)
        { }
        public Dat54IfSound(RelData d, BinaryReader br) : base(d, br)
        {
            TrueSound = br.ReadUInt32();
            FalseSound = br.ReadUInt32();
            ChildSoundsHashes = new[] { TrueSound, FalseSound };
            ConditionVariable = br.ReadUInt32();
            ConditionType = br.ReadByte();
            ConditionValue = br.ReadSingle();
            RHS = br.ReadUInt32();
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            TrueSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "TrueSound"));
            FalseSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "FalseSound"));
            ConditionVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "ConditionVariable"));
            ConditionType = (byte)Xml.GetChildIntAttribute(node, "ConditionType", "value");
            ConditionValue = Xml.GetChildFloatAttribute(node, "ConditionValue", "value");
            RHS = XmlRel.GetHash(Xml.GetChildInnerText(node, "RHS"));
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "TrueSound", RelXml.HashString(TrueSound));
            RelXml.StringTag(sb, indent, "FalseSound", RelXml.HashString(FalseSound));
            RelXml.StringTag(sb, indent, "ConditionVariable", RelXml.HashString(ConditionVariable));
            RelXml.ValueTag(sb, indent, "ConditionType", ConditionType.ToString());
            RelXml.ValueTag(sb, indent, "ConditionValue", FloatUtil.ToString(ConditionValue));
            RelXml.StringTag(sb, indent, "RHS", RelXml.HashString(RHS));
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(TrueSound);
            bw.Write(FalseSound);
            bw.Write(ConditionVariable);
            bw.Write(ConditionType);
            bw.Write(ConditionValue);
            bw.Write(RHS);
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0, 4 };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54MathOperationSound : Dat54Sound
    {
        public MetaHash ChildSound { get; set; }
        public byte OperationsCount { get; set; }
        public Dat54MathOperationSoundData[] Operations { get; set; }

        public Dat54MathOperationSound(RelFile rel) : base(rel, Dat54SoundType.MathOperationSound)
        { }
        public Dat54MathOperationSound(RelData d, BinaryReader br) : base(d, br)
        {
            ChildSound = br.ReadUInt32();
            ChildSoundsHashes = new[] { ChildSound };
            OperationsCount = br.ReadByte();
            Operations = new Dat54MathOperationSoundData[OperationsCount];
            for (int i = 0; i < OperationsCount; i++)
            {
                Operations[i] = new Dat54MathOperationSoundData(br);
            }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
            Operations = XmlRel.ReadItemArray<Dat54MathOperationSoundData>(node, "Operations");
            OperationsCount = (byte)(Operations?.Length ?? 0);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
            RelXml.WriteItemArray(sb, Operations, indent, "Operations");
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(ChildSound);
            bw.Write(OperationsCount);
            for (int i = 0; i < OperationsCount; i++)
            {
                Operations[i].Write(bw);
            }
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0 };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54MathOperationSoundData : IMetaXmlItem
    {
        public byte OperationType { get; set; } //0x0-0x1
        public float InputImmediate1 { get; set; } //0x1-0x5
        public MetaHash InputParameter1 { get; set; } //0x5-0x9
        public float InputImmediate2 { get; set; } //0x9-0xD
        public MetaHash InputParameter2 { get; set; } //0xD-0x11
        public float InputImmediate3 { get; set; } //0x11-0x15
        public MetaHash InputParameter3 { get; set; } //0x15-0x19
        public MetaHash OutputParameter { get; set; } //0x19-0x1D

        public Dat54MathOperationSoundData()
        { }
        public Dat54MathOperationSoundData(BinaryReader br)
        {
            OperationType = br.ReadByte();
            InputImmediate1 = br.ReadSingle();
            InputParameter1 = br.ReadUInt32();
            InputImmediate2 = br.ReadSingle();
            InputParameter2 = br.ReadUInt32();
            InputImmediate3 = br.ReadSingle();
            InputParameter3 = br.ReadUInt32();
            OutputParameter = br.ReadUInt32();
        }
        public void ReadXml(XmlNode node)
        {
            OperationType = (byte)Xml.GetChildIntAttribute(node, "OperationType", "value");
            InputImmediate1 = Xml.GetChildFloatAttribute(node, "InputImmediate1", "value");
            InputParameter1 = XmlRel.GetHash(Xml.GetChildInnerText(node, "InputParameter1"));
            InputImmediate2 = Xml.GetChildFloatAttribute(node, "InputImmediate2", "value");
            InputParameter2 = XmlRel.GetHash(Xml.GetChildInnerText(node, "InputParameter2"));
            InputImmediate3 = Xml.GetChildFloatAttribute(node, "InputImmediate3", "value");
            InputParameter3 = XmlRel.GetHash(Xml.GetChildInnerText(node, "InputParameter3"));
            OutputParameter = XmlRel.GetHash(Xml.GetChildInnerText(node, "OutputParameter"));
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "OperationType", OperationType.ToString());
            RelXml.ValueTag(sb, indent, "InputImmediate1", FloatUtil.ToString(InputImmediate1));
            RelXml.StringTag(sb, indent, "InputParameter1", RelXml.HashString(InputParameter1));
            RelXml.ValueTag(sb, indent, "InputImmediate2", FloatUtil.ToString(InputImmediate2));
            RelXml.StringTag(sb, indent, "InputParameter2", RelXml.HashString(InputParameter2));
            RelXml.ValueTag(sb, indent, "InputImmediate3", FloatUtil.ToString(InputImmediate3));
            RelXml.StringTag(sb, indent, "InputParameter3", RelXml.HashString(InputParameter3));
            RelXml.StringTag(sb, indent, "OutputParameter", RelXml.HashString(OutputParameter));
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(OperationType);
            bw.Write(InputImmediate1);
            bw.Write(InputParameter1);
            bw.Write(InputImmediate2);
            bw.Write(InputParameter2);
            bw.Write(InputImmediate3);
            bw.Write(InputParameter3);
            bw.Write(OutputParameter);
        }
        public override string ToString()
        {
            return InputParameter3.ToString() + ", " + OutputParameter.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54ParameterTransformSound : Dat54Sound
    {
        public MetaHash ChildSound { get; set; }
        public int ParameterTransformsCount { get; set; }
        public Dat54ParameterTransformSoundData[] ParameterTransforms { get; set; }

        public Dat54ParameterTransformSound(RelFile rel) : base(rel, Dat54SoundType.ParameterTransformSound)
        { }
        public Dat54ParameterTransformSound(RelData d, BinaryReader br) : base(d, br)
        {
            ChildSound = br.ReadUInt32();
            ChildSoundsHashes = new[] { ChildSound };
            ParameterTransformsCount = br.ReadInt32(); //0x4-0x8
            ParameterTransforms = new Dat54ParameterTransformSoundData[ParameterTransformsCount];
            for (int i = 0; i < ParameterTransformsCount; i++)
            {
                ParameterTransforms[i] = new Dat54ParameterTransformSoundData(br);
            }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
            ParameterTransforms = XmlRel.ReadItemArray<Dat54ParameterTransformSoundData>(node, "ParameterTransforms");
            ParameterTransformsCount = (ParameterTransforms?.Length ?? 0);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
            RelXml.WriteItemArray(sb, ParameterTransforms, indent, "ParameterTransforms");
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(ChildSound);
            bw.Write(ParameterTransformsCount); //0x4-0x8
            for (int i = 0; i < ParameterTransformsCount; i++)
            {
                ParameterTransforms[i].Write(bw);
            }
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0 };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54ParameterTransformSoundData : IMetaXmlItem
    {
        public MetaHash InputParameter { get; set; } //0x0-0x4
        public float InputRangeMin { get; set; } //0x4-0x8
        public float InputRangeMax { get; set; } //0x8-0xC
        public int TransformsCount { get; set; }
        public Dat54ParameterTransformSoundData2[] Transforms { get; set; } //0x10..

        public Dat54ParameterTransformSoundData()
        { }
        public Dat54ParameterTransformSoundData(BinaryReader br)
        {
            InputParameter = br.ReadUInt32();
            InputRangeMin = br.ReadSingle();
            InputRangeMax = br.ReadSingle();
            TransformsCount = br.ReadInt32();
            Transforms = new Dat54ParameterTransformSoundData2[TransformsCount];
            for (int i = 0; i < TransformsCount; i++)
            {
                Transforms[i] = new Dat54ParameterTransformSoundData2(br);
            }
        }
        public void ReadXml(XmlNode node)
        {
            InputParameter = XmlRel.GetHash(Xml.GetChildInnerText(node, "InputParameter"));
            InputRangeMin = Xml.GetChildFloatAttribute(node, "InputRangeMin", "value");
            InputRangeMax = Xml.GetChildFloatAttribute(node, "InputRangeMax", "value");
            Transforms = XmlRel.ReadItemArray<Dat54ParameterTransformSoundData2>(node, "Transforms");
            TransformsCount = Transforms?.Length ?? 0;
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "InputParameter", RelXml.HashString(InputParameter));
            RelXml.ValueTag(sb, indent, "InputRangeMin", FloatUtil.ToString(InputRangeMin));
            RelXml.ValueTag(sb, indent, "InputRangeMax", FloatUtil.ToString(InputRangeMax));
            RelXml.WriteItemArray(sb, Transforms, indent, "Transforms");
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(InputParameter);
            bw.Write(InputRangeMin);
            bw.Write(InputRangeMax);
            bw.Write(TransformsCount);
            for (int i = 0; i < TransformsCount; i++)
            {
                Transforms[i].Write(bw);
            }
        }
        public override string ToString()
        {
            return InputParameter.ToString() + ", " + TransformsCount.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54ParameterTransformSoundData2 : IMetaXmlItem
    {
        public float SmoothRate { get; set; } //0x0-0x4
        public int TransformType { get; set; } //0x4 //type of transform; volume, pitch, etc
        public MetaHash TransformTypeParameter { get; set; } //0x8-0xC //
        public float OutputRangeMin { get; set; } //0xC //output range min, multiplies the range covered by the vectors
        public float OutputRangeMax { get; set; } //0x10-0x14 //output range max, multiplies the range covered by the vectors
        public int VectorCount { get; set; }
        public Vector2[] Vectors { get; set; } //0x18-... //vector graph

        public Dat54ParameterTransformSoundData2()
        { }
        public Dat54ParameterTransformSoundData2(BinaryReader br)
        {
            SmoothRate = br.ReadSingle();
            TransformType = br.ReadInt32();
            TransformTypeParameter = br.ReadUInt32();
            OutputRangeMin = br.ReadSingle();
            OutputRangeMax = br.ReadSingle();
            VectorCount = br.ReadInt32();
            Vectors = new Vector2[VectorCount];
            for (int i = 0; i < VectorCount; i++)
            {
                Vectors[i] = new Vector2(br.ReadSingle(), br.ReadSingle());
            }
        }
        public void ReadXml(XmlNode node)
        {
            SmoothRate = Xml.GetChildFloatAttribute(node, "SmoothRate", "value");
            TransformType = Xml.GetChildIntAttribute(node, "TransformType", "value");
            TransformTypeParameter = XmlRel.GetHash(Xml.GetChildInnerText(node, "TransformTypeParameter"));
            OutputRangeMin = Xml.GetChildFloatAttribute(node, "OutputRangeMin", "value");
            OutputRangeMax = Xml.GetChildFloatAttribute(node, "OutputRangeMax", "value");
            Vectors = Xml.GetChildRawVector2Array(node, "Vectors");
            VectorCount = Vectors?.Length ?? 0;
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "SmoothRate", FloatUtil.ToString(SmoothRate));
            RelXml.ValueTag(sb, indent, "TransformType", TransformType.ToString());
            RelXml.StringTag(sb, indent, "TransformTypeParameter", RelXml.HashString(TransformTypeParameter));
            RelXml.ValueTag(sb, indent, "OutputRangeMin", FloatUtil.ToString(OutputRangeMin));
            RelXml.ValueTag(sb, indent, "OutputRangeMax", FloatUtil.ToString(OutputRangeMax));
            RelXml.WriteRawArray(sb, Vectors, indent, "Vectors", "", RelXml.FormatVector2, 1);
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(SmoothRate);
            bw.Write(TransformType);
            bw.Write(TransformTypeParameter);
            bw.Write(OutputRangeMin);
            bw.Write(OutputRangeMax);
            bw.Write(VectorCount);
            for (int i = 0; i < VectorCount; i++)
            {
                bw.Write(Vectors[i].X);
                bw.Write(Vectors[i].Y);
            }
        }
        public override string ToString()
        {
            return TransformTypeParameter.ToString() + ", " + VectorCount.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54FluctuatorSound : Dat54Sound
    {
        public MetaHash ChildSound { get; set; }
        public int FluctuatorsCount { get; set; }
        public Dat54FluctuatorSoundData[] Fluctuators { get; set; }

        public Dat54FluctuatorSound(RelFile rel) : base(rel, Dat54SoundType.FluctuatorSound)
        { }
        public Dat54FluctuatorSound(RelData d, BinaryReader br) : base(d, br)
        {
            ChildSound = br.ReadUInt32();
            ChildSoundsHashes = new[] { ChildSound };
            FluctuatorsCount = br.ReadInt32(); //0x4-0x8
            Fluctuators = new Dat54FluctuatorSoundData[FluctuatorsCount];
            for (int i = 0; i < FluctuatorsCount; i++)
            {
                Fluctuators[i] = new Dat54FluctuatorSoundData(br);
            }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
            Fluctuators = XmlRel.ReadItemArray<Dat54FluctuatorSoundData>(node, "Fluctuators");
            FluctuatorsCount = (Fluctuators?.Length ?? 0);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
            RelXml.WriteItemArray(sb, Fluctuators, indent, "Fluctuators");
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(ChildSound);
            bw.Write(FluctuatorsCount); //0x4-0x8
            for (int i = 0; i < FluctuatorsCount; i++)
            {
                Fluctuators[i].Write(bw);
            }
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0 };
        }
    }

    [TC(typeof(EXP))] public class Dat54FluctuatorSoundData : IMetaXmlItem
    {
        public byte Mode { get; set; } //0x0-0x1 //type of fluctuator; probability-based, time-based
        public byte Destination { get; set; } //0x1-0x2
        public MetaHash OutputVariable { get; set; } //0x2-0x6
        public float IncreaseRate { get; set; } //0x6-0xA
        public float DecreaseRate { get; set; } //0xA-0xE
        public float BandOneMinimum { get; set; } //0xE-0x12
        public float BandOneMaximum { get; set; } //0x12-0x16
        public float BandTwoMinimum { get; set; } //0x16-0x1A
        public float BandTwoMaximum { get; set; } //0x1A-0x1E
        public float IntraBandFlipProbabilty { get; set; } //0x1E-0x22
        public float InterBandFlipProbabilty { get; set; } //0x22-0x26
        public float MinSwitchTime { get; set; } //0x26-0x2A
        public float MaxSwitchTime { get; set; } //0x2A-0x2E
        public float InitialValue { get; set; } //0x2E-0x32

        public Dat54FluctuatorSoundData()
        { }
        public Dat54FluctuatorSoundData(BinaryReader br)
        {
            Mode = br.ReadByte();
            Destination = br.ReadByte();
            OutputVariable = br.ReadUInt32();
            IncreaseRate = br.ReadSingle();
            DecreaseRate = br.ReadSingle();
            BandOneMinimum = br.ReadSingle();
            BandOneMaximum = br.ReadSingle();
            BandTwoMinimum = br.ReadSingle();
            BandTwoMaximum = br.ReadSingle();
            IntraBandFlipProbabilty = br.ReadSingle();
            InterBandFlipProbabilty = br.ReadSingle();
            MinSwitchTime = br.ReadSingle();
            MaxSwitchTime = br.ReadSingle();
            InitialValue = br.ReadSingle();
        }
        public void ReadXml(XmlNode node)
        {
            Mode = (byte)Xml.GetChildIntAttribute(node, "Mode", "value");
            Destination = (byte)Xml.GetChildIntAttribute(node, "Destination", "value");
            OutputVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "OutputVariable"));
            IncreaseRate = Xml.GetChildFloatAttribute(node, "IncreaseRate", "value");
            DecreaseRate = Xml.GetChildFloatAttribute(node, "DecreaseRate", "value");
            BandOneMinimum = Xml.GetChildFloatAttribute(node, "BandOneMinimum", "value");
            BandOneMaximum = Xml.GetChildFloatAttribute(node, "BandOneMaximum", "value");
            BandTwoMinimum = Xml.GetChildFloatAttribute(node, "BandTwoMinimum", "value");
            BandTwoMaximum = Xml.GetChildFloatAttribute(node, "BandTwoMaximum", "value");
            IntraBandFlipProbabilty = Xml.GetChildFloatAttribute(node, "IntraBandFlipProbabilty", "value");
            InterBandFlipProbabilty = Xml.GetChildFloatAttribute(node, "InterBandFlipProbabilty", "value");
            MinSwitchTime = Xml.GetChildFloatAttribute(node, "MinSwitchTime", "value");
            MaxSwitchTime = Xml.GetChildFloatAttribute(node, "MaxSwitchTime", "value");
            InitialValue = Xml.GetChildFloatAttribute(node, "InitialValue", "value");
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Mode", Mode.ToString());
            RelXml.ValueTag(sb, indent, "Destination", Destination.ToString());
            RelXml.StringTag(sb, indent, "OutputVariable", RelXml.HashString(OutputVariable));
            RelXml.ValueTag(sb, indent, "IncreaseRate", FloatUtil.ToString(IncreaseRate));
            RelXml.ValueTag(sb, indent, "DecreaseRate", FloatUtil.ToString(DecreaseRate));
            RelXml.ValueTag(sb, indent, "BandOneMinimum", FloatUtil.ToString(BandOneMinimum));
            RelXml.ValueTag(sb, indent, "BandOneMaximum", FloatUtil.ToString(BandOneMaximum));
            RelXml.ValueTag(sb, indent, "BandTwoMinimum", FloatUtil.ToString(BandTwoMinimum));
            RelXml.ValueTag(sb, indent, "BandTwoMaximum", FloatUtil.ToString(BandTwoMaximum));
            RelXml.ValueTag(sb, indent, "IntraBandFlipProbabilty", FloatUtil.ToString(IntraBandFlipProbabilty));
            RelXml.ValueTag(sb, indent, "InterBandFlipProbabilty", FloatUtil.ToString(InterBandFlipProbabilty));
            RelXml.ValueTag(sb, indent, "MinSwitchTime", FloatUtil.ToString(MinSwitchTime));
            RelXml.ValueTag(sb, indent, "MaxSwitchTime", FloatUtil.ToString(MaxSwitchTime));
            RelXml.ValueTag(sb, indent, "InitialValue", FloatUtil.ToString(InitialValue));
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Mode);
            bw.Write(Destination);
            bw.Write(OutputVariable);
            bw.Write(IncreaseRate);
            bw.Write(DecreaseRate);
            bw.Write(BandOneMinimum);
            bw.Write(BandOneMaximum);
            bw.Write(BandTwoMinimum);
            bw.Write(BandTwoMaximum);
            bw.Write(IntraBandFlipProbabilty);
            bw.Write(InterBandFlipProbabilty);
            bw.Write(MinSwitchTime);
            bw.Write(MaxSwitchTime);
            bw.Write(InitialValue);
        }
        public override string ToString()
        {
            return OutputVariable.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54AutomationSound : Dat54Sound
    {
        public MetaHash FallBackSound { get; set; }  //fallback sound
        public float PlaybackRate { get; set; } //0x4-0x8 //rate at which the midi is played back, 1.0 default
        public float PlaybackRateVariance { get; set; } //0x8-0xC //variance of the playback rate
        public MetaHash PlaybackRateVariable { get; set; } //0xC-0x10 //parameter override for playback rate
        public MetaHash NoteMap { get; set; } //mapping note sounds onto the midi
        public MetaHash ContainerName { get; set; } //0x14-0x18 // file path
        public MetaHash FileName { get; set; } //0x18-0x1C // .mid file name
        public int VariableOutputsCount { get; set; } // array data count 0x1C-0x20
        public Dat54AutomationSoundVariableOutput[] VariableOutputs { get; set; } //0x20-

        public Dat54AutomationSound(RelFile rel) : base(rel, Dat54SoundType.AutomationSound)
        { }
        public Dat54AutomationSound(RelData d, BinaryReader br) : base(d, br)
        {
            FallBackSound = br.ReadUInt32();
            PlaybackRate = br.ReadSingle();
            PlaybackRateVariance = br.ReadSingle();
            PlaybackRateVariable = br.ReadUInt32();
            NoteMap = br.ReadUInt32();
            ChildSoundsHashes = new[] { FallBackSound, NoteMap };
            ContainerName = br.ReadUInt32();
            FileName = br.ReadUInt32();
            VariableOutputsCount = br.ReadInt32();
            VariableOutputs = new Dat54AutomationSoundVariableOutput[VariableOutputsCount];
            for (int i = 0; i < VariableOutputsCount; i++)
            {
                VariableOutputs[i] = new Dat54AutomationSoundVariableOutput(br);
            }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            FallBackSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "FallBackSound"));
            PlaybackRate = Xml.GetChildFloatAttribute(node, "PlaybackRate", "value");
            PlaybackRateVariance = Xml.GetChildFloatAttribute(node, "PlaybackRateVariance", "value");
            PlaybackRateVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "PlaybackRateVariable"));
            NoteMap = XmlRel.GetHash(Xml.GetChildInnerText(node, "NoteMap"));
            ContainerName = XmlRel.GetHash(Xml.GetChildInnerText(node, "ContainerName"));
            FileName = XmlRel.GetHash(Xml.GetChildInnerText(node, "FileName"));
            VariableOutputs = XmlRel.ReadItemArray<Dat54AutomationSoundVariableOutput>(node, "VariableOutputs");
            VariableOutputsCount = (VariableOutputs?.Length ?? 0);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "FallBackSound", RelXml.HashString(FallBackSound));
            RelXml.ValueTag(sb, indent, "PlaybackRate", FloatUtil.ToString(PlaybackRate));
            RelXml.ValueTag(sb, indent, "PlaybackRateVariance", FloatUtil.ToString(PlaybackRateVariance));
            RelXml.StringTag(sb, indent, "PlaybackRateVariable", RelXml.HashString(PlaybackRateVariable));
            RelXml.StringTag(sb, indent, "NoteMap", RelXml.HashString(NoteMap));
            RelXml.StringTag(sb, indent, "ContainerName", RelXml.HashString(ContainerName));
            RelXml.StringTag(sb, indent, "FileName", RelXml.HashString(FileName));
            RelXml.WriteItemArray(sb, VariableOutputs, indent, "VariableOutputs");
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(FallBackSound);
            bw.Write(PlaybackRate);
            bw.Write(PlaybackRateVariance);
            bw.Write(PlaybackRateVariable);
            bw.Write(NoteMap);
            bw.Write(ContainerName);
            bw.Write(FileName);
            bw.Write(VariableOutputsCount);
            for (int i = 0; i < VariableOutputsCount; i++)
            {
                VariableOutputs[i].Write(bw);
            }
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0, 16 };
        }
        public override uint[] GetPackTableOffsets()
        {
            return new uint[] { 20 };
        }
    }

    [TC(typeof(EXP))]
    public class Dat54AutomationSoundVariableOutput : IMetaXmlItem
    {
        public int Channel { get; set; } //0x0-0x1
        public MetaHash Variable { get; set; } //0x2-0x6

        public Dat54AutomationSoundVariableOutput()
        { }
        public Dat54AutomationSoundVariableOutput(BinaryReader br)
        {
            Channel = br.ReadInt32();
            Variable = br.ReadUInt32();
        }
        public void ReadXml(XmlNode node)
        {
            Channel = Xml.GetChildIntAttribute(node, "Channel", "value");
            Variable = XmlRel.GetHash(Xml.GetChildInnerText(node, "Variable"));
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Channel", Channel.ToString());
            RelXml.StringTag(sb, indent, "Variable", RelXml.HashString(Variable));
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Channel);
            bw.Write(Variable);
        }
        public override string ToString()
        {
            return Channel.ToString() + ", " + Variable.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54ExternalStreamSound : Dat54Sound
    {
        public MetaHash EnvironmentSound1 { get; set; }
        public MetaHash EnvironmentSound2 { get; set; }
        public MetaHash EnvironmentSound3 { get; set; }
        public MetaHash EnvironmentSound4 { get; set; }

        public Dat54ExternalStreamSound(RelFile rel) : base(rel, Dat54SoundType.ExternalStreamSound)
        { }
        public Dat54ExternalStreamSound(RelData d, BinaryReader br) : base(d, br)
        {
            ReadChildSoundsHashes(br);

            EnvironmentSound1 = br.ReadUInt32();
            EnvironmentSound2 = br.ReadUInt32();

            if (ChildSoundsCount == 0)
            {
                EnvironmentSound3 = br.ReadUInt32();
                EnvironmentSound4 = br.ReadUInt32();
            }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            ReadChildSoundsXml(node, "EnvironmentSounds");
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            WriteChildSoundsXml(sb, indent, "EnvironmentSounds");
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            WriteChildSoundsHashes(bw);

            bw.Write(EnvironmentSound1);
            bw.Write(EnvironmentSound2);

            if (ChildSoundsCount == 0)
            {
                bw.Write(EnvironmentSound3);
                bw.Write(EnvironmentSound4);
            }

        }
        public override uint[] GetHashTableOffsets()
        {
            var list = GetChildSoundsHashTableOffsets().ToList();
            uint offs = (uint)list.Count * 4 + 1;
            list.Add(offs);// EnvironmentSound1
            list.Add(offs + 4);// EnvironmentSound2
            if (ChildSoundsCount == 0)
            {
                list.Add(offs + 8);// EnvironmentSound3
                list.Add(offs + 12);// EnvironmentSound4
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54SoundSet : Dat54Sound
    {
        public int SoundSetsCount { get; set; }
        public Dat54SoundSetItem[] SoundSets { get; set; }

        public Dat54SoundSet(RelFile rel) : base(rel, Dat54SoundType.SoundSet)
        { }
        public Dat54SoundSet(RelData d, BinaryReader br) : base(d, br)
        {
            SoundSetsCount = br.ReadInt32();
            SoundSets = new Dat54SoundSetItem[SoundSetsCount];
            ChildSoundsHashes = new MetaHash[SoundSetsCount];
            for (int i = 0; i < SoundSetsCount; i++)
            {
                SoundSets[i] = new Dat54SoundSetItem(br);
                ChildSoundsHashes[i] = SoundSets[i].ChildSound;
            }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            SoundSets = XmlRel.ReadItemArray<Dat54SoundSetItem>(node, "SoundSets");
            SoundSetsCount = (SoundSets?.Length ?? 0);

            if (SoundSets != null)
            {
                Array.Sort(SoundSets, (a, b) => a.ScriptName.Hash.CompareTo(b.ScriptName.Hash));
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.WriteItemArray(sb, SoundSets, indent, "SoundSets");
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(SoundSetsCount);
            for (int i = 0; i < SoundSetsCount; i++)
            {
                SoundSets[i].Write(bw);
            }
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < SoundSetsCount; i++)
            {
                offsets.Add(8 + i * 8);
            }
            return offsets.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54SoundSetItem : IMetaXmlItem
    {
        public MetaHash ScriptName { get; set; }
        public MetaHash ChildSound { get; set; }

        public Dat54SoundSetItem()
        { }
        public Dat54SoundSetItem(BinaryReader br)
        {
            ScriptName = br.ReadUInt32();
            ChildSound = br.ReadUInt32();
        }
        public void ReadXml(XmlNode node)
        {
            ScriptName = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScriptName"));
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "ScriptName", RelXml.HashString(ScriptName));
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(ScriptName);
            bw.Write(ChildSound);
        }
        public override string ToString()
        {
            return ScriptName.ToString() + ": " + ChildSound.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54AutomationNoteMapSound : Dat54Sound
    {
        public byte RangesCount { get; set; }
        public Dat54AutomationNoteMapSoundData[] Ranges { get; set; }

        public Dat54AutomationNoteMapSound(RelFile rel) : base(rel, Dat54SoundType.AutomationNoteMapSound)
        { }
        public Dat54AutomationNoteMapSound(RelData d, BinaryReader br) : base(d, br)
        {
            RangesCount = br.ReadByte();
            Ranges = new Dat54AutomationNoteMapSoundData[RangesCount];
            ChildSoundsHashes = new MetaHash[RangesCount];
            for (int i = 0; i < RangesCount; i++)
            {
                Ranges[i] = new Dat54AutomationNoteMapSoundData(br);
                ChildSoundsHashes[i] = Ranges[i].ChildSound;// br.ReadUInt32();
            }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            Ranges = XmlRel.ReadItemArray<Dat54AutomationNoteMapSoundData>(node, "Ranges");
            RangesCount = (byte)(Ranges?.Length ?? 0);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.WriteItemArray(sb, Ranges, indent, "Ranges");
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(RangesCount);
            for (int i = 0; i < RangesCount; i++)
            {
                Ranges[i].Write(bw);
            }
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < RangesCount; i++)
            {
                offsets.Add(4 + i * 7);
            }
            return offsets.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54AutomationNoteMapSoundData : IMetaXmlItem
    {
        public byte FirstNoteID { get; set; }
        public byte LastNoteID { get; set; }
        public byte Mode { get; set; }
        public MetaHash ChildSound { get; set; }

        public Dat54AutomationNoteMapSoundData()
        { }
        public Dat54AutomationNoteMapSoundData(BinaryReader br)
        {
            FirstNoteID = br.ReadByte();
            LastNoteID = br.ReadByte();
            Mode = br.ReadByte();
            ChildSound = br.ReadUInt32();
        }
        public void ReadXml(XmlNode node)
        {
            FirstNoteID = (byte)Xml.GetChildIntAttribute(node, "FirstNoteID", "value");
            LastNoteID = (byte)Xml.GetChildIntAttribute(node, "LastNoteID", "value");
            Mode = (byte)Xml.GetChildIntAttribute(node, "Mode", "value");
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "FirstNoteID", FirstNoteID.ToString());
            RelXml.ValueTag(sb, indent, "LastNoteID", LastNoteID.ToString());
            RelXml.ValueTag(sb, indent, "Mode", Mode.ToString());
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(FirstNoteID);
            bw.Write(LastNoteID);
            bw.Write(Mode);
            bw.Write(ChildSound);
        }
        public override string ToString()
        {
            return FirstNoteID.ToString() + ": " + LastNoteID.ToString() + ": " + Mode.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat54SoundSetList : Dat54Sound
    {
        public uint SoundSetsCount { get; set; }
        public MetaHash[] SoundSets { get; set; }

        public Dat54SoundSetList(RelFile rel) : base(rel, Dat54SoundType.SoundSetList)
        { }
        public Dat54SoundSetList(RelData d, BinaryReader br) : base(d, br)
        {
            SoundSetsCount = br.ReadUInt32();
            SoundSets = new MetaHash[SoundSetsCount];
            for (int i = 0; i < SoundSetsCount; i++)
            {
                SoundSets[i] = br.ReadUInt32();
            }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            SoundSets = XmlRel.ReadHashItemArray(node, "SoundSets");
            SoundSetsCount = (uint)(SoundSets?.Length ?? 0);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.WriteHashItemArray(sb, SoundSets, indent, "SoundSets");
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(SoundSetsCount);
            for (int i = 0; i < SoundSetsCount; i++)
            {
                bw.Write(SoundSets[i]);
            }
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < SoundSetsCount; i++)
            {
                offsets.Add(4 + i * 4);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetSoundHashes()
        {
            return SoundSets;
        }
    }

    [TC(typeof(EXP))]
    public class Dat54SoundHashList : Dat54Sound
    {
        public ushort UnkShort { get; set; }
        public uint SoundHashesCount { get; set; }
        public MetaHash[] SoundHashes { get; set; }

        public Dat54SoundHashList(RelFile rel) : base(rel, Dat54SoundType.SoundHashList)
        { }
        public Dat54SoundHashList(RelData d, BinaryReader br) : base(d, br)
        {
            UnkShort = br.ReadUInt16();
            SoundHashesCount = br.ReadUInt32();
            SoundHashes = new MetaHash[SoundHashesCount];
            for (int i = 0; i < SoundHashesCount; i++)
            {
                SoundHashes[i] = br.ReadUInt32();
            }
            if (br.BaseStream.Position != br.BaseStream.Length)
            { }
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            UnkShort = (ushort)Xml.GetChildUIntAttribute(node, "UnkShort", "value");
            SoundHashes = XmlRel.ReadHashItemArray(node, "SoundHashes");
            SoundHashesCount = (uint)(SoundHashes?.Length ?? 0);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "UnkShort", UnkShort.ToString());
            RelXml.WriteHashItemArray(sb, SoundHashes, indent, "SoundHashes");
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(UnkShort);
            bw.Write(SoundHashesCount);
            for (int i = 0; i < SoundHashesCount; i++)
            {
                bw.Write(SoundHashes[i]);
            }
        }
        public override MetaHash[] GetSoundHashes()
        {
            return SoundHashes;
        }
    }



    #endregion




    #region dat151


    public enum Dat151RelType : byte //not sure how correct these are?
    {
        VehicleCollisionSettings = 1, //only for vehicles, vehicle_collision
        TrailerAudioSettings = 2,
        CarAudioSettings = 3,
        VehicleEngineAudioSettings = 4, //_vehicle_engine
        CollisionMaterialSettings = 5, //am_base
        StaticEmitter = 6, //radio emitters only, se_
        EntityEmitter = 7, //ee_, entity emitters for props such as fans, radars, etc
        HeliAudioSettings = 8,
        MeleeCombatSettings = 9, //melee_combat
        SpeechContextSettings = 10,
        TriggeredSpeechContext = 11, //eg. default_speech_context, provoke, apologise, run, etc. contains reference to SpeechContext
        SpeechContext = 12, //eg. default_speech_context_sc, SpeechChat? SpeechController..? child of TriggeredSpeechContext, Unk13
        SpeechContextVirtual = 13, //eg. greet_virtual_sc (has TriggeredSpeechContext children eg. greeting_evening, morning) - TriggeredSpeechContextVirtual..? also can have SpeechContext children instead
        SpeechParams = 14, //speech_params
        SpeechContextList = 15, //contains a list of TriggeredSpeechContext objects. greetings, insults, reactions, provoke, etc. dlc_btl_nightclub_scl, dlc_btl_nightclub_queue_scl
        BoatAudioSettings = 16, //and submarines
        WeaponSettings = 17,//individual weapons (and _npc weapons)
        ShoeAudioSettings = 18, //footsteps_generic, shoe_, etc.
        ModelPhysicsParams = 22, //player/creature foostep tuning stuff
        SkiAudioSettings = 23, //skis_generic, listed under some CollisionMaterialSettings but obviously unused :(
        RadioStationList = 24, //RadioStationList? repl_music_station_list_03
        RadioStationSettings = 25,//radio_station
        RadioStationTrackList = 26,//exclusively for radio stations, music, ads, idents, etc
        RadioTrackCategoryData = 27, //radio_track_category_ back-to-back timings, sets pre-delay of each radio track.
        ScannerCrimeReport = 28, //crime_throw_grenade_b
        PedRaceToPedVoiceGroup = 29, // Ped Race Ped Voice Group
        PedVoiceGroups = 30, //maybe Ped Ped Voice Group?
        FriendGroup = 31,//ped category? jewish, street, airport, etc
        StaticEmitterList = 32, //contains a list of StaticEmitters used in the world.
        ScriptedScannerLine = 33, // scripted_scanner_report_ etc
        ScannerSpecificLocation = 35,
        ScannerSpecificLocationList = 36,
        AmbientZone = 37, //zones for ambient rules.
        AmbientRule = 38, //ar_, according to GDC conference, an ambient rule contains information on a sound's position relative to the zone.
        AmbientZoneList = 39, //contains a list of AmbientZones used in the world.
        AmbientSlotMap = 40, // ambience_slot_map
        AmbientBankMap = 41, //assigns audio bank containers to the ambience system, ambience_bank_map_autogenerated
        EnvironmentRule = 42, //connected to AmbientZones, something related to nearby props?
        InteriorSettings = 44,
        InteriorWeaponMetrics = 45, //connected to InteriorRooms.
        InteriorRoom = 46,
        DoorAudioSettings = 47,
        DoorTuningParams = 48, //configures door movement settings, _dtp, dlc_h4_dtp_vertical_slide_door
        DoorList = 49, //doors/gates
        ItemAudioSettings = 50,//assigns weapon entries (player, npc, etc) to an audio item entry
        ClimbingAudioSettings = 51, //climbing materials such as wood, chainlink, etc.
        ModelAudioCollisionSettings = 52, //macs_models_override + AudioCollisionSettings archetype extension
        TrainAudioSettings = 53,
        WeatherAudioSettings = 54, //connected to WeatherTypeAudioReference
        WeatherTypeAudioReference = 55, //only one in the entire game.dat, named weathertypelist. (most child names found in weather.xml)
        BicycleAudioSettings = 56,
        PlaneAudioSettings = 57,
        StemMix = 59, //StemMix, defines the 8-stem stereo mix used for the score, prefixed sm_. child of moods.
        InteractiveMusicMood = 62,//_md, moods define transitions and stem behavior of scores.
        StartTrackAction = 63,
        StopTrackAction = 64,
        SetMoodAction = 65,
        MusicEvent = 66, // me_
        StartOneShotAction = 67,
        StopOneShotAction = 68,
        BeatConstraint = 69, // SetMoodBeat? suffixed _beat. 
        BarConstraint = 70, // something about bars.
        DirectionalAmbience = 71, //prefixed da_, connected to AmbientZone's external parameters (usually crickets/other animals, day/night?)
        GunfightConductorIntensitySettings = 72,//collision/bullet impacts?
        AnimalParams = 73,
        AnimalVocalAnimTrigger = 74,//animal sounds - links to speech.dat somehow?
        ScannerVoiceParams = 75, //ScannerVoiceParams ? contains all police scanner colours and prefixes for vehicles
        ScannerVehicleParams = 76, // _scanner_params
        AudioRoadInfo = 77,
        MicrophoneSettingsReference = 78,
        MicrophoneSettings = 79, //Microphone? _mic
        CarRecordingAudioSettings = 80, //vehicle recording audio (YVR)
        CarRecordingList = 81,//list of CarRecordings
        AnimalFootstepSettings = 82, //af_, animal footsteps on collision materials
        AnimalFootstepReference = 83, //list of AnimalFootstepSettings sounds per collision material
        ShoeList = 84, //contains a list of Shoe objects
        ClothAudioSettings = 85, //Cloth, clothing items, bags, etc.
        ClothList = 86, //ClothList, all sorts of clothing stuff, bags, rappel gear, parachute gear, pants, shorts, etc. references ClothAudioSettings
        ExplosionAudioSettings = 87,
        GranularEngineAudioSettings = 88, //granular engine system, _granular_engine
        ShoreLinePoolAudioSettings = 90,
        ShoreLineLakeAudioSettings = 91,
        ShoreLineRiverAudioSettings = 92,
        ShoreLineOceanAudioSettings = 93,
        ShoreLineList = 94,
        RadioTrackSettings = 95, //_rts, _radio_settings - sets a specific radio track
        ModelFootStepTuning = 96, //player_one_tuning_values, good_stealth, bad_stealth, etc
        RadioDJSpeechAction = 98,
        SilenceConstraint = 99,
        ReflectionsSettings = 100, //tunnels_in/out
        AlarmSettings = 101,
        FadeOutRadioAction = 102,
        FadeInRadioAction = 103,
        ForceRadioTrackAction = 104, //suffixed _frta
        SlowMoSettings = 105, //SlowMotion settings for weapons, jumps, other slow squences etc.
        PedScenarioAudioSettings = 106, //eg world_human_musician
        PortalSettings = 107, //world changes, broken window vs fixed windows at certain interiors (Michael's house, car showroom, etc)
        ElectricEngineAudioSettings = 108,  //voltic_electric_engine
        PlayerBreathingSettings = 109, //bike_breath_settings, run_breath_settings
        PedWallaSpeechSettings = 110, //ped walla speech
        AircraftWarningSettings = 111,
        PedWallaSpeechSettingsList = 112, //conversation/speech related? contains refs to PedWallaSpeechSettings
        CopDispatchInteractionSettings = 113, //cop_dispatch_interaction_settings
        RadioTrackTextIDs = 114, //suffixed rtt and rtb, contains list of Events from radio song's awc.
        RandomisedRadioEmitterSettings = 115,//links to StaticEmitters
        TennisVocalizationSettings = 116,//tennis_vfx_settings
        DoorAudioSettingsLink = 117, //assigns door models to Door entriees. prefixed dasl_ followed by hash of door model.
        SportsCarRevsSettings = 118,
        FoliageSettings = 119, //_foliage, prop_bush_lrg_02 - tree sounds
        ReplayRadioStationTrackList = 120, //_tracklist - its like a radio system, but for non-radio sounds (r* editor sounds and stuff)
        ModelAudioCollisionSettingsOverrideList = 121, //macs = modelaudiocollisionsettings (stems from Dat151ModelAudioCollisionSettings)
        GameObjectHashList = 124, // radio override something?
    }

    [TC(typeof(EXP))] 
    public class Dat151RelData : RelData
    {
        public Dat151RelType Type { get; set; }
        public uint NameTableOffset { get; set; }

        public Dat151RelData(RelFile rel) : base(rel) { }
        public Dat151RelData(RelFile rel, Dat151RelType type) : base(rel)
        {
            Type = type;
            TypeID = (byte)type;
        }
        public Dat151RelData(RelData d, BinaryReader br) : base(d)
        {
            Type = (Dat151RelType)TypeID;

            br.BaseStream.Position = 0; //1 byte was read already (TypeID)

            NameTableOffset = ((br.ReadUInt32() >> 8) & 0xFFFFFF);
        }


        public void WriteTypeAndOffset(BinaryWriter bw)
        {
            var val = ((NameTableOffset & 0xFFFFFF) << 8) + TypeID;
            bw.Write(val);
        }


        public override string ToString()
        {
            return GetBaseString() + ": " + Type.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public struct Dat151HashPair : IMetaXmlItem
    {
        public MetaHash Context { get; set; }
        public MetaHash SoundRef { get; set; }

        public Dat151HashPair(BinaryReader br)
        {
            Context = br.ReadUInt32();
            SoundRef = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Context);
            bw.Write(SoundRef);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Context", RelXml.HashString(Context));
            RelXml.StringTag(sb, indent, "SoundRef", RelXml.HashString(SoundRef));
        }
        public void ReadXml(XmlNode node)
        {
            Context = XmlRel.GetHash(Xml.GetChildInnerText(node, "Context"));
            SoundRef = XmlRel.GetHash(Xml.GetChildInnerText(node, "SoundRef"));
        }
        public override string ToString()
        {
            return Context.ToString() + ": " + SoundRef.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public struct Dat151HashFloat : IMetaXmlItem
    {
        public MetaHash Hash { get; set; }
        public float Value { get; set; }

        public Dat151HashFloat(BinaryReader br)
        {
            Hash = br.ReadUInt32();
            Value = br.ReadSingle();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Hash);
            bw.Write(Value);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Hash", RelXml.HashString(Hash));
            RelXml.ValueTag(sb, indent, "Value", FloatUtil.ToString(Value));
        }
        public void ReadXml(XmlNode node)
        {
            Hash = XmlRel.GetHash(Xml.GetChildInnerText(node, "Hash"));
            Value = Xml.GetChildFloatAttribute(node, "Value", "value");
        }
        public override string ToString()
        {
            return Hash.ToString() + ": " + Value.ToString();
        }
    }


    public enum Dat151ZoneShape : byte
    {
        Box = 0,
        Sphere = 1,
        Line = 2,
    }

    [TC(typeof(EXP))] 
    public class Dat151StaticEmitterList: Dat151RelData
    {
        public uint EmitterCount { get; set; }
        public MetaHash[] EmitterHashes { get; set; }

        public Dat151StaticEmitterList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.StaticEmitterList;
            TypeID = (byte)Type;
        }
        public Dat151StaticEmitterList(RelData d, BinaryReader br) : base(d, br)
        {
            EmitterCount = br.ReadUInt32();
            EmitterHashes = new MetaHash[EmitterCount];
            for (int i = 0; i < EmitterCount; i++)
            {
                EmitterHashes[i] = br.ReadUInt32();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(EmitterCount);
            for (int i = 0; i < EmitterCount; i++)
            {
                bw.Write(EmitterHashes[i]);
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteHashItemArray(sb, EmitterHashes, indent, "Emitters");
        }
        public override void ReadXml(XmlNode node)
        {
            EmitterHashes = XmlRel.ReadHashItemArray(node, "Emitters");
            EmitterCount = (uint)(EmitterHashes?.Length ?? 0);
        }
        public override MetaHash[] GetGameHashes()
        {
            return EmitterHashes;
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151AmbientZone : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public Dat151ZoneShape Shape { get; set; }
        public short unused0 { get; set; }
        public byte unused00 { get; set; }
        public uint Padding00 { get; set; }
        public Vector3 ActivationZoneCentre { get; set; }
        public float Unused01 { get; set; }
        public Vector3 ActivationZoneSize { get; set; } 
        public float Unused02 { get; set; }
        public Vector3 ActivationZonePostRotationOffset { get; set; }
        public uint Padding01 { get; set; }
        public Vector3 ActivationZoneSizeScale { get; set; }
        public uint Padding02 { get; set; }
        public ushort ActivationZoneRotationAngle { get; set; }
        public ushort Padding03 { get; set; }
        public uint Padding04 { get; set; }
        public uint Padding05 { get; set; }
        public uint Padding06 { get; set; }
        public Vector3 PositioningZoneCentre { get; set; }
        public float Unused06 { get; set; }
        public Vector3 PositioningZoneSize { get; set; }
        public float Unused07 { get; set; }
        public Vector3 PositioningZonePostRotationOffset { get; set; }
        public uint Padding07 { get; set; }
        public Vector3 PositioningZoneSizeScale { get; set; }
        public uint Padding08 { get; set; }
        public ushort PositioningZoneRotationAngle { get; set; }
        public ushort Padding09 { get; set; }
        public uint Padding10 { get; set; }
        public uint Padding11 { get; set; }
        public uint Padding12 { get; set; }
        public float BuiltUpFactor { get; set; }
        public float MinPedDensity { get; set; }
        public float MaxPedDensity { get; set; }
        public MetaHash PedDensityTOD { get; set; }
        public float PedDensityScalar { get; set; }
        public float MaxWindInfluence { get; set; }
        public float MinWindInfluence { get; set; }
        public MetaHash WindElevationSounds { get; set; }
        public MetaHash EnvironmentRule { get; set; }
        public MetaHash AudioScene { get; set; }
        public float UnderwaterCreakFactor { get; set; }
        public MetaHash PedWallaSettings { get; set; }
        public MetaHash RandomisedRadioSettings { get; set; }
        public byte NumRulesToPlay { get; set; }
        public byte ZoneWaterCalculation { get; set; }
        public byte NumRules { get; set; }
        public byte Unused11 { get; set; }
        public MetaHash[] Rules { get; set; }
        public byte NumDirAmbiences { get; set; }
        public byte Unused12 { get; set; }
        public byte Unused13 { get; set; }
        public byte Unused14 { get; set; }
        public DirAmbience[] DirAmbiences { get; set; }
        public struct DirAmbience : IMetaXmlItem
        {
            public MetaHash Name { get; set; }
            public float Volume { get; set; }
            public DirAmbience(BinaryReader br)
            {
                Name = br.ReadUInt32();
                Volume = br.ReadSingle();
            }
            public void Write(BinaryWriter bw)
            {
                bw.Write(Name);
                bw.Write(Volume);
            }
            public void WriteXml(StringBuilder sb, int indent)
            {
                RelXml.StringTag(sb, indent, "Name", RelXml.HashString(Name));
                RelXml.ValueTag(sb, indent, "Volume", FloatUtil.ToString(Volume));
            }
            public void ReadXml(XmlNode node)
            {
                Name = XmlRel.GetHash(Xml.GetChildInnerText(node, "Name"));
                Volume = Xml.GetChildFloatAttribute(node, "Volume", "value");
            }
            public override string ToString()
            {
                return Name.ToString() + ": " + FloatUtil.ToString(Volume);
            }
        }



        public Dat151AmbientZone(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.AmbientZone;
            TypeID = (byte)Type;
        }
        public Dat151AmbientZone(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Shape = (Dat151ZoneShape)br.ReadByte();
            unused0 = br.ReadInt16();
            unused00 = br.ReadByte();
            Padding00 = br.ReadUInt32();
            ActivationZoneCentre = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            Unused01 = br.ReadSingle();
            ActivationZoneSize = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            Unused02 = br.ReadSingle();
            ActivationZonePostRotationOffset = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            Padding01 = br.ReadUInt32();
            ActivationZoneSizeScale = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            Padding02 = br.ReadUInt32();
            ActivationZoneRotationAngle = br.ReadUInt16();
            Padding03 = br.ReadUInt16();
            Padding04 = br.ReadUInt32();
            Padding05 = br.ReadUInt32();
            Padding06 = br.ReadUInt32();
            PositioningZoneCentre = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            Unused06 = br.ReadSingle();
            PositioningZoneSize = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            Unused07 = br.ReadSingle();
            PositioningZonePostRotationOffset = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            Padding07 = br.ReadUInt32();
            PositioningZoneSizeScale = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            Padding08 = br.ReadUInt32();
            PositioningZoneRotationAngle = br.ReadUInt16();
            Padding09 = br.ReadUInt16();
            Padding10 = br.ReadUInt32();
            Padding11 = br.ReadUInt32();
            Padding12 = br.ReadUInt32();
            BuiltUpFactor = br.ReadSingle();
            MinPedDensity = br.ReadSingle();
            MaxPedDensity = br.ReadSingle();
            PedDensityTOD = br.ReadUInt32();
            PedDensityScalar = br.ReadSingle();
            MaxWindInfluence = br.ReadSingle();
            MinWindInfluence = br.ReadSingle();
            WindElevationSounds = br.ReadUInt32();
            EnvironmentRule = br.ReadUInt32();
            AudioScene = br.ReadUInt32();
            UnderwaterCreakFactor = br.ReadSingle();
            PedWallaSettings = br.ReadUInt32();
            RandomisedRadioSettings = br.ReadUInt32();
            NumRulesToPlay = br.ReadByte();
            ZoneWaterCalculation = br.ReadByte();
            NumRules = br.ReadByte();
            Unused11 = br.ReadByte();

            var rules = new MetaHash[NumRules];
            for (int i = 0; i < NumRules; i++)
            {
                rules[i] = br.ReadUInt32();
            }
            Rules = rules;

            NumDirAmbiences = br.ReadByte();
            Unused12 = br.ReadByte();
            Unused13 = br.ReadByte();
            Unused14 = br.ReadByte();

            DirAmbiences = new DirAmbience[NumDirAmbiences];
            for (int i = 0; i < NumDirAmbiences; i++)
            {
                DirAmbiences[i] = new DirAmbience(br);
            }

        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write((uint)Shape);
            bw.Write(Padding00);
            bw.Write(ActivationZoneCentre.X);
            bw.Write(ActivationZoneCentre.Y);
            bw.Write(ActivationZoneCentre.Z);
            bw.Write(Unused01);
            bw.Write(ActivationZoneSize.X);
            bw.Write(ActivationZoneSize.Y);
            bw.Write(ActivationZoneSize.Z);
            bw.Write(Unused02);
            bw.Write(ActivationZonePostRotationOffset.X);
            bw.Write(ActivationZonePostRotationOffset.Y);
            bw.Write(ActivationZonePostRotationOffset.Z);
            bw.Write(Padding01);
            bw.Write(ActivationZoneSizeScale.X);
            bw.Write(ActivationZoneSizeScale.Y);
            bw.Write(ActivationZoneSizeScale.Z);
            bw.Write(Padding02);
            bw.Write(ActivationZoneRotationAngle);
            bw.Write(Padding03);
            bw.Write(Padding04);
            bw.Write(Padding05);
            bw.Write(Padding06);
            bw.Write(PositioningZoneCentre.X);
            bw.Write(PositioningZoneCentre.Y);
            bw.Write(PositioningZoneCentre.Z);
            bw.Write(Unused06);
            bw.Write(PositioningZoneSize.X);
            bw.Write(PositioningZoneSize.Y);
            bw.Write(PositioningZoneSize.Z);
            bw.Write(Unused07);
            bw.Write(PositioningZonePostRotationOffset.X);
            bw.Write(PositioningZonePostRotationOffset.Y);
            bw.Write(PositioningZonePostRotationOffset.Z);
            bw.Write(Padding07);
            bw.Write(PositioningZoneSizeScale.X);
            bw.Write(PositioningZoneSizeScale.Y);
            bw.Write(PositioningZoneSizeScale.Z);
            bw.Write(Padding08);
            bw.Write(PositioningZoneRotationAngle);
            bw.Write(Padding09);
            bw.Write(Padding10);
            bw.Write(Padding11);
            bw.Write(Padding12);
            bw.Write(BuiltUpFactor);
            bw.Write(MinPedDensity);
            bw.Write(MaxPedDensity);
            bw.Write(PedDensityTOD);
            bw.Write(PedDensityScalar);
            bw.Write(MaxWindInfluence);
            bw.Write(MinWindInfluence);
            bw.Write(WindElevationSounds);
            bw.Write(EnvironmentRule);
            bw.Write(AudioScene);
            bw.Write(UnderwaterCreakFactor);
            bw.Write(PedWallaSettings);
            bw.Write(RandomisedRadioSettings);
            bw.Write(NumRulesToPlay);
            bw.Write(ZoneWaterCalculation); 
            bw.Write(NumRules);
            bw.Write(Unused11);

            for (int i = 0; i < NumRules; i++)
            {
                bw.Write(Rules[i]);
            }

            bw.Write(NumDirAmbiences);
            bw.Write(Unused12);
            bw.Write(Unused13);
            bw.Write(Unused14);

            for (int i = 0; i < NumDirAmbiences; i++)
            {
                DirAmbiences[i].Write(bw);
            }
            while ((bw.BaseStream.Position & 0xF) != 0) bw.Write((byte)0); //pad out to next 16 bytes
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "Shape", Shape.ToString());
            RelXml.SelfClosingTag(sb, indent, "ActivationZoneCentre " + FloatUtil.GetVector3XmlString(ActivationZoneCentre));
            RelXml.SelfClosingTag(sb, indent, "ActivationZoneSize " + FloatUtil.GetVector3XmlString(ActivationZoneSize));
            RelXml.SelfClosingTag(sb, indent, "ActivationZonePostRotationOffset " + FloatUtil.GetVector3XmlString(ActivationZonePostRotationOffset));
            RelXml.SelfClosingTag(sb, indent, "ActivationZoneSizeScale " + FloatUtil.GetVector3XmlString(ActivationZoneSizeScale));
            RelXml.ValueTag(sb, indent, "ActivationZoneRotationAngle", ActivationZoneRotationAngle.ToString());
            RelXml.SelfClosingTag(sb, indent, "PositioningZoneCentre " + FloatUtil.GetVector3XmlString(PositioningZoneCentre));
            RelXml.SelfClosingTag(sb, indent, "PositioningZoneSize " + FloatUtil.GetVector3XmlString(PositioningZoneSize));
            RelXml.SelfClosingTag(sb, indent, "PositioningZonePostRotationOffset " + FloatUtil.GetVector3XmlString(PositioningZonePostRotationOffset));
            RelXml.SelfClosingTag(sb, indent, "PositioningZoneSizeScale " + FloatUtil.GetVector3XmlString(PositioningZoneSizeScale));
            RelXml.ValueTag(sb, indent, "PositioningZoneRotationAngle", PositioningZoneRotationAngle.ToString());
            RelXml.ValueTag(sb, indent, "BuiltUpFactor", FloatUtil.ToString(BuiltUpFactor));
            RelXml.ValueTag(sb, indent, "MinPedDensity", FloatUtil.ToString(MinPedDensity));
            RelXml.ValueTag(sb, indent, "MaxPedDensity", FloatUtil.ToString(MaxPedDensity));
            RelXml.StringTag(sb, indent, "PedDensityTOD", RelXml.HashString(PedDensityTOD));
            RelXml.ValueTag(sb, indent, "PedDensityScalar", FloatUtil.ToString(PedDensityScalar));
            RelXml.ValueTag(sb, indent, "MaxWindInfluence", FloatUtil.ToString(MaxWindInfluence));
            RelXml.ValueTag(sb, indent, "MinWindInfluence", FloatUtil.ToString(MinWindInfluence));
            RelXml.StringTag(sb, indent, "WindElevationSounds", RelXml.HashString(WindElevationSounds));
            RelXml.StringTag(sb, indent, "EnvironmentRule", RelXml.HashString(EnvironmentRule));
            RelXml.StringTag(sb, indent, "AudioScene", RelXml.HashString(AudioScene));
            RelXml.ValueTag(sb, indent, "UnderwaterCreakFactor", FloatUtil.ToString(UnderwaterCreakFactor));
            RelXml.StringTag(sb, indent, "PedWallaSettings", RelXml.HashString(PedWallaSettings));
            RelXml.StringTag(sb, indent, "RandomisedRadioSettings", RelXml.HashString(RandomisedRadioSettings));
            RelXml.ValueTag(sb, indent, "NumRulesToPlay", NumRulesToPlay.ToString());
            RelXml.ValueTag(sb, indent, "ZoneWaterCalculation", ZoneWaterCalculation.ToString());
            RelXml.WriteHashItemArray(sb, Rules, indent, "Rules");
            RelXml.WriteItemArray(sb, DirAmbiences, indent, "DirAmbiences");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Shape = Xml.GetEnumValue<Dat151ZoneShape>(Xml.GetChildInnerText(node, "Shape"));
            ActivationZoneCentre = Xml.GetChildVector3Attributes(node, "ActivationZoneCentre");
            ActivationZoneSize = Xml.GetChildVector3Attributes(node, "ActivationZoneSize");
            ActivationZonePostRotationOffset = Xml.GetChildVector3Attributes(node, "ActivationZonePostRotationOffset");
            ActivationZoneSizeScale = Xml.GetChildVector3Attributes(node, "ActivationZoneSizeScale");
            ActivationZoneRotationAngle = (ushort)Xml.GetChildUIntAttribute(node, "ActivationZoneRotationAngle", "value");
            PositioningZoneCentre = Xml.GetChildVector3Attributes(node, "PositioningZoneCentre");
            PositioningZoneSize = Xml.GetChildVector3Attributes(node, "PositioningZoneSize");
            PositioningZonePostRotationOffset = Xml.GetChildVector3Attributes(node, "PositioningZonePostRotationOffset");
            PositioningZoneSizeScale = Xml.GetChildVector3Attributes(node, "PositioningZoneSizeScale");
            PositioningZoneRotationAngle = (ushort)Xml.GetChildUIntAttribute(node, "PositioningZoneRotationAngle", "value");
            BuiltUpFactor = Xml.GetChildFloatAttribute(node, "BuiltUpFactor", "value");
            MinPedDensity = Xml.GetChildFloatAttribute(node, "MinPedDensity", "value");
            MaxPedDensity = Xml.GetChildFloatAttribute(node, "MaxPedDensity", "value");
            PedDensityTOD = XmlRel.GetHash(Xml.GetChildInnerText(node, "PedDensityTOD"));
            PedDensityScalar = Xml.GetChildFloatAttribute(node, "PedDensityScalar", "value");
            MaxWindInfluence = Xml.GetChildFloatAttribute(node, "MaxWindInfluence", "value");
            MinWindInfluence = Xml.GetChildFloatAttribute(node, "MinWindInfluence", "value");
            WindElevationSounds = XmlRel.GetHash(Xml.GetChildInnerText(node, "WindElevationSounds"));
            EnvironmentRule = XmlRel.GetHash(Xml.GetChildInnerText(node, "EnvironmentRule"));
            AudioScene = XmlRel.GetHash(Xml.GetChildInnerText(node, "AudioScene"));
            UnderwaterCreakFactor = Xml.GetChildFloatAttribute(node, "UnderwaterCreakFactor", "value");
            PedWallaSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "PedWallaSettings"));
            RandomisedRadioSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "RandomisedRadioSettings"));
            NumRulesToPlay = (byte)Xml.GetChildUIntAttribute(node, "NumRulesToPlay", "value");
            ZoneWaterCalculation = (byte)Xml.GetChildUIntAttribute(node, "ZoneWaterCalculation", "value");
            Rules = XmlRel.ReadHashItemArray(node, "Rules");
            NumRules = (byte)(Rules?.Length ?? 0);
            DirAmbiences = XmlRel.ReadItemArray<DirAmbience>(node, "DirAmbiences");
            NumDirAmbiences = (byte)(DirAmbiences?.Length ?? 0);
        }
        public override MetaHash[] GetMixerHashes()
        {
            return new[] { AudioScene, PedDensityTOD };
        }
        public override MetaHash[] GetGameHashes()
        {
            var hashes = new List<MetaHash> { EnvironmentRule, WindElevationSounds };
            if (Rules != null)
                hashes.AddRange(Rules);
            if (DirAmbiences != null)
                hashes.AddRange(DirAmbiences.Select(ep => ep.Name));

            return hashes.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151AmbientRule : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public uint Padding01 { get; set; }
        public uint Padding02 { get; set; }
        public Vector3 Position { get; set; }
        public uint Padding03 { get; set; }
        public MetaHash ChildSound { get; set; }
        public MetaHash Category { get; set; }
        public uint LastPlayTime { get; set; }
        public int DynamicBankID { get; set; }
        public uint DynamicSlotType { get; set; }
        public float Weight { get; set; }
        public float MinDist { get; set; }                 // inner radius  of volume (playback bound)
        public float MaxDist { get; set; }                 // outer radius  of volume (activation bound)
        public ushort MinTimeMinutes { get; set; }         // time allows to start playing, in mins
        public ushort MaxTimeMinutes { get; set; }         // time to stop playing, in mins (max 1440)
        public ushort MinRepeatTime { get; set; }          // 0..600
        public ushort MinRepeatTimeVariance { get; set; }  // 0..150
        public byte SpawnHeight { get; set; }              // 0,1,2
        public ExplicitSpawnType ExplicitSpawn { get; set; }
        public byte MaxLocalInstances { get; set; }        // 1,2,3,4,8,255
        public byte MaxGlobalInstances { get; set; }       // 1,2,3,4,5,6,8,10,255
        public byte BlockabilityFactor { get; set; }       // 0, 50, 80, 100
        public byte MaxPathDepth { get; set; }             // 1,2,3,5
        public ushort NumConditions { get; set; }          // 0,1,2,4
        public Condition[] Conditions { get; set; }

        public struct Condition : IMetaXmlItem
        {
            public MetaHash Name;
            public float Value;
            public byte ConditionType;
            public byte BankLoading;
            public ushort Padding;
            public Condition(BinaryReader br)
            {
                Name = br.ReadUInt32();
                Value = br.ReadSingle();
                ConditionType = br.ReadByte();
                BankLoading = br.ReadByte();
                Padding = br.ReadUInt16();
            }
            public void Write(BinaryWriter bw)
            {
                bw.Write(Name);
                bw.Write(Value);
                bw.Write(ConditionType);
                bw.Write(BankLoading);
                bw.Write(Padding);
            }
            public void WriteXml(StringBuilder sb, int indent)
            {
                RelXml.StringTag(sb, indent, "Name", RelXml.HashString(Name));
                RelXml.ValueTag(sb, indent, "Value", FloatUtil.ToString(Value));
                RelXml.ValueTag(sb, indent, "ConditionType", FloatUtil.ToString(ConditionType));
                RelXml.ValueTag(sb, indent, "BankLoading", FloatUtil.ToString(BankLoading));
            }
            public void ReadXml(XmlNode node)
            {
                Name = XmlRel.GetHash(Xml.GetChildInnerText(node, "Name"));
                Value = Xml.GetChildFloatAttribute(node, "Value", "value");
                ConditionType = (byte)Xml.GetChildUIntAttribute(node, "ConditionType", "value");
                BankLoading = (byte)Xml.GetChildUIntAttribute(node, "BankLoading", "value");
            }
            public override string ToString()
            {
                return Name.ToString() + ": " + FloatUtil.ToString(Value) + ": " + ConditionType.ToString();
            }
        }

        public enum ExplicitSpawnType : byte
        {
            Disabled = 0,
            WorldRelative = 1,
            InteriorRelative = 2,
        }

        public Dat151AmbientRule(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.AmbientRule;
            TypeID = (byte)Type;
        }
        public Dat151AmbientRule(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Padding01 = br.ReadUInt32();
            Padding02 = br.ReadUInt32();
            Position = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            Padding03 = br.ReadUInt32();
            ChildSound = br.ReadUInt32();
            Category = br.ReadUInt32();
            LastPlayTime = br.ReadUInt32();
            DynamicBankID = br.ReadInt32();
            DynamicSlotType = br.ReadUInt32();
            Weight = br.ReadSingle();
            MinDist = br.ReadSingle();           // inner radius  of volume (playback bound)
            MaxDist = br.ReadSingle();           // outer radius of volume (activation bound)
            MinTimeMinutes = br.ReadUInt16();    // time allows to start playing, in mins
            MaxTimeMinutes = br.ReadUInt16();    // time to stop playing, in mins (max 1440)
            MinRepeatTime = br.ReadUInt16();
            MinRepeatTimeVariance = br.ReadUInt16();
            SpawnHeight = br.ReadByte();
            ExplicitSpawn = (ExplicitSpawnType)br.ReadByte();
            MaxLocalInstances = br.ReadByte();
            MaxGlobalInstances = br.ReadByte();
            BlockabilityFactor = br.ReadByte();
            MaxPathDepth = br.ReadByte();
            NumConditions = br.ReadUInt16();

            if (NumConditions > 0)
            {
                Conditions = new Condition[NumConditions];
                for (int i = 0; i < NumConditions; i++)
                {
                    Conditions[i] = new Condition(br);
                }
                //array seems to be padded to multiples of 16 bytes. (read the rest here)
                int brem = (16 - ((NumConditions * 12) % 16)) % 16;
                if (brem > 0)
                {
                    byte[] brema = br.ReadBytes(brem);
                }
            }

        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Padding01);
            bw.Write(Padding02);
            bw.Write(Position.X);
            bw.Write(Position.Y);
            bw.Write(Position.Z);
            bw.Write(Padding03);
            bw.Write(ChildSound);
            bw.Write(Category);
            bw.Write(LastPlayTime);
            bw.Write(DynamicBankID);
            bw.Write(DynamicSlotType);
            bw.Write(Weight);
            bw.Write(MinDist);
            bw.Write(MaxDist);
            bw.Write(MinTimeMinutes);
            bw.Write(MaxTimeMinutes);
            bw.Write(MinRepeatTime);
            bw.Write(MinRepeatTimeVariance);
            bw.Write(SpawnHeight);
            bw.Write((byte)ExplicitSpawn);
            bw.Write(MaxLocalInstances);
            bw.Write(MaxGlobalInstances);
            bw.Write(BlockabilityFactor);
            bw.Write(MaxPathDepth);
            bw.Write(NumConditions);

            if (NumConditions > 0)
            {
                for (int i = 0; i < NumConditions; i++)
                {
                    Conditions[i].Write(bw);
                }
                //array seems to be padded to multiples of 16 bytes. (write the rest here)
                while ((bw.BaseStream.Position & 0xF) != 0) bw.Write((byte)0); //pad out to next 16 bytes
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.SelfClosingTag(sb, indent, "Position " + FloatUtil.GetVector3XmlString(Position));
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
            RelXml.StringTag(sb, indent, "Category", RelXml.HashString(Category));
            RelXml.ValueTag(sb, indent, "LastPlayTime", LastPlayTime.ToString()); ;
            RelXml.ValueTag(sb, indent, "DynamicBankID", DynamicBankID.ToString());
            RelXml.ValueTag(sb, indent, "DynamicSlotType", DynamicSlotType.ToString());
            RelXml.ValueTag(sb, indent, "Weight", FloatUtil.ToString(Weight));
            RelXml.ValueTag(sb, indent, "MinDist", FloatUtil.ToString(MinDist));
            RelXml.ValueTag(sb, indent, "MaxDist", FloatUtil.ToString(MaxDist));
            RelXml.ValueTag(sb, indent, "MinTimeMinutes", MinTimeMinutes.ToString());
            RelXml.ValueTag(sb, indent, "MaxTimeMinutes", MaxTimeMinutes.ToString());
            RelXml.ValueTag(sb, indent, "MinRepeatTime", MinRepeatTime.ToString());
            RelXml.ValueTag(sb, indent, "MinRepeatTimeVariance", MinRepeatTimeVariance.ToString());
            RelXml.ValueTag(sb, indent, "SpawnHeight", SpawnHeight.ToString());
            RelXml.StringTag(sb, indent, "ExplicitSpawn", ExplicitSpawn.ToString());
            RelXml.ValueTag(sb, indent, "MaxLocalInstances", MaxLocalInstances.ToString());
            RelXml.ValueTag(sb, indent, "MaxGlobalInstances", MaxGlobalInstances.ToString());
            RelXml.ValueTag(sb, indent, "BlockabilityFactor", BlockabilityFactor.ToString());
            RelXml.ValueTag(sb, indent, "MaxPathDepth", MaxPathDepth.ToString());
            RelXml.WriteItemArray(sb, Conditions, indent, "Conditions");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Position = Xml.GetChildVector3Attributes(node, "Position");
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
            Category = XmlRel.GetHash(Xml.GetChildInnerText(node, "Category"));
            LastPlayTime = Xml.GetChildUIntAttribute(node, "LastPlayTime", "value");
            DynamicBankID = Xml.GetChildIntAttribute(node, "DynamicBankID", "value");
            DynamicSlotType = Xml.GetChildUIntAttribute(node, "DynamicSlotType", "value");
            Weight = Xml.GetChildFloatAttribute(node, "Weight", "value");
            MinDist = Xml.GetChildFloatAttribute(node, "MinDist", "value");
            MaxDist = Xml.GetChildFloatAttribute(node, "MaxDist", "value");
            MinTimeMinutes = (ushort)Xml.GetChildUIntAttribute(node, "MinTimeMinutes", "value");
            MaxTimeMinutes = (ushort)Xml.GetChildUIntAttribute(node, "MaxTimeMinutes", "value");
            MinRepeatTime = (ushort)Xml.GetChildUIntAttribute(node, "MinRepeatTime", "value");
            MinRepeatTimeVariance = (ushort)Xml.GetChildUIntAttribute(node, "MinRepeatTimeVariance", "value");
            SpawnHeight = (byte)Xml.GetChildUIntAttribute(node, "SpawnHeight", "value");
            ExplicitSpawn = Xml.GetChildEnumInnerText<ExplicitSpawnType>(node, "ExplicitSpawn");
            MaxLocalInstances = (byte)Xml.GetChildUIntAttribute(node, "MaxLocalInstances", "value");
            MaxGlobalInstances = (byte)Xml.GetChildUIntAttribute(node, "MaxGlobalInstances", "value");
            BlockabilityFactor = (byte)Xml.GetChildUIntAttribute(node, "BlockabilityFactor", "value");
            MaxPathDepth = (byte)Xml.GetChildUIntAttribute(node, "MaxPathDepth", "value");
            Conditions = XmlRel.ReadItemArray<Condition>(node, "Conditions");
            NumConditions = (ushort)(Conditions?.Length ?? 0);
        }
        public override MetaHash[] GetCategoryHashes()
        {
            return new[] { Category };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { ChildSound };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151AmbientZoneList : Dat151RelData
    {
        public uint ZoneCount { get; set; }
        public MetaHash[] ZoneHashes { get; set; }

        public Dat151AmbientZoneList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.AmbientZoneList;
            TypeID = (byte)Type;
        }
        public Dat151AmbientZoneList(RelData d, BinaryReader br) : base(d, br)
        {
            ZoneCount = br.ReadUInt32();
            ZoneHashes = new MetaHash[ZoneCount];
            for (int i = 0; i < ZoneCount; i++)
            {
                ZoneHashes[i] = br.ReadUInt32();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(ZoneCount);
            for (int i = 0; i < ZoneCount; i++)
            {
                bw.Write(ZoneHashes[i]);
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteHashItemArray(sb, ZoneHashes, indent, "Zones");
        }
        public override void ReadXml(XmlNode node)
        {
            ZoneHashes = XmlRel.ReadHashItemArray(node, "Zones");
            ZoneCount = (uint)(ZoneHashes?.Length ?? 0);
        }
        public override MetaHash[] GetGameHashes()
        {
            return ZoneHashes;
        }
    }

    [TC(typeof(EXP))]
    public class Dat151StaticEmitter : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash ChildSound { get; set; }
        public MetaHash RadioStation { get; set; }
        public Vector3 Position { get; set; }
        public float MinDistance { get; set; }
        public float MaxDistance { get; set; }
        public int EmittedVolume { get; set; }
        public ushort LPFCutoff { get; set; }
        public ushort HPFCutoff { get; set; }
        public ushort RolloffFactor { get; set; }
        public ushort Padding00 { get; set; }
        public MetaHash Interior { get; set; }
        public MetaHash Room { get; set; }
        public MetaHash RadioStationForScore { get; set; }
        public float MaxLeakage { get; set; }
        public ushort MinLeakageDistance { get; set; }
        public ushort MaxLeakageDistance { get; set; }
        public MetaHash Alarm { get; set; }
        public MetaHash OnBreakOneShot { get; set; }
        public byte MaxPathDepth { get; set; }
        public byte SmallReverbSend { get; set; }
        public byte MediumReverbSend { get; set; }
        public byte LargeReverbSend { get; set; }
        public ushort MinTimeMinutes { get; set; }
        public ushort MaxTimeMinutes { get; set; }
        public float BrokenHealth { get; set; }
        public float UndamagedHealth { get; set; }

        public Dat151StaticEmitter(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.StaticEmitter;
            TypeID = (byte)Type;
        }
        public Dat151StaticEmitter(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            ChildSound = br.ReadUInt32();
            RadioStation = br.ReadUInt32();
            Position = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            MinDistance = br.ReadSingle();
            MaxDistance = br.ReadSingle();
            EmittedVolume = br.ReadInt32();
            LPFCutoff = br.ReadUInt16();
            HPFCutoff = br.ReadUInt16();
            RolloffFactor = br.ReadUInt16();
            Padding00 = br.ReadUInt16();
            Interior = br.ReadUInt32();
            Room = br.ReadUInt32();
            RadioStationForScore = br.ReadUInt32();
            MaxLeakage = br.ReadSingle();
            MinLeakageDistance = br.ReadUInt16();
            MaxLeakageDistance = br.ReadUInt16();
            Alarm = br.ReadUInt32();
            OnBreakOneShot = br.ReadUInt32();
            MaxPathDepth = br.ReadByte();
            SmallReverbSend = br.ReadByte();
            MediumReverbSend = br.ReadByte();
            LargeReverbSend = br.ReadByte();
            MinTimeMinutes = br.ReadUInt16();
            MaxTimeMinutes = br.ReadUInt16();
            BrokenHealth = br.ReadSingle();
            UndamagedHealth = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);
            bw.Write(Flags);
            bw.Write(ChildSound);
            bw.Write(RadioStation);
            bw.Write(Position.X);
            bw.Write(Position.Y);
            bw.Write(Position.Z);
            bw.Write(MinDistance);
            bw.Write(MaxDistance);
            bw.Write(EmittedVolume);
            bw.Write(LPFCutoff);
            bw.Write(HPFCutoff);
            bw.Write(RolloffFactor);
            bw.Write(Padding00);
            bw.Write(Interior);
            bw.Write(Room);
            bw.Write(RadioStationForScore);
            bw.Write(MaxLeakage);
            bw.Write(MinLeakageDistance);
            bw.Write(MaxLeakageDistance);
            bw.Write(Alarm);
            bw.Write(OnBreakOneShot);
            bw.Write(MaxPathDepth);
            bw.Write(SmallReverbSend);
            bw.Write(MediumReverbSend);
            bw.Write(LargeReverbSend);
            bw.Write(MinTimeMinutes);
            bw.Write(MaxTimeMinutes);
            bw.Write(BrokenHealth);
            bw.Write(UndamagedHealth);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "ChildSound", RelXml.HashString(ChildSound));
            RelXml.StringTag(sb, indent, "RadioStation", RelXml.HashString(RadioStation));
            RelXml.SelfClosingTag(sb, indent, "Position " + FloatUtil.GetVector3XmlString(Position));
            RelXml.ValueTag(sb, indent, "MinDistance", FloatUtil.ToString(MinDistance));
            RelXml.ValueTag(sb, indent, "MaxDistance", FloatUtil.ToString(MaxDistance));
            RelXml.ValueTag(sb, indent, "EmittedVolume", EmittedVolume.ToString());
            RelXml.ValueTag(sb, indent, "LPFCutoff", LPFCutoff.ToString());
            RelXml.ValueTag(sb, indent, "HPFCutoff", HPFCutoff.ToString());
            RelXml.ValueTag(sb, indent, "RolloffFactor", RolloffFactor.ToString());
            RelXml.StringTag(sb, indent, "Interior", RelXml.HashString(Interior));
            RelXml.StringTag(sb, indent, "Room", RelXml.HashString(Room));
            RelXml.StringTag(sb, indent, "RadioStationForScore", RelXml.HashString(RadioStationForScore));
            RelXml.ValueTag(sb, indent, "MaxLeakage", FloatUtil.ToString(MaxLeakage));
            RelXml.ValueTag(sb, indent, "MinLeakageDistance", MinLeakageDistance.ToString());
            RelXml.ValueTag(sb, indent, "MaxLeakageDistance", MaxLeakageDistance.ToString());
            RelXml.StringTag(sb, indent, "Alarm", RelXml.HashString(Alarm));
            RelXml.StringTag(sb, indent, "OnBreakOneShot", RelXml.HashString(OnBreakOneShot));
            RelXml.ValueTag(sb, indent, "MaxPathDepth", MaxPathDepth.ToString());
            RelXml.ValueTag(sb, indent, "SmallReverbSend", SmallReverbSend.ToString());
            RelXml.ValueTag(sb, indent, "MediumReverbSend", MediumReverbSend.ToString());
            RelXml.ValueTag(sb, indent, "LargeReverbSend", LargeReverbSend.ToString());
            RelXml.ValueTag(sb, indent, "MinTimeMinutes", MinTimeMinutes.ToString());
            RelXml.ValueTag(sb, indent, "MaxTimeMinutes", MaxTimeMinutes.ToString());
            RelXml.ValueTag(sb, indent, "BrokenHealth", FloatUtil.ToString(BrokenHealth));
            RelXml.ValueTag(sb, indent, "UndamagedHealth", FloatUtil.ToString(UndamagedHealth));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            ChildSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChildSound"));
            RadioStation = XmlRel.GetHash(Xml.GetChildInnerText(node, "RadioStation"));
            Position = Xml.GetChildVector3Attributes(node, "Position");
            MinDistance = Xml.GetChildFloatAttribute(node, "MinDistance", "value");
            MaxDistance = Xml.GetChildFloatAttribute(node, "MaxDistance", "value");
            EmittedVolume = Xml.GetChildIntAttribute(node, "EmittedVolume", "value");
            LPFCutoff = (ushort)Xml.GetChildIntAttribute(node, "LPFCutoff", "value");
            HPFCutoff = (ushort)Xml.GetChildIntAttribute(node, "HPFCutoff", "value");
            RolloffFactor = (ushort)Xml.GetChildIntAttribute(node, "RolloffFactor", "value");
            Interior = XmlRel.GetHash(Xml.GetChildInnerText(node, "Interior"));
            Room = XmlRel.GetHash(Xml.GetChildInnerText(node, "Room"));
            RadioStationForScore = XmlRel.GetHash(Xml.GetChildInnerText(node, "RadioStationForScore"));
            MaxLeakage = Xml.GetChildFloatAttribute(node, "MaxLeakage", "value");
            MinLeakageDistance = (ushort)Xml.GetChildUIntAttribute(node, "MinLeakageDistance", "value");
            MaxLeakageDistance = (ushort)Xml.GetChildUIntAttribute(node, "MaxLeakageDistance", "value");
            Alarm = XmlRel.GetHash(Xml.GetChildInnerText(node, "Alarm"));
            OnBreakOneShot = XmlRel.GetHash(Xml.GetChildInnerText(node, "OnBreakOneShot"));
            MaxPathDepth = (byte)Xml.GetChildUIntAttribute(node, "MaxPathDepth", "value");
            SmallReverbSend = (byte)Xml.GetChildUIntAttribute(node, "SmallReverbSend", "value");
            MediumReverbSend = (byte)Xml.GetChildUIntAttribute(node, "MediumReverbSend", "value");
            LargeReverbSend = (byte)Xml.GetChildUIntAttribute(node, "LargeReverbSend", "value");
            MinTimeMinutes = (ushort)Xml.GetChildUIntAttribute(node, "MinTimeMinutes", "value");
            MaxTimeMinutes = (ushort)Xml.GetChildUIntAttribute(node, "MaxTimeMinutes", "value");
            BrokenHealth = Xml.GetChildFloatAttribute(node, "BrokenHealth", "value");
            UndamagedHealth = Xml.GetChildFloatAttribute(node, "UndamagedHealth", "value");
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { ChildSound, OnBreakOneShot };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { RadioStation, Alarm, Interior };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151InteriorSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash InteriorWallaSoundSet { get; set; }
        public MetaHash InteriorReflections { get; set; }
        public uint RoomsCount { get; set; }
        public MetaHash[] Rooms { get; set; }

        public Dat151InteriorSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.InteriorSettings;
            TypeID = (byte)Type;
        }
        public Dat151InteriorSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            InteriorWallaSoundSet = br.ReadUInt32();
            InteriorReflections = br.ReadUInt32();
            RoomsCount = br.ReadUInt32();
            var rooms = new MetaHash[RoomsCount];
            for (int i = 0; i < RoomsCount; i++)
            {
                rooms[i] = br.ReadUInt32();
            }
            Rooms = rooms;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(InteriorWallaSoundSet);
            bw.Write(InteriorReflections);
            bw.Write(RoomsCount);
            for (int i = 0; i < RoomsCount; i++)
            {
                bw.Write(Rooms[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "InteriorWallaSoundSet", RelXml.HashString(InteriorWallaSoundSet));
            RelXml.StringTag(sb, indent, "InteriorReflections", RelXml.HashString(InteriorReflections));
            RelXml.WriteHashItemArray(sb, Rooms, indent, "Rooms");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            InteriorWallaSoundSet = XmlRel.GetHash(Xml.GetChildInnerText(node, "InteriorWallaSoundSet"));
            InteriorReflections = XmlRel.GetHash(Xml.GetChildInnerText(node, "InteriorReflections"));
            Rooms = XmlRel.ReadHashItemArray(node, "Rooms");
            RoomsCount = (uint)(Rooms?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < RoomsCount; i++)
            {
                offsets.Add(16 + i * 4);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { InteriorWallaSoundSet };
        }

        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            list.Add(InteriorReflections);
            if (Rooms != null)
            {
                list.AddRange(Rooms);
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151InteriorRoom : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash RoomName { get; set; }
        public MetaHash AmbientZone { get; set; }
        public byte InteriorType { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public float ReverbSmall { get; set; }
        public float ReverbMedium { get; set; }
        public float ReverbLarge { get; set; }
        public MetaHash RoomToneSound { get; set; }
        public byte RainType { get; set; }
        public byte padding02 { get; set; }
        public short padding03 { get; set; }
        public float ExteriorAudibility { get; set; }
        public float RoomOcclusionDamping { get; set; }
        public float NonMarkedPortalOcclusion { get; set; }
        public float DistanceFromPortalForOcclusion { get; set; }
        public float DistanceFromPortalFadeDistance { get; set; }
        public MetaHash WeaponMetrics { get; set; }
        public MetaHash InteriorWallaSoundSet { get; set; }

        public Dat151InteriorRoom(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.InteriorRoom;
            TypeID = (byte)Type;
        }
        public Dat151InteriorRoom(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            RoomName = br.ReadUInt32();
            AmbientZone = br.ReadUInt32();
            InteriorType = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            ReverbSmall = br.ReadSingle();
            ReverbMedium = br.ReadSingle();
            ReverbLarge = br.ReadSingle();
            RoomToneSound = br.ReadUInt32();
            RainType = br.ReadByte();
            padding02 = br.ReadByte();
            padding03 = br.ReadInt16();
            ExteriorAudibility = br.ReadSingle();
            RoomOcclusionDamping = br.ReadSingle();
            NonMarkedPortalOcclusion = br.ReadSingle();
            DistanceFromPortalForOcclusion = br.ReadSingle();
            DistanceFromPortalFadeDistance = br.ReadSingle();
            WeaponMetrics = br.ReadUInt32();
            InteriorWallaSoundSet = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(RoomName);
            bw.Write(AmbientZone);
            bw.Write(InteriorType);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(ReverbSmall);
            bw.Write(ReverbMedium);
            bw.Write(ReverbLarge);
            bw.Write(RoomToneSound);
            bw.Write(RainType);
            bw.Write(padding02);
            bw.Write(padding03);
            bw.Write(ExteriorAudibility);
            bw.Write(RoomOcclusionDamping);
            bw.Write(NonMarkedPortalOcclusion);
            bw.Write(DistanceFromPortalForOcclusion);
            bw.Write(DistanceFromPortalFadeDistance);
            bw.Write(WeaponMetrics);
            bw.Write(InteriorWallaSoundSet);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "RoomName", RelXml.HashString(RoomName));
            RelXml.StringTag(sb, indent, "AmbientZone", RelXml.HashString(AmbientZone));
            RelXml.ValueTag(sb, indent, "InteriorType", InteriorType.ToString());
            RelXml.ValueTag(sb, indent, "ReverbSmall", FloatUtil.ToString(ReverbSmall));
            RelXml.ValueTag(sb, indent, "ReverbMedium", FloatUtil.ToString(ReverbMedium));
            RelXml.ValueTag(sb, indent, "ReverbLarge", FloatUtil.ToString(ReverbLarge));
            RelXml.StringTag(sb, indent, "RoomToneSound", RelXml.HashString(RoomToneSound));
            RelXml.ValueTag(sb, indent, "RainType", FloatUtil.ToString(RainType));
            RelXml.ValueTag(sb, indent, "ExteriorAudibility", FloatUtil.ToString(ExteriorAudibility));
            RelXml.ValueTag(sb, indent, "RoomOcclusionDamping", FloatUtil.ToString(RoomOcclusionDamping));
            RelXml.ValueTag(sb, indent, "NonMarkedPortalOcclusion", FloatUtil.ToString(NonMarkedPortalOcclusion));
            RelXml.ValueTag(sb, indent, "DistanceFromPortalForOcclusion", FloatUtil.ToString(DistanceFromPortalForOcclusion));
            RelXml.ValueTag(sb, indent, "DistanceFromPortalFadeDistance", FloatUtil.ToString(DistanceFromPortalFadeDistance));
            RelXml.StringTag(sb, indent, "WeaponMetrics", RelXml.HashString(WeaponMetrics));
            RelXml.StringTag(sb, indent, "InteriorWallaSoundSet", RelXml.HashString(InteriorWallaSoundSet));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            RoomName = XmlRel.GetHash(Xml.GetChildInnerText(node, "RoomName"));
            AmbientZone = XmlRel.GetHash(Xml.GetChildInnerText(node, "AmbientZone"));
            InteriorType = (byte)Xml.GetChildUIntAttribute(node, "InteriorType", "value");
            ReverbSmall = Xml.GetChildFloatAttribute(node, "ReverbSmall", "value");
            ReverbMedium = Xml.GetChildFloatAttribute(node, "ReverbMedium", "value");
            ReverbLarge = Xml.GetChildFloatAttribute(node, "ReverbLarge", "value");
            RoomToneSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RoomToneSound"));
            RainType = (byte)Xml.GetChildUIntAttribute(node, "RainType", "value");
            ExteriorAudibility = Xml.GetChildFloatAttribute(node, "ExteriorAudibility", "value");
            RoomOcclusionDamping = Xml.GetChildFloatAttribute(node, "RoomOcclusionDamping", "value");
            NonMarkedPortalOcclusion = Xml.GetChildFloatAttribute(node, "NonMarkedPortalOcclusion", "value");
            DistanceFromPortalForOcclusion = Xml.GetChildFloatAttribute(node, "DistanceFromPortalForOcclusion", "value");
            DistanceFromPortalFadeDistance = Xml.GetChildFloatAttribute(node, "DistanceFromPortalFadeDistance", "value");
            WeaponMetrics = XmlRel.GetHash(Xml.GetChildInnerText(node, "WeaponMetrics"));
            InteriorWallaSoundSet = XmlRel.GetHash(Xml.GetChildInnerText(node, "InteriorWallaSoundSet"));
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 8 };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { RoomToneSound, InteriorWallaSoundSet };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { AmbientZone, WeaponMetrics };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151RadioStationList : Dat151RelData
    {
        public uint StationsCount { get; set; }
        public MetaHash[] Stations { get; set; }

        public Dat151RadioStationList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.RadioStationList;
            TypeID = (byte)Type;
        }
        public Dat151RadioStationList(RelData d, BinaryReader br) : base(d, br)
        {
            StationsCount = br.ReadUInt32();
            var tracks = new MetaHash[StationsCount];
            for (int i = 0; i < StationsCount; i++)
            {
                tracks[i] = br.ReadUInt32();
            }
            Stations = tracks;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(StationsCount);
            for (int i = 0; i < StationsCount; i++)
            {
                bw.Write(Stations[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteHashItemArray(sb, Stations, indent, "Stations");
        }
        public override void ReadXml(XmlNode node)
        {
            Stations = XmlRel.ReadHashItemArray(node, "Stations");
            StationsCount = (uint)(Stations?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < StationsCount; i++)
            {
                offsets.Add(4 + i * 4);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetGameHashes()
        {
            return Stations;
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151RadioStationSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public uint WheelPosition { get; set; }
        public uint NextStationSettingsPtr { get; set; }
        public byte Genre { get; set; }
        public byte AmbientRadioVol { get; set; }
        public string RadioName { get; set; }
        public ushort padding00 { get; set; }

        public uint NumTrackList { get; set; }
        public MetaHash[] TrackList { get; set; }

        public Dat151RadioStationSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.RadioStationSettings;
            TypeID = (byte)Type;
        }
        public Dat151RadioStationSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            WheelPosition = br.ReadUInt32();
            NextStationSettingsPtr = br.ReadUInt32();
            Genre = br.ReadByte();
            AmbientRadioVol = br.ReadByte();

            var data = br.ReadBytes(32);
            RadioName = Encoding.ASCII.GetString(data).Replace("\0", "");

            padding00 = br.ReadUInt16();

            NumTrackList = br.ReadUInt32();
            var tracks = new MetaHash[NumTrackList];
            for (int i = 0; i < NumTrackList; i++)
            {
                tracks[i] = br.ReadUInt32();
            }
            TrackList = tracks;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(WheelPosition);
            bw.Write(NextStationSettingsPtr);
            bw.Write(Genre);
            bw.Write(AmbientRadioVol);

            byte[] data = new byte[32];
            int len = Math.Min(RadioName?.Length ?? 0, 32);
            if (len > 0)
            {
                Encoding.ASCII.GetBytes(RadioName, 0, len, data, 0);
            }
            bw.Write(data);

            bw.Write(padding00);

            bw.Write(NumTrackList);
            for (int i = 0; i < NumTrackList; i++)
            {
                bw.Write(TrackList[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "WheelPosition", WheelPosition.ToString());
            RelXml.ValueTag(sb, indent, "Genre", Genre.ToString());
            RelXml.ValueTag(sb, indent, "AmbientRadioVol", AmbientRadioVol.ToString());
            RelXml.StringTag(sb, indent, "RadioName", RadioName);
            RelXml.WriteHashItemArray(sb, TrackList, indent, "TrackList");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            WheelPosition = Xml.GetChildUIntAttribute(node, "WheelPosition", "value");
            Genre = (byte)Xml.GetChildUIntAttribute(node, "Genre", "value");
            AmbientRadioVol = (byte)Xml.GetChildUIntAttribute(node, "AmbientRadioVol", "value");
            RadioName = Xml.GetChildInnerText(node, "RadioName");
            TrackList = XmlRel.ReadHashItemArray(node, "TrackList");
            NumTrackList = (uint)(TrackList?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < NumTrackList; i++)
            {
                offsets.Add(52 + i * 4);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetGameHashes()
        {
            return TrackList;
        }
    }

    [TC(typeof(EXP))]
    public class Dat151RadioStationTrackList : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public byte Category { get; set; }
        public uint padding00 { get; set; }
        public uint padding01 { get; set; }
        public byte NumHistorySpaceElems { get; set; }
        public uint padding03 { get; set; }
        public uint HistorySpace00 { get; set; }
        public uint HistorySpace01 { get; set; }
        public uint HistorySpace02 { get; set; }
        public uint HistorySpace03 { get; set; }
        public uint HistorySpace04 { get; set; }
        public uint HistorySpace05 { get; set; }
        public uint HistorySpace06 { get; set; }
        public uint HistorySpace07 { get; set; }
        public uint HistorySpace08 { get; set; }
        public uint HistorySpace09 { get; set; }
        public uint TotalNumTracks { get; set; }
        public ushort NextTrackListPointer { get; set; }
        public uint NumTracks { get; set; }
        public Dat151HashPair[] Tracks { get; set; }


        public Dat151RadioStationTrackList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.RadioStationTrackList;
            TypeID = (byte)Type;
        }
        public Dat151RadioStationTrackList(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Category = br.ReadByte();
            padding00 = br.ReadUInt32();
            padding01 = br.ReadUInt32();
            NumHistorySpaceElems = br.ReadByte();
            padding03 = br.ReadUInt32();
            HistorySpace00 = br.ReadUInt32();
            HistorySpace01 = br.ReadUInt32();
            HistorySpace02 = br.ReadUInt32();
            HistorySpace03 = br.ReadUInt32();
            HistorySpace04 = br.ReadUInt32();
            HistorySpace05 = br.ReadUInt32();
            HistorySpace06 = br.ReadUInt32();
            HistorySpace07 = br.ReadUInt32();
            HistorySpace08 = br.ReadUInt32();
            HistorySpace09 = br.ReadUInt32();
            TotalNumTracks = br.ReadUInt32();
            NextTrackListPointer = br.ReadUInt16();
            NumTracks = br.ReadUInt32();

            Dat151HashPair[] items = new Dat151HashPair[NumTracks];
            for (int i = 0; i < NumTracks; i++)
            {
                items[i] = new Dat151HashPair(br);
            }
            this.Tracks = items;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Category);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(NumHistorySpaceElems);
            bw.Write(padding03);
            bw.Write(HistorySpace00);
            bw.Write(HistorySpace01);
            bw.Write(HistorySpace02);
            bw.Write(HistorySpace03);
            bw.Write(HistorySpace04);
            bw.Write(HistorySpace05);
            bw.Write(HistorySpace06);
            bw.Write(HistorySpace07);
            bw.Write(HistorySpace08);
            bw.Write(HistorySpace09);
            bw.Write(TotalNumTracks);
            bw.Write(NextTrackListPointer);
            bw.Write(NumTracks);
            for (int i = 0; i < NumTracks; i++)
            {
                Tracks[i].Write(bw);
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Category", Category.ToString());
            RelXml.ValueTag(sb, indent, "NumHistorySpaceElems", NumHistorySpaceElems.ToString());
            RelXml.WriteItemArray(sb, Tracks, indent, "Tracks");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Category = (byte)Xml.GetChildUIntAttribute(node, "Category", "value");
            NumHistorySpaceElems = (byte)Xml.GetChildUIntAttribute(node, "NumHistorySpaceElems", "value");
            Tracks = XmlRel.ReadItemArray<Dat151HashPair>(node, "Tracks");
            NumTracks = (uint)(Tracks?.Length ?? 0);
        }
        public override MetaHash[] GetSoundHashes()
        {
            var list = new List<MetaHash>();
            if (Tracks != null)
            {
                foreach (var item in Tracks)
                {
                    list.Add(item.SoundRef);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ReplayRadioStationTrackList : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public uint TrackCount { get; set; }
        public Dat151HashPair[] Tracks { get; set; }

        public Dat151ReplayRadioStationTrackList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ReplayRadioStationTrackList;
            TypeID = (byte)Type;
        }
        public Dat151ReplayRadioStationTrackList(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            TrackCount = br.ReadUInt32();
            Tracks = new Dat151HashPair[TrackCount];
            for (int i = 0; i < TrackCount; i++)
            {
                Tracks[i] = new Dat151HashPair(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(TrackCount);
            for (int i = 0; i < TrackCount; i++)
            {
                Tracks[i].Write(bw);
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.WriteItemArray(sb, Tracks, indent, "Tracks");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Tracks = XmlRel.ReadItemArray<Dat151HashPair>(node, "Tracks");
            TrackCount = (uint)(Tracks?.Length ?? 0);
        }
        public override MetaHash[] GetSoundHashes()
        {
            var list = new List<MetaHash>();
            if (Tracks != null)
            {
                foreach (var item in Tracks)
                {
                    list.Add(item.SoundRef);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ItemAudioSettings : Dat151RelData
    {
        public MetaHash FallBackWeapon { get; set; }
        public uint WeaponsCount { get; set; }
        public Dat151ItemAudioSettingsItem[] Weapons { get; set; }

        public Dat151ItemAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ItemAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151ItemAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            FallBackWeapon = br.ReadUInt32();
            WeaponsCount = br.ReadUInt32();

            Dat151ItemAudioSettingsItem[] items = new Dat151ItemAudioSettingsItem[WeaponsCount];
            for (int i = 0; i < WeaponsCount; i++)
            {
                items[i] = new Dat151ItemAudioSettingsItem(br);
            }
            this.Weapons = items;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);
            bw.Write(FallBackWeapon);
            bw.Write(WeaponsCount);
            for (int i = 0; i < WeaponsCount; i++)
            {
                Weapons[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "FallBackWeapon", RelXml.HashString(FallBackWeapon));
            RelXml.WriteItemArray(sb, Weapons, indent, "Weapons");
        }
        public override void ReadXml(XmlNode node)
        {
            FallBackWeapon = XmlRel.GetHash(Xml.GetChildInnerText(node, "FallBackWeapon"));
            Weapons = XmlRel.ReadItemArray<Dat151ItemAudioSettingsItem>(node, "Weapons");
            WeaponsCount = (uint)(Weapons?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            offsets.Add(0);
            for (uint i = 0; i < WeaponsCount; i++)
            {
                offsets.Add(12 + i * 8);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetCategoryHashes()
        {
            var list = new List<MetaHash>();
            if (Weapons != null)
            {
                foreach (var w in Weapons)
                {
                    list.Add(w.Category);//this doesn't seem to be an actual Category - eg player, player_backup
                }
            }
            return list.ToArray();
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            if (Weapons != null)
            {
                foreach (var w in Weapons)
                {
                    list.Add(w.Weapon);
                }
            }
            if ((Weapons?.Count(w => (w.Weapon == FallBackWeapon)) ?? 0) == 0)
            {
                list.Add(FallBackWeapon);
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public struct Dat151ItemAudioSettingsItem : IMetaXmlItem
    {
        public MetaHash Category { get; set; }
        public MetaHash Weapon { get; set; }

        public Dat151ItemAudioSettingsItem(BinaryReader br)
        {
            Category = br.ReadUInt32();
            Weapon = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Category);
            bw.Write(Weapon);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Category", RelXml.HashString(Category));
            RelXml.StringTag(sb, indent, "Weapon", RelXml.HashString(Weapon));
        }
        public void ReadXml(XmlNode node)
        {
            Category = XmlRel.GetHash(Xml.GetChildInnerText(node, "Category"));
            Weapon = XmlRel.GetHash(Xml.GetChildInnerText(node, "Weapon"));
        }
        public override string ToString()
        {
            return Category.ToString() + ": " + Weapon.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat151StartTrackAction : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public byte Constrain { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public int numTimingConstraints { get; set; }
        public MetaHash TimingConstraint1 { get; set; }
        public MetaHash TimingConstraint2 { get; set; }
        public float DelayTime { get; set; }
        public MetaHash Song { get; set; }
        public MetaHash Mood { get; set; }
        public float VolumeOffset { get; set; }
        public int FadeInTime { get; set; }
        public int FadeOutTime { get; set; }
        public float StartOffsetScalar { get; set; }
        public int LastSong { get; set; }
        public uint AltSongsCount { get; set; }
        public Dat151StartTrackActionItem[] AltSongs { get; set; }


        public Dat151StartTrackAction(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.StartTrackAction;
            TypeID = (byte)Type;
        }
        public Dat151StartTrackAction(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Constrain = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            numTimingConstraints = br.ReadInt32();
            TimingConstraint1 = br.ReadUInt32();
            TimingConstraint2 = br.ReadUInt32();
            DelayTime = br.ReadSingle();
            Song = br.ReadUInt32();
            Mood = br.ReadUInt32();
            VolumeOffset = br.ReadSingle();
            FadeInTime = br.ReadInt32();
            FadeOutTime = br.ReadInt32();
            StartOffsetScalar = br.ReadSingle();
            LastSong = br.ReadInt32();
            AltSongsCount = br.ReadUInt32();

            Dat151StartTrackActionItem[] items = new Dat151StartTrackActionItem[AltSongsCount];
            for (int i = 0; i < AltSongsCount; i++)
            {
                items[i] = new Dat151StartTrackActionItem(br);
            }
            this.AltSongs = items;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Constrain);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(numTimingConstraints);
            bw.Write(TimingConstraint1);
            bw.Write(TimingConstraint2);
            bw.Write(DelayTime);
            bw.Write(Song);
            bw.Write(Mood);
            bw.Write(VolumeOffset);
            bw.Write(FadeInTime);
            bw.Write(FadeOutTime);
            bw.Write(StartOffsetScalar);
            bw.Write(LastSong);
            bw.Write(AltSongsCount);

            for (int i = 0; i < AltSongsCount; i++)
            {
                AltSongs[i].Write(bw);
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Constrain", Constrain.ToString());
            RelXml.ValueTag(sb, indent, "numTimingConstraints", numTimingConstraints.ToString());
            RelXml.StringTag(sb, indent, "TimingConstraint1", RelXml.HashString(TimingConstraint1));
            RelXml.StringTag(sb, indent, "TimingConstraint2", RelXml.HashString(TimingConstraint2));
            RelXml.ValueTag(sb, indent, "DelayTime", FloatUtil.ToString(DelayTime));
            RelXml.StringTag(sb, indent, "Song", RelXml.HashString(Song));
            RelXml.StringTag(sb, indent, "Mood", RelXml.HashString(Mood));
            RelXml.ValueTag(sb, indent, "VolumeOffset", FloatUtil.ToString(VolumeOffset));
            RelXml.ValueTag(sb, indent, "FadeInTime", FadeInTime.ToString());
            RelXml.ValueTag(sb, indent, "FadeOutTime", FadeOutTime.ToString());
            RelXml.ValueTag(sb, indent, "StartOffsetScalar", FloatUtil.ToString(StartOffsetScalar));
            RelXml.ValueTag(sb, indent, "LastSong", LastSong.ToString());
            RelXml.WriteItemArray(sb, AltSongs, indent, "AltSongs");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Constrain = (byte)Xml.GetChildIntAttribute(node, "Constrain", "value");
            numTimingConstraints = Xml.GetChildIntAttribute(node, "numTimingConstraints", "value");
            TimingConstraint1 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint1"));
            TimingConstraint2 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint2"));
            DelayTime = Xml.GetChildFloatAttribute(node, "DelayTime", "value");
            Song = XmlRel.GetHash(Xml.GetChildInnerText(node, "Song"));
            Mood = XmlRel.GetHash(Xml.GetChildInnerText(node, "Mood"));
            VolumeOffset = Xml.GetChildFloatAttribute(node, "VolumeOffset", "value");
            FadeInTime = Xml.GetChildIntAttribute(node, "FadeInTime", "value");
            FadeOutTime = Xml.GetChildIntAttribute(node, "FadeOutTime", "value");
            StartOffsetScalar = Xml.GetChildFloatAttribute(node, "StartOffsetScalar", "value");
            LastSong = Xml.GetChildIntAttribute(node, "LastSong", "value");
            AltSongs = XmlRel.ReadItemArray<Dat151StartTrackActionItem>(node, "AltSongs");
            AltSongsCount = (uint)(AltSongs?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 12, 16, 28 };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { TimingConstraint1, TimingConstraint2, Mood };
        }
        public override MetaHash[] GetSoundHashes()
        {
            var list = new List<MetaHash>();
            list.Add(Song);
            if (AltSongs != null)
            {
                foreach (var t in AltSongs)
                {
                    list.Add(t.Song);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public struct Dat151StartTrackActionItem : IMetaXmlItem
    {
        public MetaHash Song { get; set; }
        public byte ValidArea { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }

        public Dat151StartTrackActionItem(BinaryReader br)
        {
            Song = br.ReadUInt32();
            ValidArea = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Song);
            bw.Write(ValidArea);
            bw.Write(padding00);
            bw.Write(padding01);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Song", RelXml.HashString(Song));
            RelXml.ValueTag(sb, indent, "ValidArea", ValidArea.ToString());
        }
        public void ReadXml(XmlNode node)
        {
            Song = XmlRel.GetHash(Xml.GetChildInnerText(node, "Song"));
            ValidArea = (byte)Xml.GetChildIntAttribute(node, "ValidArea", "value");
        }
        public override string ToString()
        {
            return Song.ToString() + ": " + ValidArea.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat151StopTrackAction : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public byte Constrain { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public int numTimingConstraints { get; set; }
        public MetaHash TimingConstraint1 { get; set; }
        public MetaHash TimingConstraint2 { get; set; }
        public float DelayTime { get; set; }
        public int FadeTime { get; set; }

        public Dat151StopTrackAction(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.StopTrackAction;
            TypeID = (byte)Type;
        }
        public Dat151StopTrackAction(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Constrain = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            numTimingConstraints = br.ReadInt32();
            TimingConstraint1 = br.ReadUInt32();
            TimingConstraint2 = br.ReadUInt32();
            DelayTime = br.ReadSingle();
            FadeTime = br.ReadInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Constrain);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(numTimingConstraints);
            bw.Write(TimingConstraint1);
            bw.Write(TimingConstraint2);
            bw.Write(DelayTime);
            bw.Write(FadeTime);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Constrain", Constrain.ToString());
            RelXml.ValueTag(sb, indent, "numTimingConstraints", numTimingConstraints.ToString());
            RelXml.StringTag(sb, indent, "TimingConstraint1", RelXml.HashString(TimingConstraint1));
            RelXml.StringTag(sb, indent, "TimingConstraint2", RelXml.HashString(TimingConstraint2));
            RelXml.ValueTag(sb, indent, "DelayTime", FloatUtil.ToString(DelayTime));
            RelXml.ValueTag(sb, indent, "FadeTime", FadeTime.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Constrain = (byte)Xml.GetChildIntAttribute(node, "Constrain", "value");
            numTimingConstraints = Xml.GetChildIntAttribute(node, "numTimingConstraints", "value");
            TimingConstraint1 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint1"));
            TimingConstraint2 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint2"));
            DelayTime = Xml.GetChildFloatAttribute(node, "DelayTime", "value");
            FadeTime = Xml.GetChildIntAttribute(node, "FadeTime", "value");
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 12, 16 };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { TimingConstraint1, TimingConstraint2 };
        }
    }


    [TC(typeof(EXP))]
    public class Dat151InteractiveMusicMood : Dat151RelData
    {
        public FlagsUint Flags { get; set; } // rage::AudBaseObject
        public ushort FadeInTime { get; set; }
        public ushort FadeOutTime { get; set; }
        public float AmbMusicDuckingVol { get; set; }
        public uint NumStemMixes { get; set; }
        public Dat151InteractiveMusicMoodItem[] StemMixes { get; set; }

        public Dat151InteractiveMusicMood(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.InteractiveMusicMood;
            TypeID = (byte)Type;
        }
        public Dat151InteractiveMusicMood(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            FadeInTime = br.ReadUInt16();
            FadeOutTime = br.ReadUInt16();
            AmbMusicDuckingVol = br.ReadSingle();
            NumStemMixes = br.ReadUInt32();
            var items = new Dat151InteractiveMusicMoodItem[NumStemMixes];
            for (int i = 0; i < NumStemMixes; i++)
            {
                items[i] = new Dat151InteractiveMusicMoodItem(br);
            }
            StemMixes = items;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(FadeInTime);
            bw.Write(FadeOutTime);
            bw.Write(AmbMusicDuckingVol);
            bw.Write(NumStemMixes);
            for (int i = 0; i < NumStemMixes; i++)
            {
                StemMixes[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "FadeInTime", FadeInTime.ToString());
            RelXml.ValueTag(sb, indent, "FadeOutTime", FadeOutTime.ToString());
            RelXml.ValueTag(sb, indent, "AmbMusicDuckingVol", FloatUtil.ToString(AmbMusicDuckingVol));
            RelXml.WriteItemArray(sb, StemMixes, indent, "StemMixes");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            FadeInTime = (ushort)Xml.GetChildUIntAttribute(node, "FadeInTime", "value");
            FadeOutTime = (ushort)Xml.GetChildUIntAttribute(node, "FadeOutTime", "value");
            AmbMusicDuckingVol = Xml.GetChildFloatAttribute(node, "AmbMusicDuckingVol", "value");
            StemMixes = XmlRel.ReadItemArray<Dat151InteractiveMusicMoodItem>(node, "StemMixes");
            NumStemMixes = (uint)(StemMixes?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < NumStemMixes; i++)
            {
                var offs = 16 + i * 32; //offsets for each mood item's subitems
                offsets.Add(offs);
                offsets.Add(offs + 4);
                offsets.Add(offs + 24);
                offsets.Add(offs + 28);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            if (StemMixes != null)
            {
                foreach (var item in StemMixes)
                {
                    list.Add(item.StemMix);
                    list.Add(item.OnTriggerAction);
                    list.Add(item.Bar);
                    list.Add(item.Beat);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public class Dat151InteractiveMusicMoodItem : IMetaXmlItem
    {
        public MetaHash StemMix { get; set; }
        public MetaHash OnTriggerAction { get; set; }
        public float MinDuration { get; set; }
        public float MaxDuration { get; set; }
        public float FadeTime { get; set; }
        public byte Constrain { get; set; }
        public byte NumTimingConstraints { get; set; }
        public short padding00 { get; set; }
        public MetaHash Bar { get; set; }
        public MetaHash Beat { get; set; }

        public override string ToString()
        {
            return StemMix.ToString();
        }

        public Dat151InteractiveMusicMoodItem()
        {
        }
        public Dat151InteractiveMusicMoodItem(BinaryReader br)
        {
            StemMix = br.ReadUInt32();
            OnTriggerAction = br.ReadUInt32();
            MinDuration = br.ReadSingle();
            MaxDuration = br.ReadSingle();
            FadeTime = br.ReadSingle();
            Constrain = br.ReadByte();
            NumTimingConstraints = br.ReadByte();
            padding00 = br.ReadInt16();
            Bar = br.ReadUInt32();
            Beat = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(StemMix);
            bw.Write(OnTriggerAction);
            bw.Write(MinDuration);
            bw.Write(MaxDuration);
            bw.Write(FadeTime);
            bw.Write(Constrain);
            bw.Write(NumTimingConstraints);
            bw.Write(padding00);
            bw.Write(Bar);
            bw.Write(Beat);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "StemMix", RelXml.HashString(StemMix));
            RelXml.StringTag(sb, indent, "OnTriggerAction", RelXml.HashString(OnTriggerAction));
            RelXml.ValueTag(sb, indent, "MinDuration", FloatUtil.ToString(MinDuration));
            RelXml.ValueTag(sb, indent, "MaxDuration", FloatUtil.ToString(MaxDuration));
            RelXml.ValueTag(sb, indent, "FadeTime", FloatUtil.ToString(FadeTime));
            RelXml.ValueTag(sb, indent, "Constrain", Constrain.ToString());
            RelXml.ValueTag(sb, indent, "NumTimingConstraints", NumTimingConstraints.ToString());
            RelXml.StringTag(sb, indent, "Bar", RelXml.HashString(Bar));
            RelXml.StringTag(sb, indent, "Beat", RelXml.HashString(Beat));
        }
        public void ReadXml(XmlNode node)
        {
            StemMix = XmlRel.GetHash(Xml.GetChildInnerText(node, "StemMix"));
            OnTriggerAction = XmlRel.GetHash(Xml.GetChildInnerText(node, "OnTriggerAction"));
            MinDuration = Xml.GetChildFloatAttribute(node, "MinDuration", "value");
            MaxDuration = Xml.GetChildFloatAttribute(node, "MaxDuration", "value");
            FadeTime = Xml.GetChildFloatAttribute(node, "FadeTime", "value");
            Constrain = (byte)Xml.GetChildIntAttribute(node, "Constrain", "value");
            NumTimingConstraints = (byte)Xml.GetChildIntAttribute(node, "NumTimingConstraints", "value");
            Bar = XmlRel.GetHash(Xml.GetChildInnerText(node, "Bar"));
            Beat = XmlRel.GetHash(Xml.GetChildInnerText(node, "Beat"));
        }
    }

    [TC(typeof(EXP))]
    public class Dat151SetMoodAction : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public uint Constrain { get; set; }
        public uint NumTimingConstraints { get; set; }
        public MetaHash Bar { get; set; }//BarConstraint
        public MetaHash Beat { get; set; }//not used but follows same pattern as TrackAction items.
        public float DelayTime { get; set; }  // rage::MusicAction end
        public MetaHash Mood { get; set; }
        public float VolumeOffset { get; set; }
        public int FadeInTime { get; set; }
        public int FadeOutTime { get; set; }

        public Dat151SetMoodAction(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.SetMoodAction;
            TypeID = (byte)Type;
        }
        public Dat151SetMoodAction(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Constrain = br.ReadUInt32();
            NumTimingConstraints = br.ReadUInt32();
            Bar = br.ReadUInt32();
            Beat = br.ReadUInt32();
            DelayTime = br.ReadSingle(); // rage::MusicAction end
            Mood = br.ReadUInt32();
            VolumeOffset = br.ReadSingle();
            FadeInTime = br.ReadInt32();
            FadeOutTime = br.ReadInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Constrain);
            bw.Write(NumTimingConstraints);
            bw.Write(Bar);
            bw.Write(Beat);
            bw.Write(DelayTime); // rage::MusicAction end
            bw.Write(Mood);
            bw.Write(VolumeOffset);
            bw.Write(FadeInTime);
            bw.Write(FadeOutTime);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Constrain", Constrain.ToString());
            RelXml.ValueTag(sb, indent, "NumTimingConstraints", NumTimingConstraints.ToString());
            RelXml.StringTag(sb, indent, "Bar", RelXml.HashString(Bar));
            RelXml.StringTag(sb, indent, "Beat", RelXml.HashString(Beat));
            RelXml.ValueTag(sb, indent, "DelayTime", FloatUtil.ToString(DelayTime));
            RelXml.StringTag(sb, indent, "Mood", RelXml.HashString(Mood));
            RelXml.ValueTag(sb, indent, "VolumeOffset", FloatUtil.ToString(VolumeOffset));
            RelXml.ValueTag(sb, indent, "FadeInTime", FadeInTime.ToString());
            RelXml.ValueTag(sb, indent, "FadeOutTime", FadeOutTime.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Constrain = Xml.GetChildUIntAttribute(node, "Constrain", "value");
            NumTimingConstraints = Xml.GetChildUIntAttribute(node, "NumTimingConstraints", "value");
            Bar = XmlRel.GetHash(Xml.GetChildInnerText(node, "Bar"));
            Beat = XmlRel.GetHash(Xml.GetChildInnerText(node, "Beat"));
            DelayTime = Xml.GetChildFloatAttribute(node, "DelayTime", "value");
            Mood = XmlRel.GetHash(Xml.GetChildInnerText(node, "Mood"));
            VolumeOffset = Xml.GetChildFloatAttribute(node, "VolumeOffset", "value");
            FadeInTime = Xml.GetChildIntAttribute(node, "FadeInTime", "value");
            FadeOutTime = Xml.GetChildIntAttribute(node, "FadeOutTime", "value");
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 12, 16, 24 };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { Bar, Beat, Mood };
        }
    }


    [TC(typeof(EXP))]
    public class Dat151MusicEvent : Dat151RelData
    {
        public uint ActionsCount { get; set; }
        public MetaHash[] Actions { get; set; }

        public Dat151MusicEvent(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.MusicEvent;
            TypeID = (byte)Type;
        }
        public Dat151MusicEvent(RelData d, BinaryReader br) : base(d, br)
        {
            ActionsCount = br.ReadUInt32();
            var tracks = new MetaHash[ActionsCount];
            for (int i = 0; i < ActionsCount; i++)
            {
                tracks[i] = br.ReadUInt32();
            }
            Actions = tracks;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(ActionsCount);
            for (int i = 0; i < ActionsCount; i++)
            {
                bw.Write(Actions[i]);
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteHashItemArray(sb, Actions, indent, "Actions");
        }
        public override void ReadXml(XmlNode node)
        {
            Actions = XmlRel.ReadHashItemArray(node, "Actions");
            ActionsCount = (uint)(Actions?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < ActionsCount; i++)
            {
                var offs = 4 + i * 4; //offsets for each audio track
                offsets.Add(offs);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetGameHashes()
        {
            return Actions;
        }
    }


    [TC(typeof(EXP))]
    public class Dat151StartOneShotAction : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public byte Constrain { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public int numTimingConstraints { get; set; }
        public MetaHash TimingConstraint1 { get; set; }
        public MetaHash TimingConstraint2 { get; set; }
        public float DelayTime { get; set; }
        public MetaHash Sound { get; set; }
        public int PreDelay { get; set; }
        public int FadeInTime { get; set; }
        public int FadeOutTime { get; set; }
        public byte SyncMarker { get; set; }
        public byte padding02 { get; set; }
        public short padding03 { get; set; }

        public Dat151StartOneShotAction(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.StartOneShotAction;
            TypeID = (byte)Type;
        }
        public Dat151StartOneShotAction(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Constrain = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            numTimingConstraints = br.ReadInt32();
            TimingConstraint1 = br.ReadUInt32();
            TimingConstraint2 = br.ReadUInt32();
            DelayTime = br.ReadSingle();
            Sound = br.ReadUInt32();
            PreDelay = br.ReadInt32();
            FadeInTime = br.ReadInt32();
            FadeOutTime = br.ReadInt32();
            SyncMarker = br.ReadByte();
            padding02 = br.ReadByte();
            padding03 = br.ReadInt16();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Constrain);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(numTimingConstraints);
            bw.Write(TimingConstraint1);
            bw.Write(TimingConstraint2);
            bw.Write(DelayTime);
            bw.Write(Sound);
            bw.Write(PreDelay);
            bw.Write(FadeInTime);
            bw.Write(FadeOutTime);
            bw.Write(SyncMarker);
            bw.Write(padding02);
            bw.Write(padding03);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Constrain", Constrain.ToString());
            RelXml.ValueTag(sb, indent, "numTimingConstraints", numTimingConstraints.ToString());
            RelXml.StringTag(sb, indent, "TimingConstraint1", RelXml.HashString(TimingConstraint1));
            RelXml.StringTag(sb, indent, "TimingConstraint2", RelXml.HashString(TimingConstraint2));
            RelXml.ValueTag(sb, indent, "DelayTime", FloatUtil.ToString(DelayTime));
            RelXml.StringTag(sb, indent, "Sound", RelXml.HashString(Sound));
            RelXml.ValueTag(sb, indent, "PreDelay", PreDelay.ToString());
            RelXml.ValueTag(sb, indent, "FadeInTime", FadeInTime.ToString());
            RelXml.ValueTag(sb, indent, "FadeOutTime", FadeOutTime.ToString());
            RelXml.ValueTag(sb, indent, "SyncMarker", SyncMarker.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Constrain = (byte)Xml.GetChildIntAttribute(node, "Constrain", "value");
            numTimingConstraints = Xml.GetChildIntAttribute(node, "numTimingConstraints", "value");
            TimingConstraint1 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint1"));
            TimingConstraint2 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint2"));
            DelayTime = Xml.GetChildFloatAttribute(node, "DelayTime", "value");
            Sound = XmlRel.GetHash(Xml.GetChildInnerText(node, "Sound"));
            PreDelay = Xml.GetChildIntAttribute(node, "PreDelay", "value");
            FadeInTime = Xml.GetChildIntAttribute(node, "FadeInTime", "value");
            FadeOutTime = Xml.GetChildIntAttribute(node, "FadeOutTime", "value");
            SyncMarker = (byte)Xml.GetChildIntAttribute(node, "SyncMarker", "value");
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 12, 16 };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { Sound };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { TimingConstraint1, TimingConstraint2 };
        }
    }


    [TC(typeof(EXP))]
    public class Dat151StopOneShotAction : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public byte Constrain { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public int numTimingConstraints { get; set; }
        public MetaHash TimingConstraint1 { get; set; }
        public MetaHash TimingConstraint2 { get; set; }
        public int DelayTime { get; set; }

        public Dat151StopOneShotAction(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.StopOneShotAction;
            TypeID = (byte)Type;
        }
        public Dat151StopOneShotAction(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Constrain = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            numTimingConstraints = br.ReadInt32();
            TimingConstraint1 = br.ReadUInt32();
            TimingConstraint2 = br.ReadUInt32();
            DelayTime = br.ReadInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Constrain);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(numTimingConstraints);
            bw.Write(TimingConstraint1);
            bw.Write(TimingConstraint2);
            bw.Write(DelayTime);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Constrain", Constrain.ToString());
            RelXml.ValueTag(sb, indent, "numTimingConstraints", numTimingConstraints.ToString());
            RelXml.StringTag(sb, indent, "TimingConstraint1", RelXml.HashString(TimingConstraint1));
            RelXml.StringTag(sb, indent, "TimingConstraint2", RelXml.HashString(TimingConstraint2));
            RelXml.ValueTag(sb, indent, "DelayTime", DelayTime.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            Constrain = (byte)Xml.GetChildIntAttribute(node, "Constrain", "value");
            numTimingConstraints = Xml.GetChildIntAttribute(node, "numTimingConstraints", "value");
            TimingConstraint1 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint1"));
            TimingConstraint2 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint2"));
            DelayTime = Xml.GetChildIntAttribute(node, "DelayTime", "value");
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 12, 16 };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { TimingConstraint1, TimingConstraint2 };
        }
    }


    [TC(typeof(EXP))]
    public class Dat151FadeInRadioAction : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public byte Constrain { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public int numTimingConstraints { get; set; }
        public MetaHash TimingConstraint1 { get; set; }
        public MetaHash TimingConstraint2 { get; set; }
        public float DelayTime { get; set; }
        public float FadeTime { get; set; }

        public Dat151FadeInRadioAction(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.FadeInRadioAction;
            TypeID = (byte)Type;
        }
        public Dat151FadeInRadioAction(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Constrain = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            numTimingConstraints = br.ReadInt32();
            TimingConstraint1 = br.ReadUInt32();
            TimingConstraint2 = br.ReadUInt32();
            DelayTime = br.ReadSingle();
            FadeTime = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Constrain);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(numTimingConstraints);
            bw.Write(TimingConstraint1);
            bw.Write(TimingConstraint2);
            bw.Write(DelayTime);
            bw.Write(FadeTime);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Constrain", Constrain.ToString());
            RelXml.ValueTag(sb, indent, "numTimingConstraints", numTimingConstraints.ToString());
            RelXml.StringTag(sb, indent, "TimingConstraint1", RelXml.HashString(TimingConstraint1));
            RelXml.StringTag(sb, indent, "TimingConstraint2", RelXml.HashString(TimingConstraint2));
            RelXml.ValueTag(sb, indent, "DelayTime", FloatUtil.ToString(DelayTime));
            RelXml.ValueTag(sb, indent, "FadeTime", FloatUtil.ToString(FadeTime));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Constrain = (byte)Xml.GetChildIntAttribute(node, "Constrain", "value");
            numTimingConstraints = Xml.GetChildIntAttribute(node, "numTimingConstraints", "value");
            TimingConstraint1 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint1"));
            TimingConstraint2 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint2"));
            DelayTime = Xml.GetChildFloatAttribute(node, "DelayTime", "value");
            FadeTime = Xml.GetChildFloatAttribute(node, "FadeTime", "value");
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 12, 16 };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { TimingConstraint1, TimingConstraint2 };
        }
    }


    [TC(typeof(EXP))]
    public class Dat151FadeOutRadioAction : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public byte Constrain { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public int numTimingConstraints { get; set; }
        public MetaHash TimingConstraint1 { get; set; }
        public MetaHash TimingConstraint2 { get; set; }
        public float DelayTime { get; set; }
        public float FadeTime { get; set; }

        public Dat151FadeOutRadioAction(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.FadeOutRadioAction;
            TypeID = (byte)Type;
        }
        public Dat151FadeOutRadioAction(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Constrain = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            numTimingConstraints = br.ReadInt32();
            TimingConstraint1 = br.ReadUInt32();
            TimingConstraint2 = br.ReadUInt32();
            DelayTime = br.ReadSingle();
            FadeTime = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Constrain);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(numTimingConstraints);
            bw.Write(TimingConstraint1);
            bw.Write(TimingConstraint2);
            bw.Write(DelayTime);
            bw.Write(FadeTime);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Constrain", Constrain.ToString());
            RelXml.ValueTag(sb, indent, "numTimingConstraints", numTimingConstraints.ToString());
            RelXml.StringTag(sb, indent, "TimingConstraint1", RelXml.HashString(TimingConstraint1));
            RelXml.StringTag(sb, indent, "TimingConstraint2", RelXml.HashString(TimingConstraint2));
            RelXml.ValueTag(sb, indent, "DelayTime", FloatUtil.ToString(DelayTime));
            RelXml.ValueTag(sb, indent, "FadeTime", FloatUtil.ToString(FadeTime));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Constrain = (byte)Xml.GetChildIntAttribute(node, "Constrain", "value");
            numTimingConstraints = Xml.GetChildIntAttribute(node, "numTimingConstraints", "value");
            TimingConstraint1 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint1"));
            TimingConstraint2 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint2"));
            DelayTime = Xml.GetChildFloatAttribute(node, "DelayTime", "value");
            FadeTime = Xml.GetChildFloatAttribute(node, "FadeTime", "value");
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 12, 16 };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { TimingConstraint1, TimingConstraint2 };
        }
    }


    [TC(typeof(EXP))] 
    public class Dat151ModelAudioCollisionSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public uint LastFragTime { get; set; }
        public uint MediumIntensity { get; set; }
        public uint HighIntensity { get; set; }
        public MetaHash BreakSound { get; set; }
        public MetaHash DestroySound { get; set; }
        public MetaHash UprootSound { get; set; }
        public MetaHash WindSounds { get; set; }
        public MetaHash SwingSound { get; set; }
        public float MinSwingVel { get; set; }
        public float MaxswingVel { get; set; }
        public MetaHash RainLoop { get; set; }
        public MetaHash ShockwaveSound { get; set; }
        public MetaHash RandomAmbient { get; set; }
        public MetaHash EntityResonance { get; set; }
        public byte Weight { get; set; }
        public byte MaterialsCount { get; set; }
        public byte padding00 { get; set; }
        public byte padding01 { get; set; }
        public MetaHash Material { get; set; }
        public Dat151ModelAudioCollisionSettingsMaterialItem[] Materials { get; set; }
        public uint FragComponentSettingsCount { get; set; }
        public MetaHash[] FragComponentSettings { get; set; }


        public Dat151ModelAudioCollisionSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ModelAudioCollisionSettings;
            TypeID = (byte)Type;
        }
        public Dat151ModelAudioCollisionSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            LastFragTime = br.ReadUInt32();
            MediumIntensity = br.ReadUInt32();
            HighIntensity = br.ReadUInt32();
            BreakSound = br.ReadUInt32();
            DestroySound = br.ReadUInt32();
            UprootSound = br.ReadUInt32();
            WindSounds = br.ReadUInt32();
            SwingSound = br.ReadUInt32();
            MinSwingVel = br.ReadSingle();
            MaxswingVel = br.ReadSingle();
            RainLoop = br.ReadUInt32();
            ShockwaveSound = br.ReadUInt32();
            RandomAmbient = br.ReadUInt32();
            EntityResonance = br.ReadUInt32();
            Weight = br.ReadByte();
            MaterialsCount = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadByte();


            if (MaterialsCount == 0)
            {
                Material = br.ReadUInt32();
            }
            else
            {
                var tracks1 = new Dat151ModelAudioCollisionSettingsMaterialItem[MaterialsCount];
                for (int i = 0; i < MaterialsCount; i++)
                {
                    tracks1[i] = new Dat151ModelAudioCollisionSettingsMaterialItem(br);
                }
                Materials = tracks1;

                FragComponentSettingsCount = br.ReadUInt32();

                var tracks2 = new MetaHash[FragComponentSettingsCount];
                for (int i = 0; i < FragComponentSettingsCount; i++)
                {
                    tracks2[i] = br.ReadUInt32();
                }
                FragComponentSettings = tracks2;
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(LastFragTime);
            bw.Write(MediumIntensity);
            bw.Write(HighIntensity);
            bw.Write(BreakSound);
            bw.Write(DestroySound);
            bw.Write(UprootSound);
            bw.Write(WindSounds);
            bw.Write(SwingSound);
            bw.Write(MinSwingVel);
            bw.Write(MaxswingVel);
            bw.Write(RainLoop);
            bw.Write(ShockwaveSound);
            bw.Write(RandomAmbient);
            bw.Write(EntityResonance);
            bw.Write(Weight);
            bw.Write(MaterialsCount);
            bw.Write(padding00);
            bw.Write(padding01);


            if (MaterialsCount == 0)
            {
                bw.Write(Material);
            }
            else
            {
                for (int i = 0; i < MaterialsCount; i++)
                {
                    Materials[i].Write(bw);
                }

                bw.Write(FragComponentSettingsCount);
                for (int i = 0; i < FragComponentSettingsCount; i++)
                {
                    bw.Write(FragComponentSettings[i]);
                }
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "LastFragTime", LastFragTime.ToString());
            RelXml.ValueTag(sb, indent, "MediumIntensity", MediumIntensity.ToString());
            RelXml.ValueTag(sb, indent, "HighIntensity", HighIntensity.ToString());
            RelXml.StringTag(sb, indent, "BreakSound", RelXml.HashString(BreakSound));
            RelXml.StringTag(sb, indent, "DestroySound", RelXml.HashString(DestroySound));
            RelXml.StringTag(sb, indent, "UprootSound", RelXml.HashString(UprootSound));
            RelXml.StringTag(sb, indent, "WindSounds", RelXml.HashString(WindSounds));
            RelXml.StringTag(sb, indent, "SwingSound", RelXml.HashString(SwingSound));
            RelXml.ValueTag(sb, indent, "MinSwingVel", FloatUtil.ToString(MinSwingVel));
            RelXml.ValueTag(sb, indent, "MaxswingVel", FloatUtil.ToString(MaxswingVel));
            RelXml.StringTag(sb, indent, "RainLoop", RelXml.HashString(RainLoop));
            RelXml.StringTag(sb, indent, "ShockwaveSound", RelXml.HashString(ShockwaveSound));
            RelXml.StringTag(sb, indent, "RandomAmbient", RelXml.HashString(RandomAmbient));
            RelXml.StringTag(sb, indent, "EntityResonance", RelXml.HashString(EntityResonance));
            RelXml.ValueTag(sb, indent, "Weight", Weight.ToString());
            if (MaterialsCount == 0)
            {
                RelXml.StringTag(sb, indent, "Material", RelXml.HashString(Material));
            }
            else
            {
                RelXml.WriteItemArray(sb, Materials, indent, "Materials");
                RelXml.WriteHashItemArray(sb, FragComponentSettings, indent, "FragComponentSettings");
            }
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            LastFragTime = Xml.GetChildUIntAttribute(node, "LastFragTime", "value");
            MediumIntensity = Xml.GetChildUIntAttribute(node, "MediumIntensity", "value");
            HighIntensity = Xml.GetChildUIntAttribute(node, "HighIntensity", "value");
            BreakSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BreakSound"));
            DestroySound = XmlRel.GetHash(Xml.GetChildInnerText(node, "DestroySound"));
            UprootSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "UprootSound"));
            WindSounds = XmlRel.GetHash(Xml.GetChildInnerText(node, "WindSounds"));
            SwingSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SwingSound"));
            MinSwingVel = Xml.GetChildFloatAttribute(node, "MinSwingVel", "value");
            MaxswingVel = Xml.GetChildFloatAttribute(node, "MaxswingVel", "value");
            RainLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "RainLoop"));
            ShockwaveSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ShockwaveSound"));
            RandomAmbient = XmlRel.GetHash(Xml.GetChildInnerText(node, "RandomAmbient"));
            EntityResonance = XmlRel.GetHash(Xml.GetChildInnerText(node, "EntityResonance"));
            Weight = (byte)Xml.GetChildUIntAttribute(node, "Weight", "value");
            Material = XmlRel.GetHash(Xml.GetChildInnerText(node, "Material"));
            Materials = XmlRel.ReadItemArray<Dat151ModelAudioCollisionSettingsMaterialItem>(node, "Materials");
            MaterialsCount = (byte)(Materials?.Length ?? 0);
            FragComponentSettings = XmlRel.ReadHashItemArray(node, "FragComponentSettings");
            FragComponentSettingsCount = (uint)(FragComponentSettings?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            uint offs = 64;
            if (MaterialsCount == 0)
            {
            }
            else
            {
                for (uint i = 0; i < MaterialsCount; i++)
                {
                    offsets.Add(offs);
                    offsets.Add(offs + 4);
                    offs += 8;
                }
                offs += 4;
                for (uint i = 0; i < FragComponentSettingsCount; i++)
                {
                    offsets.Add(offs);
                    offs += 4;
                }
            }

            return offsets.ToArray();
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { BreakSound, DestroySound, UprootSound, WindSounds, SwingSound, RainLoop, ShockwaveSound, RandomAmbient, EntityResonance };
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            list.Add(Material);
            if (Materials != null)
            {
                foreach (var item in Materials)
                {
                    list.Add(item.InputMaterial);
                    list.Add(item.OutputMaterial);
                }
            }
            if (FragComponentSettings != null)
            {
                list.AddRange(FragComponentSettings);
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public struct Dat151ModelAudioCollisionSettingsMaterialItem : IMetaXmlItem
    {
        public MetaHash InputMaterial { get; set; }
        public MetaHash OutputMaterial { get; set; }

        public Dat151ModelAudioCollisionSettingsMaterialItem(BinaryReader br)
        {
            InputMaterial = br.ReadUInt32();
            OutputMaterial = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(InputMaterial);
            bw.Write(OutputMaterial);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "InputMaterial", RelXml.HashString(InputMaterial));
            RelXml.StringTag(sb, indent, "OutputMaterial", RelXml.HashString(OutputMaterial));
        }
        public void ReadXml(XmlNode node)
        {
            InputMaterial = XmlRel.GetHash(Xml.GetChildInnerText(node, "InputMaterial"));
            OutputMaterial = XmlRel.GetHash(Xml.GetChildInnerText(node, "OutputMaterial"));
        }
        public override string ToString()
        {
            return InputMaterial.ToString() + ": " + OutputMaterial.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151DoorAudioSettingsLink : Dat151RelData
    {
        public MetaHash Door { get; set; }

        public Dat151DoorAudioSettingsLink(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.DoorAudioSettingsLink;
            TypeID = (byte)Type;
        }
        public Dat151DoorAudioSettingsLink(RelData d, BinaryReader br) : base(d, br)
        {
            Door = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Door);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Door", RelXml.HashString(Door));
        }
        public override void ReadXml(XmlNode node)
        {
            Door = XmlRel.GetHash(Xml.GetChildInnerText(node, "Door"));
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 0 };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { Door };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151CollisionMaterialSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash HardImpact { get; set; }
        public MetaHash SolidImpact { get; set; }
        public MetaHash SoftImpact { get; set; }
        public MetaHash ScrapeSound { get; set; }
        public MetaHash PedScrapeSound { get; set; }
        public MetaHash BreakSound { get; set; }
        public MetaHash DestroySound { get; set; }
        public MetaHash SettleSound { get; set; }
        public MetaHash BulletImpactSound { get; set; }
        public MetaHash AutomaticBulletImpactSound { get; set; }
        public MetaHash ShotgunBulletImpactSound { get; set; }
        public MetaHash BigVehicleImpactSound { get; set; }
        public MetaHash PedPunch { get; set; }
        public MetaHash PedKick { get; set; }
        public uint MediumIntensity { get; set; }
        public uint HighIntensity { get; set; }
        public byte Hardness { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public float MinImpulseMag { get; set; }
        public float MaxImpulseMag { get; set; }
        public byte ImpulseMagScalar { get; set; }
        public byte padding02 { get; set; }
        public short padding03 { get; set; }
        public float MaxScrapeSpeed { get; set; }
        public float MinScrapeSpeed { get; set; }
        public float ScrapeImpactMag { get; set; }
        public float MaxRollSpeed { get; set; }
        public float MinRollSpeed { get; set; }
        public float RollImpactMag { get; set; }
        public byte BulletCollisionScaling { get; set; }
        public byte padding04 { get; set; }
        public short padding05 { get; set; }
        public MetaHash FootstepCustomImpactSound { get; set; }
        public float FootstepMaterialHardness { get; set; }
        public float FootstepMaterialLoudness { get; set; }
        public MetaHash FootstepSettings { get; set; }
        public byte FootstepScaling { get; set; }
        public byte ScuffstepScaling { get; set; }
        public byte FootstepImpactScaling { get; set; }
        public byte ScuffImpactScaling { get; set; }
        public MetaHash SkiSettings { get; set; }
        public MetaHash AnimalFootstepSettings { get; set; }
        public MetaHash WetMaterialReference { get; set; }
        public MetaHash ImpactStartOffsetCurve { get; set; }
        public MetaHash ImpactVolCurve { get; set; }
        public MetaHash ScrapePitchCurve { get; set; }
        public MetaHash ScrapeVolCurve { get; set; }
        public MetaHash FastTyreRoll { get; set; }
        public MetaHash DetailTyreRoll { get; set; }
        public MetaHash MainSkid { get; set; }
        public MetaHash SideSkid { get; set; }
        public MetaHash MetalShellCasingSmall { get; set; }
        public MetaHash MetalShellCasingMedium { get; set; }
        public MetaHash MetalShellCasingLarge { get; set; }
        public MetaHash MetalShellCasingSmallSlow { get; set; }
        public MetaHash MetalShellCasingMediumSlow { get; set; }
        public MetaHash MetalShellCasingLargeSlow { get; set; }
        public MetaHash PlasticShellCasing { get; set; }
        public MetaHash PlasticShellCasingSlow { get; set; }
        public MetaHash RollSound { get; set; }
        public MetaHash RainLoop { get; set; }
        public MetaHash TyreBump { get; set; }
        public MetaHash ShockwaveSound { get; set; }
        public MetaHash RandomAmbient { get; set; }
        public MetaHash ClimbSettings { get; set; }
        public float Dirtiness { get; set; }
        public MetaHash SurfaceSettle { get; set; }
        public MetaHash RidgedSurfaceLoop { get; set; }
        public uint CollisionCount { get; set; }
        public uint CollisionCountThreshold { get; set; }
        public float VolumeThreshold { get; set; }
        public int MaterialID { get; set; }
        public MetaHash SoundSetRef { get; set; }
        public MetaHash DebrisLaunch { get; set; }
        public MetaHash DebrisLand { get; set; }
        public MetaHash OffRoadSound { get; set; }
        public float Roughness { get; set; }
        public MetaHash DebrisOnSlope { get; set; }
        public MetaHash BicycleTyreRoll { get; set; }
        public MetaHash OffRoadRumbleSound { get; set; }
        public MetaHash StealthSweetener { get; set; }
        public MetaHash Scuff { get; set; }
        public byte MaterialType { get; set; }
        public byte SurfacePriority { get; set; }
        public short padding06 { get; set; }
        public MetaHash WheelSpinLoop { get; set; }
        public MetaHash BicycleTyreGritSound { get; set; }
        public MetaHash PedSlideSound { get; set; }
        public MetaHash PedRollSound { get; set; }
        public float TimeInAirToTriggerBigLand { get; set; }
        public MetaHash MeleeOverideMaterial { get; set; }  // another CollisionMaterialSettings
        public MetaHash SelfName { get; set; }              // self reference
        public MetaHash SlowMoHardImpact { get; set; }
        public MetaHash SlowMoBulletImpactSound { get; set; }
        public MetaHash SlowMoAutomaticBulletImpactSound { get; set; }
        public MetaHash SlowMoShotgunBulletImpactSound { get; set; }
        public MetaHash SlowMoBulletImpactPreSuck { get; set; }
        public int SlowMoBulletImpactPreSuckTime { get; set; }
        public MetaHash SlowMoAutomaticBulletImpactPreSuck { get; set; }
        public int SlowMoAutomaticBulletImpactPreSuckTime { get; set; }
        public MetaHash SlowMoShotgunBulletImpactPreSuck { get; set; }
        public int SlowMoShotgunBulletImpactPreSuckTime { get; set; }

        public Dat151CollisionMaterialSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.CollisionMaterialSettings;
            TypeID = (byte)Type;
        }
        public Dat151CollisionMaterialSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            HardImpact = br.ReadUInt32();
            SolidImpact = br.ReadUInt32();
            SoftImpact = br.ReadUInt32();
            ScrapeSound = br.ReadUInt32();
            PedScrapeSound = br.ReadUInt32();
            BreakSound = br.ReadUInt32();
            DestroySound = br.ReadUInt32();
            SettleSound = br.ReadUInt32();
            BulletImpactSound = br.ReadUInt32();
            AutomaticBulletImpactSound = br.ReadUInt32();
            ShotgunBulletImpactSound = br.ReadUInt32();
            BigVehicleImpactSound = br.ReadUInt32();
            PedPunch = br.ReadUInt32();
            PedKick = br.ReadUInt32();
            MediumIntensity = br.ReadUInt32();
            HighIntensity = br.ReadUInt32();
            Hardness = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            MinImpulseMag = br.ReadSingle();
            MaxImpulseMag = br.ReadSingle();
            ImpulseMagScalar = br.ReadByte();
            padding02 = br.ReadByte();
            padding03 = br.ReadInt16();
            MaxScrapeSpeed = br.ReadSingle();
            MinScrapeSpeed = br.ReadSingle();
            ScrapeImpactMag = br.ReadSingle();
            MaxRollSpeed = br.ReadSingle();
            MinRollSpeed = br.ReadSingle();
            RollImpactMag = br.ReadSingle();
            BulletCollisionScaling = br.ReadByte();
            padding04 = br.ReadByte();
            padding05 = br.ReadInt16();
            FootstepCustomImpactSound = br.ReadUInt32();
            FootstepMaterialHardness = br.ReadSingle();
            FootstepMaterialLoudness = br.ReadSingle();
            FootstepSettings = br.ReadUInt32();
            FootstepScaling = br.ReadByte();
            ScuffstepScaling = br.ReadByte();
            FootstepImpactScaling = br.ReadByte();
            ScuffImpactScaling = br.ReadByte();
            SkiSettings = br.ReadUInt32();
            AnimalFootstepSettings = br.ReadUInt32();
            WetMaterialReference = br.ReadUInt32();
            ImpactStartOffsetCurve = br.ReadUInt32();
            ImpactVolCurve = br.ReadUInt32();
            ScrapePitchCurve = br.ReadUInt32();
            ScrapeVolCurve = br.ReadUInt32();
            FastTyreRoll = br.ReadUInt32();
            DetailTyreRoll = br.ReadUInt32();
            MainSkid = br.ReadUInt32();
            SideSkid = br.ReadUInt32();
            MetalShellCasingSmall = br.ReadUInt32();
            MetalShellCasingMedium = br.ReadUInt32();
            MetalShellCasingLarge = br.ReadUInt32();
            MetalShellCasingSmallSlow = br.ReadUInt32();
            MetalShellCasingMediumSlow = br.ReadUInt32();
            MetalShellCasingLargeSlow = br.ReadUInt32();
            PlasticShellCasing = br.ReadUInt32();
            PlasticShellCasingSlow = br.ReadUInt32();
            RollSound = br.ReadUInt32();
            RainLoop = br.ReadUInt32();
            TyreBump = br.ReadUInt32();
            ShockwaveSound = br.ReadUInt32();
            RandomAmbient = br.ReadUInt32();
            ClimbSettings = br.ReadUInt32();
            Dirtiness = br.ReadSingle();
            SurfaceSettle = br.ReadUInt32();
            RidgedSurfaceLoop = br.ReadUInt32();
            CollisionCount = br.ReadUInt32();
            CollisionCountThreshold = br.ReadUInt32();
            VolumeThreshold = br.ReadSingle();
            MaterialID = br.ReadInt32();
            SoundSetRef = br.ReadUInt32();
            DebrisLaunch = br.ReadUInt32();
            DebrisLand = br.ReadUInt32();
            OffRoadSound = br.ReadUInt32();
            Roughness = br.ReadSingle();
            DebrisOnSlope = br.ReadUInt32();
            BicycleTyreRoll = br.ReadUInt32();
            OffRoadRumbleSound = br.ReadUInt32();
            StealthSweetener = br.ReadUInt32();
            Scuff = br.ReadUInt32();

            MaterialType = br.ReadByte();
            SurfacePriority = br.ReadByte();
            padding06 = br.ReadInt16();

            WheelSpinLoop = br.ReadUInt32();
            BicycleTyreGritSound = br.ReadUInt32();
            PedSlideSound = br.ReadUInt32();
            PedRollSound = br.ReadUInt32();
            TimeInAirToTriggerBigLand = br.ReadSingle();
            MeleeOverideMaterial = br.ReadUInt32();
            SelfName = br.ReadUInt32();
            SlowMoHardImpact = br.ReadUInt32();
            SlowMoBulletImpactSound = br.ReadUInt32();
            SlowMoAutomaticBulletImpactSound = br.ReadUInt32();
            SlowMoShotgunBulletImpactSound = br.ReadUInt32();
            SlowMoBulletImpactPreSuck = br.ReadUInt32();
            SlowMoBulletImpactPreSuckTime = br.ReadInt32();
            SlowMoAutomaticBulletImpactPreSuck = br.ReadUInt32();
            SlowMoAutomaticBulletImpactPreSuckTime = br.ReadInt32();
            SlowMoShotgunBulletImpactPreSuck = br.ReadUInt32();
            SlowMoShotgunBulletImpactPreSuckTime = br.ReadInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(HardImpact);
            bw.Write(SolidImpact);
            bw.Write(SoftImpact);
            bw.Write(ScrapeSound);
            bw.Write(PedScrapeSound);
            bw.Write(BreakSound);
            bw.Write(DestroySound);
            bw.Write(SettleSound);
            bw.Write(BulletImpactSound);
            bw.Write(AutomaticBulletImpactSound);
            bw.Write(ShotgunBulletImpactSound);
            bw.Write(BigVehicleImpactSound);
            bw.Write(PedPunch);
            bw.Write(PedKick);
            bw.Write(MediumIntensity);
            bw.Write(HighIntensity);
            bw.Write(Hardness);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(MinImpulseMag);
            bw.Write(MaxImpulseMag);
            bw.Write(ImpulseMagScalar);
            bw.Write(padding02);
            bw.Write(padding03);
            bw.Write(MaxScrapeSpeed);
            bw.Write(MinScrapeSpeed);
            bw.Write(ScrapeImpactMag);
            bw.Write(MaxRollSpeed);
            bw.Write(MinRollSpeed);
            bw.Write(RollImpactMag);
            bw.Write(BulletCollisionScaling);
            bw.Write(padding04);
            bw.Write(padding05);
            bw.Write(FootstepCustomImpactSound);
            bw.Write(FootstepMaterialHardness);
            bw.Write(FootstepMaterialLoudness);
            bw.Write(FootstepSettings);
            bw.Write(FootstepScaling);
            bw.Write(ScuffstepScaling);
            bw.Write(FootstepImpactScaling);
            bw.Write(ScuffImpactScaling);
            bw.Write(SkiSettings);
            bw.Write(AnimalFootstepSettings);
            bw.Write(WetMaterialReference);
            bw.Write(ImpactStartOffsetCurve);
            bw.Write(ImpactVolCurve);
            bw.Write(ScrapePitchCurve);
            bw.Write(ScrapeVolCurve);
            bw.Write(FastTyreRoll);
            bw.Write(DetailTyreRoll);
            bw.Write(MainSkid);
            bw.Write(SideSkid);
            bw.Write(MetalShellCasingSmall);
            bw.Write(MetalShellCasingMedium);
            bw.Write(MetalShellCasingLarge);
            bw.Write(MetalShellCasingSmallSlow);
            bw.Write(MetalShellCasingMediumSlow);
            bw.Write(MetalShellCasingLargeSlow);
            bw.Write(PlasticShellCasing);
            bw.Write(PlasticShellCasingSlow);
            bw.Write(RollSound);
            bw.Write(RainLoop);
            bw.Write(TyreBump);
            bw.Write(ShockwaveSound);
            bw.Write(RandomAmbient);
            bw.Write(ClimbSettings);
            bw.Write(Dirtiness);
            bw.Write(SurfaceSettle);
            bw.Write(RidgedSurfaceLoop);
            bw.Write(CollisionCount);
            bw.Write(CollisionCountThreshold);
            bw.Write(VolumeThreshold);
            bw.Write(MaterialID);
            bw.Write(SoundSetRef);
            bw.Write(DebrisLaunch);
            bw.Write(DebrisLand);
            bw.Write(OffRoadSound);
            bw.Write(Roughness);
            bw.Write(DebrisOnSlope);
            bw.Write(BicycleTyreRoll);
            bw.Write(OffRoadRumbleSound);
            bw.Write(StealthSweetener);
            bw.Write(Scuff);

            bw.Write(MaterialType);
            bw.Write(SurfacePriority);
            bw.Write(padding06);

            bw.Write(WheelSpinLoop);
            bw.Write(BicycleTyreGritSound);
            bw.Write(PedSlideSound);
            bw.Write(PedRollSound);
            bw.Write(TimeInAirToTriggerBigLand);
            bw.Write(MeleeOverideMaterial);
            bw.Write(SelfName);
            bw.Write(SlowMoHardImpact);
            bw.Write(SlowMoBulletImpactSound);
            bw.Write(SlowMoAutomaticBulletImpactSound);
            bw.Write(SlowMoShotgunBulletImpactSound);
            bw.Write(SlowMoBulletImpactPreSuck);
            bw.Write(SlowMoBulletImpactPreSuckTime);
            bw.Write(SlowMoAutomaticBulletImpactPreSuck);
            bw.Write(SlowMoAutomaticBulletImpactPreSuckTime);
            bw.Write(SlowMoShotgunBulletImpactPreSuck);
            bw.Write(SlowMoShotgunBulletImpactPreSuckTime);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "HardImpact", RelXml.HashString(HardImpact));
            RelXml.StringTag(sb, indent, "SolidImpact", RelXml.HashString(SolidImpact));
            RelXml.StringTag(sb, indent, "SoftImpact", RelXml.HashString(SoftImpact));
            RelXml.StringTag(sb, indent, "ScrapeSound", RelXml.HashString(ScrapeSound));
            RelXml.StringTag(sb, indent, "PedScrapeSound", RelXml.HashString(PedScrapeSound));
            RelXml.StringTag(sb, indent, "BreakSound", RelXml.HashString(BreakSound));
            RelXml.StringTag(sb, indent, "DestroySound", RelXml.HashString(DestroySound));
            RelXml.StringTag(sb, indent, "SettleSound", RelXml.HashString(SettleSound));
            RelXml.StringTag(sb, indent, "BulletImpactSound", RelXml.HashString(BulletImpactSound));
            RelXml.StringTag(sb, indent, "AutomaticBulletImpactSound", RelXml.HashString(AutomaticBulletImpactSound));
            RelXml.StringTag(sb, indent, "ShotgunBulletImpactSound", RelXml.HashString(ShotgunBulletImpactSound));
            RelXml.StringTag(sb, indent, "BigVehicleImpactSound", RelXml.HashString(BigVehicleImpactSound));
            RelXml.StringTag(sb, indent, "PedPunch", RelXml.HashString(PedPunch));
            RelXml.StringTag(sb, indent, "PedKick", RelXml.HashString(PedKick));
            RelXml.ValueTag(sb, indent, "MediumIntensity", MediumIntensity.ToString());
            RelXml.ValueTag(sb, indent, "HighIntensity", HighIntensity.ToString());
            RelXml.ValueTag(sb, indent, "Hardness", Hardness.ToString());
            RelXml.ValueTag(sb, indent, "MinImpulseMag", FloatUtil.ToString(MinImpulseMag));
            RelXml.ValueTag(sb, indent, "MaxImpulseMag", FloatUtil.ToString(MaxImpulseMag));
            RelXml.ValueTag(sb, indent, "ImpulseMagScalar", ImpulseMagScalar.ToString());
            RelXml.ValueTag(sb, indent, "MaxScrapeSpeed", FloatUtil.ToString(MaxScrapeSpeed));
            RelXml.ValueTag(sb, indent, "MinScrapeSpeed", FloatUtil.ToString(MinScrapeSpeed));
            RelXml.ValueTag(sb, indent, "ScrapeImpactMag", FloatUtil.ToString(ScrapeImpactMag));
            RelXml.ValueTag(sb, indent, "MaxRollSpeed", FloatUtil.ToString(MaxRollSpeed));
            RelXml.ValueTag(sb, indent, "MinRollSpeed", FloatUtil.ToString(MinRollSpeed));
            RelXml.ValueTag(sb, indent, "RollImpactMag", FloatUtil.ToString(RollImpactMag));
            RelXml.ValueTag(sb, indent, "BulletCollisionScaling", BulletCollisionScaling.ToString());
            RelXml.StringTag(sb, indent, "FootstepCustomImpactSound", RelXml.HashString(FootstepCustomImpactSound));
            RelXml.ValueTag(sb, indent, "FootstepMaterialHardness", FloatUtil.ToString(FootstepMaterialHardness));
            RelXml.ValueTag(sb, indent, "FootstepMaterialLoudness", FloatUtil.ToString(FootstepMaterialLoudness));
            RelXml.StringTag(sb, indent, "FootstepSettings", RelXml.HashString(FootstepSettings));
            RelXml.ValueTag(sb, indent, "FootstepScaling", FootstepScaling.ToString());
            RelXml.ValueTag(sb, indent, "ScuffstepScaling", ScuffstepScaling.ToString());
            RelXml.ValueTag(sb, indent, "FootstepImpactScaling", FootstepImpactScaling.ToString());
            RelXml.ValueTag(sb, indent, "ScuffImpactScaling", ScuffImpactScaling.ToString());
            RelXml.StringTag(sb, indent, "SkiSettings", RelXml.HashString(SkiSettings));
            RelXml.StringTag(sb, indent, "AnimalFootstepSettings", RelXml.HashString(AnimalFootstepSettings));
            RelXml.StringTag(sb, indent, "WetMaterialReference", RelXml.HashString(WetMaterialReference));
            RelXml.StringTag(sb, indent, "ImpactStartOffsetCurve", RelXml.HashString(ImpactStartOffsetCurve));
            RelXml.StringTag(sb, indent, "ImpactVolCurve", RelXml.HashString(ImpactVolCurve));
            RelXml.StringTag(sb, indent, "ScrapePitchCurve", RelXml.HashString(ScrapePitchCurve));
            RelXml.StringTag(sb, indent, "ScrapeVolCurve", RelXml.HashString(ScrapeVolCurve));
            RelXml.StringTag(sb, indent, "FastTyreRoll", RelXml.HashString(FastTyreRoll));
            RelXml.StringTag(sb, indent, "DetailTyreRoll", RelXml.HashString(DetailTyreRoll));
            RelXml.StringTag(sb, indent, "MainSkid", RelXml.HashString(MainSkid));
            RelXml.StringTag(sb, indent, "SideSkid", RelXml.HashString(SideSkid));
            RelXml.StringTag(sb, indent, "MetalShellCasingSmall", RelXml.HashString(MetalShellCasingSmall));
            RelXml.StringTag(sb, indent, "MetalShellCasingMedium", RelXml.HashString(MetalShellCasingMedium));
            RelXml.StringTag(sb, indent, "MetalShellCasingLarge", RelXml.HashString(MetalShellCasingLarge));
            RelXml.StringTag(sb, indent, "MetalShellCasingSmallSlow", RelXml.HashString(MetalShellCasingSmallSlow));
            RelXml.StringTag(sb, indent, "MetalShellCasingMediumSlow", RelXml.HashString(MetalShellCasingMediumSlow));
            RelXml.StringTag(sb, indent, "MetalShellCasingLargeSlow", RelXml.HashString(MetalShellCasingLargeSlow));
            RelXml.StringTag(sb, indent, "PlasticShellCasing", RelXml.HashString(PlasticShellCasing));
            RelXml.StringTag(sb, indent, "PlasticShellCasingSlow", RelXml.HashString(PlasticShellCasingSlow));
            RelXml.StringTag(sb, indent, "RollSound", RelXml.HashString(RollSound));
            RelXml.StringTag(sb, indent, "RainLoop", RelXml.HashString(RainLoop));
            RelXml.StringTag(sb, indent, "TyreBump", RelXml.HashString(TyreBump));
            RelXml.StringTag(sb, indent, "ShockwaveSound", RelXml.HashString(ShockwaveSound));
            RelXml.StringTag(sb, indent, "RandomAmbient", RelXml.HashString(RandomAmbient));
            RelXml.StringTag(sb, indent, "ClimbSettings", RelXml.HashString(ClimbSettings));
            RelXml.ValueTag(sb, indent, "Dirtiness", FloatUtil.ToString(Dirtiness));
            RelXml.StringTag(sb, indent, "SurfaceSettle", RelXml.HashString(SurfaceSettle));
            RelXml.StringTag(sb, indent, "RidgedSurfaceLoop", RelXml.HashString(RidgedSurfaceLoop));
            RelXml.ValueTag(sb, indent, "CollisionCount", CollisionCount.ToString());
            RelXml.ValueTag(sb, indent, "CollisionCountThreshold", CollisionCountThreshold.ToString());
            RelXml.ValueTag(sb, indent, "VolumeThreshold", FloatUtil.ToString(VolumeThreshold));
            RelXml.ValueTag(sb, indent, "MaterialID", MaterialID.ToString());
            RelXml.ValueTag(sb, indent, "SoundSetRef", SoundSetRef.ToString());
            RelXml.StringTag(sb, indent, "DebrisLaunch", RelXml.HashString(DebrisLaunch));
            RelXml.StringTag(sb, indent, "DebrisLand", RelXml.HashString(DebrisLand));
            RelXml.StringTag(sb, indent, "OffRoadSound", RelXml.HashString(OffRoadSound));
            RelXml.ValueTag(sb, indent, "Roughness", FloatUtil.ToString(Roughness));
            RelXml.StringTag(sb, indent, "DebrisOnSlope", RelXml.HashString(DebrisOnSlope));
            RelXml.StringTag(sb, indent, "BicycleTyreRoll", RelXml.HashString(BicycleTyreRoll));
            RelXml.StringTag(sb, indent, "OffRoadRumbleSound", RelXml.HashString(OffRoadRumbleSound));
            RelXml.StringTag(sb, indent, "StealthSweetener", RelXml.HashString(StealthSweetener));
            RelXml.StringTag(sb, indent, "Scuff", RelXml.HashString(Scuff));
            RelXml.ValueTag(sb, indent, "MaterialType", MaterialType.ToString());
            RelXml.ValueTag(sb, indent, "SurfacePriority", SurfacePriority.ToString());
            RelXml.StringTag(sb, indent, "WheelSpinLoop", RelXml.HashString(WheelSpinLoop));
            RelXml.StringTag(sb, indent, "BicycleTyreGritSound", RelXml.HashString(BicycleTyreGritSound));
            RelXml.StringTag(sb, indent, "PedSlideSound", RelXml.HashString(PedSlideSound));
            RelXml.StringTag(sb, indent, "PedRollSound", RelXml.HashString(PedRollSound));
            RelXml.ValueTag(sb, indent, "TimeInAirToTriggerBigLand", FloatUtil.ToString(TimeInAirToTriggerBigLand));
            RelXml.StringTag(sb, indent, "MeleeOverideMaterial", RelXml.HashString(MeleeOverideMaterial));
            RelXml.StringTag(sb, indent, "SelfName", RelXml.HashString(SelfName));
            RelXml.StringTag(sb, indent, "SlowMoHardImpact", RelXml.HashString(SlowMoHardImpact));
            RelXml.StringTag(sb, indent, "SlowMoBulletImpactSound", RelXml.HashString(SlowMoBulletImpactSound));
            RelXml.StringTag(sb, indent, "SlowMoAutomaticBulletImpactSound", RelXml.HashString(SlowMoAutomaticBulletImpactSound));
            RelXml.StringTag(sb, indent, "SlowMoShotgunBulletImpactSound", RelXml.HashString(SlowMoShotgunBulletImpactSound));
            RelXml.StringTag(sb, indent, "SlowMoBulletImpactPreSuck", RelXml.HashString(SlowMoBulletImpactPreSuck));
            RelXml.ValueTag(sb, indent, "SlowMoBulletImpactPreSuckTime", SlowMoBulletImpactPreSuckTime.ToString());
            RelXml.StringTag(sb, indent, "SlowMoAutomaticBulletImpactPreSuck", RelXml.HashString(SlowMoAutomaticBulletImpactPreSuck));
            RelXml.ValueTag(sb, indent, "SlowMoAutomaticBulletImpactPreSuckTime", SlowMoAutomaticBulletImpactPreSuckTime.ToString());
            RelXml.StringTag(sb, indent, "SlowMoShotgunBulletImpactPreSuck", RelXml.HashString(SlowMoShotgunBulletImpactPreSuck));
            RelXml.ValueTag(sb, indent, "SlowMoShotgunBulletImpactPreSuckTime", SlowMoShotgunBulletImpactPreSuckTime.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            HardImpact = XmlRel.GetHash(Xml.GetChildInnerText(node, "HardImpact"));
            SolidImpact = XmlRel.GetHash(Xml.GetChildInnerText(node, "SolidImpact"));
            SoftImpact = XmlRel.GetHash(Xml.GetChildInnerText(node, "SoftImpact"));
            ScrapeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScrapeSound"));
            PedScrapeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "PedScrapeSound"));
            BreakSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BreakSound"));
            DestroySound = XmlRel.GetHash(Xml.GetChildInnerText(node, "DestroySound"));
            SettleSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SettleSound"));
            BulletImpactSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BulletImpactSound"));
            AutomaticBulletImpactSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "AutomaticBulletImpactSound"));
            ShotgunBulletImpactSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ShotgunBulletImpactSound"));
            BigVehicleImpactSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BigVehicleImpactSound"));
            PedPunch = XmlRel.GetHash(Xml.GetChildInnerText(node, "PedPunch"));
            PedKick = XmlRel.GetHash(Xml.GetChildInnerText(node, "PedKick"));
            MediumIntensity = Xml.GetChildUIntAttribute(node, "MediumIntensity", "value");
            HighIntensity = Xml.GetChildUIntAttribute(node, "HighIntensity", "value");
            Hardness = (byte)Xml.GetChildUIntAttribute(node, "Hardness", "value");
            MinImpulseMag = Xml.GetChildFloatAttribute(node, "MinImpulseMag", "value");
            MaxImpulseMag = Xml.GetChildFloatAttribute(node, "MaxImpulseMag", "value");
            ImpulseMagScalar = (byte)Xml.GetChildUIntAttribute(node, "ImpulseMagScalar", "value");
            MaxScrapeSpeed = Xml.GetChildFloatAttribute(node, "MaxScrapeSpeed", "value");
            MinScrapeSpeed = Xml.GetChildFloatAttribute(node, "MinScrapeSpeed", "value");
            ScrapeImpactMag = Xml.GetChildFloatAttribute(node, "ScrapeImpactMag", "value");
            MaxRollSpeed = Xml.GetChildFloatAttribute(node, "MaxRollSpeed", "value");
            MinRollSpeed = Xml.GetChildFloatAttribute(node, "MinRollSpeed", "value");
            RollImpactMag = Xml.GetChildFloatAttribute(node, "RollImpactMag", "value");
            BulletCollisionScaling = (byte)Xml.GetChildUIntAttribute(node, "BulletCollisionScaling", "value");
            FootstepCustomImpactSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "FootstepCustomImpactSound"));
            FootstepMaterialHardness = Xml.GetChildFloatAttribute(node, "FootstepMaterialHardness", "value");
            FootstepMaterialLoudness = Xml.GetChildFloatAttribute(node, "FootstepMaterialLoudness", "value");
            FootstepSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "FootstepSettings"));
            FootstepScaling = (byte)Xml.GetChildUIntAttribute(node, "FootstepScaling", "value");
            ScuffstepScaling = (byte)Xml.GetChildUIntAttribute(node, "ScuffstepScaling", "value");
            FootstepImpactScaling = (byte)Xml.GetChildUIntAttribute(node, "FootstepImpactScaling", "value");
            ScuffImpactScaling = (byte)Xml.GetChildUIntAttribute(node, "ScuffImpactScaling", "value");
            SkiSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "SkiSettings"));
            AnimalFootstepSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "AnimalFootstepSettings"));
            WetMaterialReference = XmlRel.GetHash(Xml.GetChildInnerText(node, "WetMaterialReference"));
            ImpactStartOffsetCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ImpactStartOffsetCurve"));
            ImpactVolCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ImpactVolCurve"));
            ScrapePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScrapePitchCurve"));
            ScrapeVolCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScrapeVolCurve"));
            FastTyreRoll = XmlRel.GetHash(Xml.GetChildInnerText(node, "FastTyreRoll"));
            DetailTyreRoll = XmlRel.GetHash(Xml.GetChildInnerText(node, "DetailTyreRoll"));
            MainSkid = XmlRel.GetHash(Xml.GetChildInnerText(node, "MainSkid"));
            SideSkid = XmlRel.GetHash(Xml.GetChildInnerText(node, "SideSkid"));
            MetalShellCasingSmall = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetalShellCasingSmall"));
            MetalShellCasingMedium = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetalShellCasingMedium"));
            MetalShellCasingLarge = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetalShellCasingLarge"));
            MetalShellCasingSmallSlow = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetalShellCasingSmallSlow"));
            MetalShellCasingMediumSlow = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetalShellCasingMediumSlow"));
            MetalShellCasingLargeSlow = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetalShellCasingLargeSlow"));
            PlasticShellCasing = XmlRel.GetHash(Xml.GetChildInnerText(node, "PlasticShellCasing"));
            PlasticShellCasingSlow = XmlRel.GetHash(Xml.GetChildInnerText(node, "PlasticShellCasingSlow"));
            RollSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RollSound"));
            RainLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "RainLoop"));
            TyreBump = XmlRel.GetHash(Xml.GetChildInnerText(node, "TyreBump"));
            ShockwaveSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ShockwaveSound"));
            RandomAmbient = XmlRel.GetHash(Xml.GetChildInnerText(node, "RandomAmbient"));
            ClimbSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "ClimbSettings"));
            Dirtiness = Xml.GetChildFloatAttribute(node, "Dirtiness", "value");
            SurfaceSettle = XmlRel.GetHash(Xml.GetChildInnerText(node, "SurfaceSettle"));
            RidgedSurfaceLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "RidgedSurfaceLoop"));
            CollisionCount = Xml.GetChildUIntAttribute(node, "CollisionCount", "value");
            CollisionCountThreshold = Xml.GetChildUIntAttribute(node, "CollisionCountThreshold", "value");
            VolumeThreshold = Xml.GetChildFloatAttribute(node, "VolumeThreshold", "value");
            MaterialID = Xml.GetChildIntAttribute(node, "MaterialID", "value");
            SoundSetRef = XmlRel.GetHash(Xml.GetChildInnerText(node, "SoundSetRef"));
            DebrisLaunch = XmlRel.GetHash(Xml.GetChildInnerText(node, "DebrisLaunch"));
            DebrisLand = XmlRel.GetHash(Xml.GetChildInnerText(node, "DebrisLand"));
            OffRoadSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "OffRoadSound"));
            Roughness = Xml.GetChildFloatAttribute(node, "Roughness", "value");
            DebrisOnSlope = XmlRel.GetHash(Xml.GetChildInnerText(node, "DebrisOnSlope"));
            BicycleTyreRoll = XmlRel.GetHash(Xml.GetChildInnerText(node, "BicycleTyreRoll"));
            OffRoadRumbleSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "OffRoadRumbleSound"));
            StealthSweetener = XmlRel.GetHash(Xml.GetChildInnerText(node, "StealthSweetener"));
            Scuff = XmlRel.GetHash(Xml.GetChildInnerText(node, "Scuff"));
            MaterialType = (byte)Xml.GetChildUIntAttribute(node, "MaterialType", "value");
            SurfacePriority = (byte)Xml.GetChildUIntAttribute(node, "SurfacePriority", "value");
            WheelSpinLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "WheelSpinLoop"));
            BicycleTyreGritSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BicycleTyreGritSound"));
            PedSlideSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "PedSlideSound"));
            PedRollSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "PedRollSound"));
            TimeInAirToTriggerBigLand = Xml.GetChildFloatAttribute(node, "TimeInAirToTriggerBigLand", "value");
            MeleeOverideMaterial = XmlRel.GetHash(Xml.GetChildInnerText(node, "MeleeOverideMaterial"));
            SelfName = XmlRel.GetHash(Xml.GetChildInnerText(node, "SelfName"));
            SlowMoHardImpact = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoHardImpact"));
            SlowMoBulletImpactSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoBulletImpactSound"));
            SlowMoAutomaticBulletImpactSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoAutomaticBulletImpactSound"));
            SlowMoShotgunBulletImpactSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoShotgunBulletImpactSound"));
            SlowMoBulletImpactPreSuck = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoBulletImpactPreSuck"));
            SlowMoBulletImpactPreSuckTime = Xml.GetChildIntAttribute(node, "SlowMoBulletImpactPreSuckTime", "value");
            SlowMoAutomaticBulletImpactPreSuck = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoAutomaticBulletImpactPreSuck"));
            SlowMoAutomaticBulletImpactPreSuckTime = Xml.GetChildIntAttribute(node, "SlowMoAutomaticBulletImpactPreSuckTime", "value");
            SlowMoShotgunBulletImpactPreSuck = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoShotgunBulletImpactPreSuck"));
            SlowMoShotgunBulletImpactPreSuckTime = Xml.GetChildIntAttribute(node, "SlowMoShotgunBulletImpactPreSuckTime", "value");

        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 124, 136, 140 };
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { ImpactStartOffsetCurve, ImpactVolCurve, ScrapePitchCurve, ScrapeVolCurve };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { HardImpact, SolidImpact, SoftImpact, ScrapeSound, PedScrapeSound, BreakSound, DestroySound, SettleSound, BulletImpactSound, AutomaticBulletImpactSound, ShotgunBulletImpactSound, BigVehicleImpactSound, PedPunch, PedKick, FootstepCustomImpactSound, 
                FastTyreRoll, DetailTyreRoll, MainSkid, SideSkid, MetalShellCasingSmall, MetalShellCasingMedium, MetalShellCasingLarge, MetalShellCasingSmallSlow, MetalShellCasingMediumSlow, MetalShellCasingLargeSlow, PlasticShellCasing, PlasticShellCasingSlow, RollSound, RainLoop, TyreBump, ShockwaveSound, RandomAmbient,
                SurfaceSettle, RidgedSurfaceLoop, DebrisLaunch, DebrisLand, OffRoadSound, DebrisOnSlope, BicycleTyreRoll, OffRoadRumbleSound, StealthSweetener, Scuff, SurfacePriority, WheelSpinLoop, BicycleTyreGritSound, PedSlideSound, PedRollSound,
                SlowMoHardImpact, SlowMoBulletImpactSound, SlowMoAutomaticBulletImpactSound, SlowMoShotgunBulletImpactSound, SlowMoBulletImpactPreSuck, SlowMoAutomaticBulletImpactPreSuck, SlowMoShotgunBulletImpactPreSuck };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { FootstepSettings, SkiSettings, AnimalFootstepSettings, ClimbSettings, MeleeOverideMaterial };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151VehicleCollisionSettings : Dat151RelData
    {
        public MetaHash MediumIntensity { get; set; }
        public MetaHash HighIntensity { get; set; }
        public MetaHash SmallScrapeImpact { get; set; }
        public MetaHash SlowScrapeImpact { get; set; }
        public MetaHash SlowScrapeLoop { get; set; }
        public MetaHash RollSound { get; set; }
        public MetaHash VehOnVehCrashSound { get; set; }
        public MetaHash HighImpactSweetenerSound { get; set; }
        public float SweetenerImpactThreshold { get; set; }
        public MetaHash ScrapePitchCurve { get; set; }
        public MetaHash ScrapeVolCurve { get; set; }
        public MetaHash SlowScrapeVolCurve { get; set; }
        public MetaHash ScrapeImpactVolCurve { get; set; }
        public MetaHash SlowScrapeImpactCurve { get; set; }
        public MetaHash ImpactStartOffsetCurve { get; set; }
        public MetaHash ImpactVolCurve { get; set; }
        public MetaHash VehicleImpactStartOffsetCurve { get; set; }
        public MetaHash VehicleImpactVolCurve { get; set; }
        public MetaHash VelocityImpactScalingCurve { get; set; }
        public MetaHash FakeImpactStartOffsetCurve { get; set; }
        public MetaHash FakeImpactVolCurve { get; set; }
        public float FakeImpactMin { get; set; }
        public float FakeImpactMax { get; set; }
        public float FakeImpactScale { get; set; }
        public float VehicleSizeScale { get; set; }
        public float FakeImpactTriggerDelta { get; set; }
        public float FakeImpactSweetenerThreshold { get; set; }
        public MetaHash DamageVolCurve { get; set; }
        public MetaHash JumpLandVolCurve { get; set; }
        public MetaHash VehicleMaterialSettings { get; set; }  // CollisionMaterialSettings
        public MetaHash DeformationSound { get; set; }
        public MetaHash ImpactDebris { get; set; }
        public MetaHash GlassDebris { get; set; }
        public MetaHash PostImpactDebris { get; set; }
        public float PedCollisionMin { get; set; }
        public float PedCollisionMax { get; set; }
        public float CollisionMin { get; set; }
        public float CollisionMax { get; set; }
        public float VehicleCollisionMin { get; set; }
        public float VehicleCollisionMax { get; set; }
        public float VehicleSweetenerThreshold { get; set; }
        public float ScrapeMin { get; set; }
        public float ScrapeMax { get; set; }
        public float DamageMin { get; set; }
        public float DamageMax { get; set; }
        public MetaHash TrainImpact { get; set; }
        public MetaHash TrainImpactLoop { get; set; }
        public MetaHash WaveImpactLoop { get; set; }
        public MetaHash FragMaterial { get; set; }
        public MetaHash WheelFragMaterial { get; set; }
        public byte NumMeleeMaterialOverrides { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public Dat151VehicleCollisionSettingsItem[] MeleeMaterialOverrides { get; set; }


        public Dat151VehicleCollisionSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.VehicleCollisionSettings;
            TypeID = (byte)Type;
        }
        public Dat151VehicleCollisionSettings(RelData d, BinaryReader br) : base(d, br)
        {
            MediumIntensity = br.ReadUInt32();
            HighIntensity = br.ReadUInt32();
            SmallScrapeImpact = br.ReadUInt32();
            SlowScrapeImpact = br.ReadUInt32();
            SlowScrapeLoop = br.ReadUInt32();
            RollSound = br.ReadUInt32();
            VehOnVehCrashSound = br.ReadUInt32();
            HighImpactSweetenerSound = br.ReadUInt32();
            SweetenerImpactThreshold = br.ReadSingle();
            ScrapePitchCurve = br.ReadUInt32();
            ScrapeVolCurve = br.ReadUInt32();
            SlowScrapeVolCurve = br.ReadUInt32();
            ScrapeImpactVolCurve = br.ReadUInt32();
            SlowScrapeImpactCurve = br.ReadUInt32();
            ImpactStartOffsetCurve = br.ReadUInt32();
            ImpactVolCurve = br.ReadUInt32();
            VehicleImpactStartOffsetCurve = br.ReadUInt32();
            VehicleImpactVolCurve = br.ReadUInt32();
            VelocityImpactScalingCurve = br.ReadUInt32();
            FakeImpactStartOffsetCurve = br.ReadUInt32();
            FakeImpactVolCurve = br.ReadUInt32();
            FakeImpactMin = br.ReadSingle();
            FakeImpactMax = br.ReadSingle();
            FakeImpactScale = br.ReadSingle();
            VehicleSizeScale = br.ReadSingle();
            FakeImpactTriggerDelta = br.ReadSingle();
            FakeImpactSweetenerThreshold = br.ReadSingle();
            DamageVolCurve = br.ReadUInt32();
            JumpLandVolCurve = br.ReadUInt32();
            VehicleMaterialSettings = br.ReadUInt32();
            DeformationSound = br.ReadUInt32();
            ImpactDebris = br.ReadUInt32();
            GlassDebris = br.ReadUInt32();
            PostImpactDebris = br.ReadUInt32();
            PedCollisionMin = br.ReadSingle();
            PedCollisionMax = br.ReadSingle();
            CollisionMin = br.ReadSingle();
            CollisionMax = br.ReadSingle();
            VehicleCollisionMin = br.ReadSingle();
            VehicleCollisionMax = br.ReadSingle();
            VehicleSweetenerThreshold = br.ReadSingle();
            ScrapeMin = br.ReadSingle();
            ScrapeMax = br.ReadSingle();
            DamageMin = br.ReadSingle();
            DamageMax = br.ReadSingle();
            TrainImpact = br.ReadUInt32();
            TrainImpactLoop = br.ReadUInt32();
            WaveImpactLoop = br.ReadUInt32();
            FragMaterial = br.ReadUInt32();
            WheelFragMaterial = br.ReadUInt32();
            NumMeleeMaterialOverrides = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            MeleeMaterialOverrides = new Dat151VehicleCollisionSettingsItem[NumMeleeMaterialOverrides];
            for (int i = 0; i < NumMeleeMaterialOverrides; i++)
            {
                MeleeMaterialOverrides[i] = new Dat151VehicleCollisionSettingsItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(MediumIntensity);
            bw.Write(HighIntensity);
            bw.Write(SmallScrapeImpact);
            bw.Write(SlowScrapeImpact);
            bw.Write(SlowScrapeLoop);
            bw.Write(RollSound);
            bw.Write(VehOnVehCrashSound);
            bw.Write(HighImpactSweetenerSound);
            bw.Write(SweetenerImpactThreshold);
            bw.Write(ScrapePitchCurve);
            bw.Write(ScrapeVolCurve);
            bw.Write(SlowScrapeVolCurve);
            bw.Write(ScrapeImpactVolCurve);
            bw.Write(SlowScrapeImpactCurve);
            bw.Write(ImpactStartOffsetCurve);
            bw.Write(ImpactVolCurve);
            bw.Write(VehicleImpactStartOffsetCurve);
            bw.Write(VehicleImpactVolCurve);
            bw.Write(VelocityImpactScalingCurve);
            bw.Write(FakeImpactStartOffsetCurve);
            bw.Write(FakeImpactVolCurve);
            bw.Write(FakeImpactMin);
            bw.Write(FakeImpactMax);
            bw.Write(FakeImpactScale);
            bw.Write(VehicleSizeScale);
            bw.Write(FakeImpactTriggerDelta);
            bw.Write(FakeImpactSweetenerThreshold);
            bw.Write(DamageVolCurve);
            bw.Write(JumpLandVolCurve);
            bw.Write(VehicleMaterialSettings);
            bw.Write(DeformationSound);
            bw.Write(ImpactDebris);
            bw.Write(GlassDebris);
            bw.Write(PostImpactDebris);
            bw.Write(PedCollisionMin);
            bw.Write(PedCollisionMax);
            bw.Write(CollisionMin);
            bw.Write(CollisionMax);
            bw.Write(VehicleCollisionMin);
            bw.Write(VehicleCollisionMax);
            bw.Write(VehicleSweetenerThreshold);
            bw.Write(ScrapeMin);
            bw.Write(ScrapeMax);
            bw.Write(DamageMin);
            bw.Write(DamageMax);
            bw.Write(TrainImpact);
            bw.Write(TrainImpactLoop);
            bw.Write(WaveImpactLoop);
            bw.Write(FragMaterial);
            bw.Write(WheelFragMaterial);
            bw.Write(NumMeleeMaterialOverrides);
            bw.Write(padding00);
            bw.Write(padding01);
            for (int i = 0; i < NumMeleeMaterialOverrides; i++)
            {
                MeleeMaterialOverrides[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "MediumIntensity", MediumIntensity.ToString());
            RelXml.ValueTag(sb, indent, "HighIntensity", HighIntensity.ToString());
            RelXml.StringTag(sb, indent, "SmallScrapeImpact", RelXml.HashString(SmallScrapeImpact));
            RelXml.StringTag(sb, indent, "SlowScrapeImpact", RelXml.HashString(SlowScrapeImpact));
            RelXml.StringTag(sb, indent, "SlowScrapeLoop", RelXml.HashString(SlowScrapeLoop));
            RelXml.StringTag(sb, indent, "RollSound", RelXml.HashString(RollSound));
            RelXml.StringTag(sb, indent, "VehOnVehCrashSound", RelXml.HashString(VehOnVehCrashSound));
            RelXml.StringTag(sb, indent, "HighImpactSweetenerSound", RelXml.HashString(HighImpactSweetenerSound));
            RelXml.ValueTag(sb, indent, "SweetenerImpactThreshold", FloatUtil.ToString(SweetenerImpactThreshold));
            RelXml.StringTag(sb, indent, "ScrapePitchCurve", RelXml.HashString(ScrapePitchCurve));
            RelXml.StringTag(sb, indent, "ScrapeVolCurve", RelXml.HashString(ScrapeVolCurve));
            RelXml.StringTag(sb, indent, "SlowScrapeVolCurve", RelXml.HashString(SlowScrapeVolCurve));
            RelXml.StringTag(sb, indent, "ScrapeImpactVolCurve", RelXml.HashString(ScrapeImpactVolCurve));
            RelXml.StringTag(sb, indent, "SlowScrapeImpactCurve", RelXml.HashString(SlowScrapeImpactCurve));
            RelXml.StringTag(sb, indent, "ImpactStartOffsetCurve", RelXml.HashString(ImpactStartOffsetCurve));
            RelXml.StringTag(sb, indent, "ImpactVolCurve", RelXml.HashString(ImpactVolCurve));
            RelXml.StringTag(sb, indent, "VehicleImpactStartOffsetCurve", RelXml.HashString(VehicleImpactStartOffsetCurve));
            RelXml.StringTag(sb, indent, "VehicleImpactVolCurve", RelXml.HashString(VehicleImpactVolCurve));
            RelXml.StringTag(sb, indent, "VelocityImpactScalingCurve", RelXml.HashString(VelocityImpactScalingCurve));
            RelXml.StringTag(sb, indent, "FakeImpactStartOffsetCurve", RelXml.HashString(FakeImpactStartOffsetCurve));
            RelXml.StringTag(sb, indent, "FakeImpactVolCurve", RelXml.HashString(FakeImpactVolCurve));
            RelXml.ValueTag(sb, indent, "FakeImpactMin", FloatUtil.ToString(FakeImpactMin));
            RelXml.ValueTag(sb, indent, "FakeImpactMax", FloatUtil.ToString(FakeImpactMax));
            RelXml.ValueTag(sb, indent, "FakeImpactScale", FloatUtil.ToString(FakeImpactScale));
            RelXml.ValueTag(sb, indent, "VehicleSizeScale", FloatUtil.ToString(VehicleSizeScale));
            RelXml.ValueTag(sb, indent, "FakeImpactTriggerDelta", FloatUtil.ToString(FakeImpactTriggerDelta));
            RelXml.ValueTag(sb, indent, "FakeImpactSweetenerThreshold", FloatUtil.ToString(FakeImpactSweetenerThreshold));
            RelXml.StringTag(sb, indent, "DamageVolCurve", RelXml.HashString(DamageVolCurve));
            RelXml.StringTag(sb, indent, "JumpLandVolCurve", RelXml.HashString(JumpLandVolCurve));
            RelXml.StringTag(sb, indent, "VehicleMaterialSettings", RelXml.HashString(VehicleMaterialSettings));
            RelXml.StringTag(sb, indent, "DeformationSound", RelXml.HashString(DeformationSound));
            RelXml.StringTag(sb, indent, "ImpactDebris", RelXml.HashString(ImpactDebris));
            RelXml.StringTag(sb, indent, "GlassDebris", RelXml.HashString(GlassDebris));
            RelXml.StringTag(sb, indent, "PostImpactDebris", RelXml.HashString(PostImpactDebris));
            RelXml.ValueTag(sb, indent, "PedCollisionMin", FloatUtil.ToString(PedCollisionMin));
            RelXml.ValueTag(sb, indent, "PedCollisionMax", FloatUtil.ToString(PedCollisionMax));
            RelXml.ValueTag(sb, indent, "CollisionMin", FloatUtil.ToString(CollisionMin));
            RelXml.ValueTag(sb, indent, "CollisionMax", FloatUtil.ToString(CollisionMax));
            RelXml.ValueTag(sb, indent, "VehicleCollisionMin", FloatUtil.ToString(VehicleCollisionMin));
            RelXml.ValueTag(sb, indent, "VehicleCollisionMax", FloatUtil.ToString(VehicleCollisionMax));
            RelXml.ValueTag(sb, indent, "VehicleSweetenerThreshold", FloatUtil.ToString(VehicleSweetenerThreshold));
            RelXml.ValueTag(sb, indent, "ScrapeMin", FloatUtil.ToString(ScrapeMin));
            RelXml.ValueTag(sb, indent, "ScrapeMax", FloatUtil.ToString(ScrapeMax));
            RelXml.ValueTag(sb, indent, "DamageMin", FloatUtil.ToString(DamageMin));
            RelXml.ValueTag(sb, indent, "DamageMax", FloatUtil.ToString(DamageMax));
            RelXml.StringTag(sb, indent, "TrainImpact", RelXml.HashString(TrainImpact));
            RelXml.StringTag(sb, indent, "TrainImpactLoop", RelXml.HashString(TrainImpactLoop));
            RelXml.StringTag(sb, indent, "WaveImpactLoop", RelXml.HashString(WaveImpactLoop));
            RelXml.StringTag(sb, indent, "FragMaterial", RelXml.HashString(FragMaterial));
            RelXml.StringTag(sb, indent, "WheelFragMaterial", RelXml.HashString(WheelFragMaterial));
            RelXml.WriteItemArray(sb, MeleeMaterialOverrides, indent, "MeleeMaterialOverrides");

        }
        public override void ReadXml(XmlNode node)
        {
            MediumIntensity = Xml.GetChildUIntAttribute(node, "MediumIntensity", "value");
            HighIntensity = Xml.GetChildUIntAttribute(node, "HighIntensity", "value");
            SmallScrapeImpact = XmlRel.GetHash(Xml.GetChildInnerText(node, "SmallScrapeImpact"));
            SlowScrapeImpact = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowScrapeImpact"));
            SlowScrapeLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowScrapeLoop"));
            RollSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RollSound"));
            VehOnVehCrashSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehOnVehCrashSound"));
            HighImpactSweetenerSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "HighImpactSweetenerSound"));
            SweetenerImpactThreshold = Xml.GetChildFloatAttribute(node, "SweetenerImpactThreshold", "value");
            ScrapePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScrapePitchCurve"));
            ScrapeVolCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScrapeVolCurve"));
            SlowScrapeVolCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowScrapeVolCurve"));
            ScrapeImpactVolCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScrapeImpactVolCurve"));
            SlowScrapeImpactCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowScrapeImpactCurve"));
            ImpactStartOffsetCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ImpactStartOffsetCurve"));
            ImpactVolCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ImpactVolCurve"));
            VehicleImpactStartOffsetCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleImpactStartOffsetCurve"));
            VehicleImpactVolCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleImpactVolCurve"));
            VelocityImpactScalingCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "VelocityImpactScalingCurve"));
            FakeImpactStartOffsetCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "FakeImpactStartOffsetCurve"));
            FakeImpactVolCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "FakeImpactVolCurve"));
            FakeImpactMin = Xml.GetChildFloatAttribute(node, "FakeImpactMin", "value");
            FakeImpactMax = Xml.GetChildFloatAttribute(node, "FakeImpactMax", "value");
            FakeImpactScale = Xml.GetChildFloatAttribute(node, "FakeImpactScale", "value");
            VehicleSizeScale = Xml.GetChildFloatAttribute(node, "VehicleSizeScale", "value");
            FakeImpactTriggerDelta = Xml.GetChildFloatAttribute(node, "FakeImpactTriggerDelta", "value");
            FakeImpactSweetenerThreshold = Xml.GetChildFloatAttribute(node, "FakeImpactSweetenerThreshold", "value");
            DamageVolCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DamageVolCurve"));
            JumpLandVolCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "JumpLandVolCurve"));
            VehicleMaterialSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleMaterialSettings"));
            DeformationSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "DeformationSound"));
            ImpactDebris = XmlRel.GetHash(Xml.GetChildInnerText(node, "ImpactDebris"));
            GlassDebris = XmlRel.GetHash(Xml.GetChildInnerText(node, "GlassDebris"));
            PostImpactDebris = XmlRel.GetHash(Xml.GetChildInnerText(node, "PostImpactDebris"));
            PedCollisionMin = Xml.GetChildFloatAttribute(node, "PedCollisionMin", "value");
            PedCollisionMax = Xml.GetChildFloatAttribute(node, "PedCollisionMax", "value");
            CollisionMin = Xml.GetChildFloatAttribute(node, "CollisionMin", "value");
            CollisionMax = Xml.GetChildFloatAttribute(node, "CollisionMax", "value");
            VehicleCollisionMin = Xml.GetChildFloatAttribute(node, "VehicleCollisionMin", "value");
            VehicleCollisionMax = Xml.GetChildFloatAttribute(node, "VehicleCollisionMax", "value");
            VehicleSweetenerThreshold = Xml.GetChildFloatAttribute(node, "VehicleSweetenerThreshold", "value");
            ScrapeMin = Xml.GetChildFloatAttribute(node, "ScrapeMin", "value");
            ScrapeMax = Xml.GetChildFloatAttribute(node, "ScrapeMax", "value");
            DamageMin = Xml.GetChildFloatAttribute(node, "DamageMin", "value");
            DamageMax = Xml.GetChildFloatAttribute(node, "DamageMax", "value");
            TrainImpact = XmlRel.GetHash(Xml.GetChildInnerText(node, "TrainImpact"));
            TrainImpactLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "TrainImpactLoop"));
            WaveImpactLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "WaveImpactLoop"));
            FragMaterial = XmlRel.GetHash(Xml.GetChildInnerText(node, "FragMaterial"));
            WheelFragMaterial = XmlRel.GetHash(Xml.GetChildInnerText(node, "WheelFragMaterial"));
            MeleeMaterialOverrides = XmlRel.ReadItemArray<Dat151VehicleCollisionSettingsItem>(node, "MeleeMaterialOverrides");
            NumMeleeMaterialOverrides = (byte)(MeleeMaterialOverrides?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            if (NumMeleeMaterialOverrides > 0) return new uint[] { 204, 208 };
            else return null;
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { ScrapePitchCurve, ScrapeVolCurve, SlowScrapeVolCurve, ScrapeImpactVolCurve, SlowScrapeImpactCurve, ImpactStartOffsetCurve,
                ImpactVolCurve, VehicleImpactStartOffsetCurve, VehicleImpactVolCurve, VelocityImpactScalingCurve, FakeImpactStartOffsetCurve,
                FakeImpactVolCurve, DamageVolCurve, JumpLandVolCurve };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { SmallScrapeImpact, SlowScrapeImpact, SlowScrapeLoop, RollSound, VehOnVehCrashSound,
                HighImpactSweetenerSound, DeformationSound, ImpactDebris, GlassDebris, PostImpactDebris,
                TrainImpact, TrainImpactLoop, WaveImpactLoop };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { VehicleMaterialSettings, FragMaterial, WheelFragMaterial };
        }
    }

    [TC(typeof(EXP))]
    public class Dat151VehicleCollisionSettingsItem : IMetaXmlItem
    {
        public MetaHash Material { get; set; }
        public MetaHash Override { get; set; }

        public Dat151VehicleCollisionSettingsItem()
        { }
        public Dat151VehicleCollisionSettingsItem(BinaryReader br)
        {
            Material = br.ReadUInt32();
            Override = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Material);
            bw.Write(Override);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Material", RelXml.HashString(Material));
            RelXml.StringTag(sb, indent, "Override", RelXml.HashString(Override));
        }
        public void ReadXml(XmlNode node)
        {
            Material = XmlRel.GetHash(Xml.GetChildInnerText(node, "Material"));
            Override = XmlRel.GetHash(Xml.GetChildInnerText(node, "Override"));
        }
        public override string ToString()
        {
            return Material.ToString() + ": " + Override.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151DoorAudioSettings : Dat151RelData
    {
        public MetaHash Sounds { get; set; }
        public MetaHash TuningParams { get; set; }  // Dat151DoorTuningParams
        public float MaxOcclusion { get; set; }

        public Dat151DoorAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.DoorAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151DoorAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Sounds = br.ReadUInt32();
            TuningParams = br.ReadUInt32();
            MaxOcclusion = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Sounds);
            bw.Write(TuningParams);
            bw.Write(MaxOcclusion);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Sounds", RelXml.HashString(Sounds));
            RelXml.StringTag(sb, indent, "TuningParams", RelXml.HashString(TuningParams));
            RelXml.ValueTag(sb, indent, "MaxOcclusion", FloatUtil.ToString(MaxOcclusion));
        }
        public override void ReadXml(XmlNode node)
        {
            Sounds = XmlRel.GetHash(Xml.GetChildInnerText(node, "Sounds"));
            TuningParams = XmlRel.GetHash(Xml.GetChildInnerText(node, "TuningParams"));
            MaxOcclusion = Xml.GetChildFloatAttribute(node, "MaxOcclusion", "value");
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 4 };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { Sounds };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { TuningParams };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151AnimalFootstepReference : Dat151RelData
    {
        public uint AnimalFootstepSettingsCount { get; set; }
        public Dat151AnimalFootstepReferenceItem[] AnimalFootstepSettings { get; set; }

        public Dat151AnimalFootstepReference(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.AnimalFootstepReference;
            TypeID = (byte)Type;
        }
        public Dat151AnimalFootstepReference(RelData d, BinaryReader br) : base(d, br)
        {
            AnimalFootstepSettingsCount = br.ReadUInt32();
            var items = new Dat151AnimalFootstepReferenceItem[AnimalFootstepSettingsCount];
            for (uint i = 0; i < AnimalFootstepSettingsCount; i++)
            {
                items[i] = new Dat151AnimalFootstepReferenceItem(br);
            }
            AnimalFootstepSettings = items;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(AnimalFootstepSettingsCount);
            for (uint i = 0; i < AnimalFootstepSettingsCount; i++)
            {
                AnimalFootstepSettings[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, AnimalFootstepSettings, indent, "AnimalFootstepSettings");
        }
        public override void ReadXml(XmlNode node)
        {
            AnimalFootstepSettings = XmlRel.ReadItemArray<Dat151AnimalFootstepReferenceItem>(node, "AnimalFootstepSettings");
            AnimalFootstepSettingsCount = (uint)(AnimalFootstepSettings?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < AnimalFootstepSettingsCount; i++)
            {
                offsets.Add(8 + i * 8);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            foreach (var item in AnimalFootstepSettings)
            {
                list.Add(item.Footsteps);
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public struct Dat151AnimalFootstepReferenceItem : IMetaXmlItem
    {
        public MetaHash Animal { get; set; }
        public MetaHash Footsteps { get; set; }

        public Dat151AnimalFootstepReferenceItem(BinaryReader br)
        {
            Animal = br.ReadUInt32();
            Footsteps = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Animal);
            bw.Write(Footsteps);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Animal", RelXml.HashString(Animal));
            RelXml.StringTag(sb, indent, "Footsteps", RelXml.HashString(Footsteps));
        }
        public void ReadXml(XmlNode node)
        {
            Animal = XmlRel.GetHash(Xml.GetChildInnerText(node, "Animal"));
            Footsteps = XmlRel.GetHash(Xml.GetChildInnerText(node, "Footsteps"));
        }
        public override string ToString()
        {
            return Animal.ToString() + ": " + Footsteps.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat151ForceRadioTrackAction : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public byte Constrain { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public int numTimingConstraints { get; set; }
        public MetaHash TimingConstraint1 { get; set; }
        public MetaHash TimingConstraint2 { get; set; }
        public float DelayTime { get; set; }
        public MetaHash Station { get; set; }
        public int NextIndex { get; set; }
        public byte NumTrackLists { get; set; }
        public byte padding02 { get; set; }
        public short padding03 { get; set; }
        public MetaHash[] TrackList { get; set; }

        public Dat151ForceRadioTrackAction(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ForceRadioTrackAction;
            TypeID = (byte)Type;
        }
        public Dat151ForceRadioTrackAction(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Constrain = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            numTimingConstraints = br.ReadInt32();
            TimingConstraint1 = br.ReadUInt32();
            TimingConstraint2 = br.ReadUInt32();
            DelayTime = br.ReadSingle();
            Station = br.ReadUInt32();
            NextIndex = br.ReadInt32();
            NumTrackLists = br.ReadByte();
            padding02 = br.ReadByte();
            padding03 = br.ReadInt16();
            var tracks = new MetaHash[NumTrackLists];
            for (var i = 0; i < NumTrackLists; i++)
            {
                tracks[i] = br.ReadUInt32();
            }
            TrackList = tracks;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Constrain);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(numTimingConstraints);
            bw.Write(TimingConstraint1);
            bw.Write(TimingConstraint2);
            bw.Write(DelayTime);
            bw.Write(Station);
            bw.Write(NextIndex);
            bw.Write(NumTrackLists);
            bw.Write(padding02);
            bw.Write(padding03);
            for (var i = 0; i < NumTrackLists; i++)
            {
                bw.Write(TrackList[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Constrain", Constrain.ToString());
            RelXml.ValueTag(sb, indent, "numTimingConstraints", numTimingConstraints.ToString());
            RelXml.StringTag(sb, indent, "TimingConstraint1", RelXml.HashString(TimingConstraint1));
            RelXml.StringTag(sb, indent, "TimingConstraint2", RelXml.HashString(TimingConstraint2));
            RelXml.ValueTag(sb, indent, "DelayTime", FloatUtil.ToString(DelayTime));
            RelXml.StringTag(sb, indent, "Station", RelXml.HashString(Station));
            RelXml.ValueTag(sb, indent, "NextIndex", NextIndex.ToString());
            RelXml.WriteHashItemArray(sb, TrackList, indent, "TrackList");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Constrain = (byte)Xml.GetChildIntAttribute(node, "Constrain", "value");
            numTimingConstraints = Xml.GetChildIntAttribute(node, "numTimingConstraints", "value");
            TimingConstraint1 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint1"));
            TimingConstraint2 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint2"));
            DelayTime = Xml.GetChildFloatAttribute(node, "DelayTime", "value");
            Station = XmlRel.GetHash(Xml.GetChildInnerText(node, "Station"));
            NextIndex = Xml.GetChildIntAttribute(node, "NextIndex", "value");
            TrackList = XmlRel.ReadHashItemArray(node, "TrackList");
            NumTrackLists = (byte)(TrackList?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            offsets.Add(12);
            offsets.Add(16);
            for (uint i = 0; i < NumTrackLists; i++)
            {
                offsets.Add(36 + i * 4);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            list.Add(TimingConstraint1);
            list.Add(TimingConstraint2);
            list.Add(Station);
            if (TrackList != null)
            {
                list.AddRange(TrackList);
            }
            return list.ToArray();
        }
    }


    [TC(typeof(EXP))]
    public class Dat151RadioDjSpeechAction : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public byte Constrain { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public int numTimingConstraints { get; set; }
        public MetaHash TimingConstraint1 { get; set; }
        public MetaHash TimingConstraint2 { get; set; }
        public float DelayTime { get; set; }
        public MetaHash Station { get; set; }
        public byte Category { get; set; }
        public byte padding02 { get; set; }
        public short padding03 { get; set; }

        public Dat151RadioDjSpeechAction(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.RadioDJSpeechAction;
            TypeID = (byte)Type;
        }
        public Dat151RadioDjSpeechAction(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Constrain = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            numTimingConstraints = br.ReadInt32();
            TimingConstraint1 = br.ReadUInt32();
            TimingConstraint2 = br.ReadUInt32();
            DelayTime = br.ReadSingle();
            Station = br.ReadUInt32();
            Category = br.ReadByte();
            padding02 = br.ReadByte();
            padding03 = br.ReadInt16();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Constrain);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(numTimingConstraints);
            bw.Write(TimingConstraint1);
            bw.Write(TimingConstraint2);
            bw.Write(DelayTime);
            bw.Write(Station);
            bw.Write(Category);
            bw.Write(padding02);
            bw.Write(padding03);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Constrain", Constrain.ToString());
            RelXml.ValueTag(sb, indent, "numTimingConstraints", numTimingConstraints.ToString());
            RelXml.StringTag(sb, indent, "TimingConstraint1", RelXml.HashString(TimingConstraint1));
            RelXml.StringTag(sb, indent, "TimingConstraint2", RelXml.HashString(TimingConstraint2));
            RelXml.ValueTag(sb, indent, "DelayTime", FloatUtil.ToString(DelayTime));
            RelXml.StringTag(sb, indent, "Station", RelXml.HashString(Station));
            RelXml.ValueTag(sb, indent, "Category", Category.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Constrain = (byte)Xml.GetChildIntAttribute(node, "Constrain", "value");
            numTimingConstraints = Xml.GetChildIntAttribute(node, "numTimingConstraints", "value");
            TimingConstraint1 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint1"));
            TimingConstraint2 = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimingConstraint2"));
            DelayTime = Xml.GetChildFloatAttribute(node, "DelayTime", "value");
            Station = XmlRel.GetHash(Xml.GetChildInnerText(node, "Station"));
            Category = (byte)Xml.GetChildIntAttribute(node, "Category", "value");
        }
        public override uint[] GetHashTableOffsets()
        {
            return new uint[] { 12, 16 };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { TimingConstraint1, TimingConstraint2, Station };
        }
    }


    [TC(typeof(EXP))] 
    public class Dat151MicrophoneSettingsReference : Dat151RelData
    {
        public uint MicrophonesCount { get; set; }
        public Dat151MicrophoneSettingsReferenceItem[] Microphones { get; set; }

        public Dat151MicrophoneSettingsReference(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.MicrophoneSettingsReference;
            TypeID = (byte)Type;
        }
        public Dat151MicrophoneSettingsReference(RelData d, BinaryReader br) : base(d, br)
        {
            MicrophonesCount = br.ReadUInt32();
            var items = new Dat151MicrophoneSettingsReferenceItem[MicrophonesCount];
            for (var i = 0; i < MicrophonesCount; i++)
            {
                items[i] = new Dat151MicrophoneSettingsReferenceItem(br);
            }
            Microphones = items;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(MicrophonesCount);
            for (var i = 0; i < MicrophonesCount; i++)
            {
                Microphones[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, Microphones, indent, "Microphones");
        }
        public override void ReadXml(XmlNode node)
        {
            Microphones = XmlRel.ReadItemArray<Dat151MicrophoneSettingsReferenceItem>(node, "Microphones");
            MicrophonesCount = (uint)(Microphones?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < MicrophonesCount; i++)
            {
                offsets.Add(8 + i * 8);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            if (Microphones != null)
            {
                foreach (var item in Microphones)
                {
                    list.Add(item.Microphone);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public struct Dat151MicrophoneSettingsReferenceItem : IMetaXmlItem
    {
        public MetaHash Camera { get; set; }
        public MetaHash Microphone { get; set; }

        public Dat151MicrophoneSettingsReferenceItem(BinaryReader br)
        {
            Camera = br.ReadUInt32();
            Microphone = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Camera);
            bw.Write(Microphone);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Camera", RelXml.HashString(Camera));
            RelXml.StringTag(sb, indent, "Microphone", RelXml.HashString(Microphone));
        }
        public void ReadXml(XmlNode node)
        {
            Camera = XmlRel.GetHash(Xml.GetChildInnerText(node, "Camera"));
            Microphone = XmlRel.GetHash(Xml.GetChildInnerText(node, "Microphone"));
        }
        public override string ToString()
        {
            return Camera.ToString() + ": " + Microphone.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat151DoorList : Dat151RelData
    {
        public uint DoorsCount { get; set; }
        public Dat151DoorListItem[] Doors { get; set; }  // prop name, Door

        public Dat151DoorList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.DoorList;
            TypeID = (byte)Type;
        }
        public Dat151DoorList(RelData d, BinaryReader br) : base(d, br)
        {
            DoorsCount = br.ReadUInt32();
            var items = new Dat151DoorListItem[DoorsCount];
            for (var i = 0; i < DoorsCount; i++)
            {
                items[i] = new Dat151DoorListItem(br);
            }
            Doors = items;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(DoorsCount);
            for (var i = 0; i < DoorsCount; i++)
            {
                Doors[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, Doors, indent, "Doors");
        }
        public override void ReadXml(XmlNode node)
        {
            Doors = XmlRel.ReadItemArray<Dat151DoorListItem>(node, "Doors");
            DoorsCount = (uint)(Doors?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < DoorsCount; i++)
            {
                offsets.Add(8 + i * 8);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            if (Doors != null)
            {
                foreach (var item in Doors)
                {
                    list.Add(item.Door);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public struct Dat151DoorListItem : IMetaXmlItem
    {
        public MetaHash Prop { get; set; }
        public MetaHash Door { get; set; }

        public Dat151DoorListItem(BinaryReader br)
        {
            Prop = br.ReadUInt32();
            Door = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Prop);
            bw.Write(Door);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Prop", RelXml.HashString(Prop));
            RelXml.StringTag(sb, indent, "Door", RelXml.HashString(Door));
        }
        public void ReadXml(XmlNode node)
        {
            Prop = XmlRel.GetHash(Xml.GetChildInnerText(node, "Prop"));
            Door = XmlRel.GetHash(Xml.GetChildInnerText(node, "Door"));
        }
        public override string ToString()
        {
            return Prop.ToString() + ": " + Door.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ShoeList : Dat151RelData
    {
        public uint ShoesCount { get; set; }
        public Dat151ShoeListItem[] Shoes { get; set; }  // ShoeAudioSettings

        public Dat151ShoeList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ShoeList;
            TypeID = (byte)Type;
        }
        public Dat151ShoeList(RelData d, BinaryReader br) : base(d, br)
        {
            ShoesCount = br.ReadUInt32();
            var items = new Dat151ShoeListItem[ShoesCount];
            for (var i = 0; i < ShoesCount; i++)
            {
                items[i] = new Dat151ShoeListItem(br);
            }
            Shoes = items;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(ShoesCount);
            for (var i = 0; i < ShoesCount; i++)
            {
                Shoes[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, Shoes, indent, "Shoes");
        }
        public override void ReadXml(XmlNode node)
        {
            Shoes = XmlRel.ReadItemArray<Dat151ShoeListItem>(node, "Shoes");
            ShoesCount = (uint)(Shoes?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < ShoesCount; i++)
            {
                offsets.Add(8 + i * 8);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            if (Shoes != null)
            {
                foreach (var item in Shoes)
                {
                    list.Add(item.Shoe);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public struct Dat151ShoeListItem : IMetaXmlItem
    {
        public MetaHash ShoeType { get; set; }
        public MetaHash Shoe { get; set; }

        public Dat151ShoeListItem(BinaryReader br)
        {
            ShoeType = br.ReadUInt32();
            Shoe = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(ShoeType);
            bw.Write(Shoe);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "ShoeType", RelXml.HashString(ShoeType));
            RelXml.StringTag(sb, indent, "Shoe", RelXml.HashString(Shoe));
        }
        public void ReadXml(XmlNode node)
        {
            ShoeType = XmlRel.GetHash(Xml.GetChildInnerText(node, "ShoeType"));
            Shoe = XmlRel.GetHash(Xml.GetChildInnerText(node, "Shoe"));
        }
        public override string ToString()
        {
            return ShoeType.ToString() + ": " + Shoe.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ClothList : Dat151RelData
    {
        public uint ClothesCount { get; set; }
        public Dat151ClothListItem[] Clothes { get; set; } // ClothAudioSettings

        public Dat151ClothList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ClothList;
            TypeID = (byte)Type;
        }
        public Dat151ClothList(RelData d, BinaryReader br) : base(d, br)
        {
            ClothesCount = br.ReadUInt32();
            var items = new Dat151ClothListItem[ClothesCount];
            for (var i = 0; i < ClothesCount; i++)
            {
                items[i] = new Dat151ClothListItem(br);
            }
            Clothes = items;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(ClothesCount);
            for (var i = 0; i < ClothesCount; i++)
            {
                Clothes[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, Clothes, indent, "Clothes");
        }
        public override void ReadXml(XmlNode node)
        {
            Clothes = XmlRel.ReadItemArray<Dat151ClothListItem>(node, "Clothes");
            ClothesCount = (uint)(Clothes?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < ClothesCount; i++)
            {
                offsets.Add(8 + i * 8);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            if (Clothes != null)
            {
                foreach (var item in Clothes)
                {
                    list.Add(item.Cloth);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public struct Dat151ClothListItem : IMetaXmlItem
    {
        public MetaHash ClothType { get; set; }
        public MetaHash Cloth { get; set; }

        public Dat151ClothListItem(BinaryReader br)
        {
            ClothType = br.ReadUInt32();
            Cloth = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(ClothType);
            bw.Write(Cloth);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "ClothType", RelXml.HashString(ClothType));
            RelXml.StringTag(sb, indent, "Cloth", RelXml.HashString(Cloth));
        }
        public void ReadXml(XmlNode node)
        {
            ClothType = XmlRel.GetHash(Xml.GetChildInnerText(node, "ClothType"));
            Cloth = XmlRel.GetHash(Xml.GetChildInnerText(node, "Cloth"));
        }
        public override string ToString()
        {
            return ClothType.ToString() + ": " + Cloth.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151CarRecordingList : Dat151RelData
    {
        public uint CarRecordingsCount { get; set; }
        public Dat151CarRecordingListItem[] CarRecordings { get; set; }  // CarRecordingAudioSettings

        public Dat151CarRecordingList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.CarRecordingList;
            TypeID = (byte)Type;
        }
        public Dat151CarRecordingList(RelData d, BinaryReader br) : base(d, br)
        {
            CarRecordingsCount = br.ReadUInt32();
            var items = new Dat151CarRecordingListItem[CarRecordingsCount];
            for (var i = 0; i < CarRecordingsCount; i++)
            {
                items[i] = new Dat151CarRecordingListItem(br);
            }
            CarRecordings = items;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(CarRecordingsCount);
            for (var i = 0; i < CarRecordingsCount; i++)
            {
                CarRecordings[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, CarRecordings, indent, "CarRecordings");
        }
        public override void ReadXml(XmlNode node)
        {
            CarRecordings = XmlRel.ReadItemArray<Dat151CarRecordingListItem>(node, "CarRecordings");
            CarRecordingsCount = (uint)(CarRecordings?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < CarRecordingsCount; i++)
            {
                offsets.Add(8 + i * 8);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            if (CarRecordings != null)
            {
                foreach (var item in CarRecordings)
                {
                    list.Add(item.Recording);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public struct Dat151CarRecordingListItem : IMetaXmlItem
    {
        public MetaHash ID { get; set; }
        public MetaHash Recording { get; set; }

        public Dat151CarRecordingListItem(BinaryReader br)
        {
            ID = br.ReadUInt32();
            Recording = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(ID);
            bw.Write(Recording);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "ID", RelXml.HashString(ID));
            RelXml.StringTag(sb, indent, "Recording", RelXml.HashString(Recording));
        }
        public void ReadXml(XmlNode node)
        {
            ID = XmlRel.GetHash(Xml.GetChildInnerText(node, "ID"));
            Recording = XmlRel.GetHash(Xml.GetChildInnerText(node, "Recording"));
        }
        public override string ToString()
        {
            return ID.ToString() + ": " + Recording.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151WeatherTypeAudioSettingsAudioReference : Dat151RelData
    {
        public uint WeatherTypesCount { get; set; }
        public Dat151WeatherTypeAudioSettingsAudioReferenceItem[] WeatherTypes { get; set; }   // WeatherAudioSettings

        public Dat151WeatherTypeAudioSettingsAudioReference(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.WeatherTypeAudioReference;
            TypeID = (byte)Type;
        }
        public Dat151WeatherTypeAudioSettingsAudioReference(RelData d, BinaryReader br) : base(d, br)
        {
            WeatherTypesCount = br.ReadUInt32();
            var items = new Dat151WeatherTypeAudioSettingsAudioReferenceItem[WeatherTypesCount];
            for (var i = 0; i < WeatherTypesCount; i++)
            {
                items[i] = new Dat151WeatherTypeAudioSettingsAudioReferenceItem(br);
            }
            WeatherTypes = items;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(WeatherTypesCount);
            for (var i = 0; i < WeatherTypesCount; i++)
            {
                WeatherTypes[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, WeatherTypes, indent, "WeatherTypes");
        }
        public override void ReadXml(XmlNode node)
        {
            WeatherTypes = XmlRel.ReadItemArray<Dat151WeatherTypeAudioSettingsAudioReferenceItem>(node, "WeatherTypes");
            WeatherTypesCount = (uint)(WeatherTypes?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < WeatherTypesCount; i++)
            {
                offsets.Add(8 + i * 8);
            }
            return offsets.ToArray();
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            if (WeatherTypes != null)
            {
                foreach (var item in WeatherTypes)
                {
                    list.Add(item.Weather);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public struct Dat151WeatherTypeAudioSettingsAudioReferenceItem : IMetaXmlItem
    {
        public MetaHash WeatherType { get; set; }
        public MetaHash Weather { get; set; }

        public Dat151WeatherTypeAudioSettingsAudioReferenceItem(BinaryReader br)
        {
            WeatherType = br.ReadUInt32();
            Weather = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(WeatherType);
            bw.Write(Weather);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "WeatherType", RelXml.HashString(WeatherType));
            RelXml.StringTag(sb, indent, "Weather", RelXml.HashString(Weather));
        }
        public void ReadXml(XmlNode node)
        {
            WeatherType = XmlRel.GetHash(Xml.GetChildInnerText(node, "WeatherType"));
            Weather = XmlRel.GetHash(Xml.GetChildInnerText(node, "Weather"));
        }
        public override string ToString()
        {
            return WeatherType.ToString() + ": " + Weather.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ShoreLinePoolAudioSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public Vector4 ActivationBox { get; set; }
        public float RotationAngle { get; set; }
        public int WaterLappingMinDelay { get; set; }
        public int WaterLappingMaxDelay { get; set; }
        public int WaterSplashMinDelay { get; set; }
        public int WaterSplashMaxDelay { get; set; }
        public int FirstQuadIndex { get; set; }
        public int SecondQuadIndex { get; set; }
        public int ThirdQuadIndex { get; set; }
        public int FourthQuadIndex { get; set; }
        public float SmallestDistanceToPoint { get; set; }
        public int PointsCount { get; set; }
        public Vector2[] Points { get; set; }


        public Dat151ShoreLinePoolAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ShoreLinePoolAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151ShoreLinePoolAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            ActivationBox = new Vector4(br.ReadSingle(), br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            RotationAngle = br.ReadInt32();
            WaterLappingMinDelay = br.ReadInt32();
            WaterLappingMaxDelay = br.ReadInt32();
            WaterSplashMinDelay = br.ReadInt32();
            WaterSplashMaxDelay = br.ReadInt32();
            FirstQuadIndex = br.ReadInt32();
            SecondQuadIndex = br.ReadInt32();
            ThirdQuadIndex = br.ReadInt32();
            FourthQuadIndex = br.ReadInt32();
            SmallestDistanceToPoint = br.ReadSingle();

            PointsCount = br.ReadInt32();
            var points = new Vector2[PointsCount];
            for (int i = 0; i < PointsCount; i++)
            {
                points[i] = new Vector2(br.ReadSingle(), br.ReadSingle());
            }
            Points = points;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(ActivationBox.X);
            bw.Write(ActivationBox.Y);
            bw.Write(ActivationBox.Z);
            bw.Write(ActivationBox.W);
            bw.Write(RotationAngle);
            bw.Write(WaterLappingMinDelay);
            bw.Write(WaterLappingMaxDelay);
            bw.Write(WaterSplashMinDelay);
            bw.Write(WaterSplashMaxDelay);
            bw.Write(FirstQuadIndex);
            bw.Write(SecondQuadIndex);
            bw.Write(ThirdQuadIndex);
            bw.Write(FourthQuadIndex);
            bw.Write(SmallestDistanceToPoint);

            bw.Write(PointsCount);
            for (int i = 0; i < PointsCount; i++)
            {
                bw.Write(Points[i].X);
                bw.Write(Points[i].Y);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.SelfClosingTag(sb, indent, "ActivationBox " + FloatUtil.GetVector4XmlString(ActivationBox));
            RelXml.ValueTag(sb, indent, "RotationAngle", FloatUtil.ToString(RotationAngle));
            RelXml.ValueTag(sb, indent, "WaterLappingMinDelay", WaterLappingMinDelay.ToString());
            RelXml.ValueTag(sb, indent, "WaterLappingMaxDelay", WaterLappingMaxDelay.ToString());
            RelXml.ValueTag(sb, indent, "WaterSplashMinDelay", WaterSplashMinDelay.ToString());
            RelXml.ValueTag(sb, indent, "WaterSplashMaxDelay", WaterSplashMaxDelay.ToString());
            RelXml.ValueTag(sb, indent, "FirstQuadIndex", FirstQuadIndex.ToString());
            RelXml.ValueTag(sb, indent, "SecondQuadIndex", SecondQuadIndex.ToString());
            RelXml.ValueTag(sb, indent, "ThirdQuadIndex", ThirdQuadIndex.ToString());
            RelXml.ValueTag(sb, indent, "FourthQuadIndex", FourthQuadIndex.ToString());
            RelXml.ValueTag(sb, indent, "SmallestDistanceToPoint", FloatUtil.ToString(SmallestDistanceToPoint));
            RelXml.WriteRawArray(sb, Points, indent, "Points", "", RelXml.FormatVector2, 1);
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            ActivationBox = Xml.GetChildVector4Attributes(node, "ActivationBox");
            RotationAngle = Xml.GetChildFloatAttribute(node, "RotationAngle", "value");
            WaterLappingMinDelay = Xml.GetChildIntAttribute(node, "WaterLappingMinDelay", "value");
            WaterLappingMaxDelay = Xml.GetChildIntAttribute(node, "WaterLappingMaxDelay", "value");
            WaterSplashMinDelay = Xml.GetChildIntAttribute(node, "WaterSplashMinDelay", "value");
            WaterSplashMaxDelay = Xml.GetChildIntAttribute(node, "WaterSplashMaxDelay", "value");
            FirstQuadIndex = Xml.GetChildIntAttribute(node, "FirstQuadIndex", "value");
            SecondQuadIndex = Xml.GetChildIntAttribute(node, "SecondQuadIndex", "value");
            ThirdQuadIndex = Xml.GetChildIntAttribute(node, "ThirdQuadIndex", "value");
            FourthQuadIndex = Xml.GetChildIntAttribute(node, "FourthQuadIndex", "value");
            SmallestDistanceToPoint = Xml.GetChildFloatAttribute(node, "SmallestDistanceToPoint", "value");
            Points = Xml.GetChildRawVector2Array(node, "Points");
            PointsCount = Points?.Length ?? 0;
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ShoreLineLakeAudioSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public Vector4 ActivationBox { get; set; }
        public float RotationAngle { get; set; }
        public MetaHash NextShoreline { get; set; }
        public byte LakeSize { get; set; }
        public byte NumShorelinePoints { get; set; }
        public short padding00 { get; set; }
        public Vector2[] Points { get; set; }

        public Dat151ShoreLineLakeAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ShoreLineLakeAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151ShoreLineLakeAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            ActivationBox = new Vector4(br.ReadSingle(), br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            RotationAngle = br.ReadSingle();
            NextShoreline = br.ReadUInt32();
            LakeSize = br.ReadByte();
            NumShorelinePoints = br.ReadByte();
            padding00 = br.ReadInt16();

            var points = new Vector2[NumShorelinePoints];
            for (int i = 0; i < NumShorelinePoints; i++)
            {
                points[i] = new Vector2(br.ReadSingle(), br.ReadSingle());
            }
            Points = points;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(ActivationBox.X);
            bw.Write(ActivationBox.Y);
            bw.Write(ActivationBox.Z);
            bw.Write(ActivationBox.W);
            bw.Write(RotationAngle);
            bw.Write(NextShoreline);
            bw.Write(LakeSize);
            bw.Write(NumShorelinePoints);
            bw.Write(padding00);

            for (int i = 0; i < NumShorelinePoints; i++)
            {
                bw.Write(Points[i].X);
                bw.Write(Points[i].Y);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.SelfClosingTag(sb, indent, "ActivationBox " + FloatUtil.GetVector4XmlString(ActivationBox));
            RelXml.ValueTag(sb, indent, "RotationAngle", FloatUtil.ToString(RotationAngle));
            RelXml.StringTag(sb, indent, "NextShoreline", RelXml.HashString(NextShoreline));
            RelXml.ValueTag(sb, indent, "LakeSize", LakeSize.ToString());
            RelXml.WriteRawArray(sb, Points, indent, "Points", "", RelXml.FormatVector2, 1);
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            ActivationBox = Xml.GetChildVector4Attributes(node, "ActivationBox");
            RotationAngle = Xml.GetChildFloatAttribute(node, "RotationAngle", "value");
            NextShoreline = XmlRel.GetHash(Xml.GetChildInnerText(node, "NextShoreline"));
            LakeSize = (byte)Xml.GetChildUIntAttribute(node, "LakeSize", "value");
            Points = Xml.GetChildRawVector2Array(node, "Points");
            NumShorelinePoints = (byte)(Points?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ShoreLineRiverAudioSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public Vector4 ActivationBox { get; set; }
        public float RotationAngle { get; set; }
        public MetaHash NextShoreline { get; set; }
        public byte RiverType { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public float DefaultHeight { get; set; }
        public uint PointsCount { get; set; }
        public Vector3[] Points { get; set; }

        public Dat151ShoreLineRiverAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ShoreLineRiverAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151ShoreLineRiverAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            ActivationBox = new Vector4(br.ReadSingle(), br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            RotationAngle = br.ReadSingle();
            NextShoreline = br.ReadUInt32();
            RiverType = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            DefaultHeight = br.ReadSingle();
            PointsCount = br.ReadUInt32();

            var points = new Vector3[PointsCount];
            for (int i = 0; i < PointsCount; i++)
            {
                points[i] = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            }
            Points = points;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(ActivationBox.X);
            bw.Write(ActivationBox.Y);
            bw.Write(ActivationBox.Z);
            bw.Write(ActivationBox.W);
            bw.Write(RotationAngle);
            bw.Write(NextShoreline);
            bw.Write(RiverType);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(DefaultHeight);
            bw.Write(PointsCount);

            for (int i = 0; i < PointsCount; i++)
            {
                bw.Write(Points[i].X);
                bw.Write(Points[i].Y);
                bw.Write(Points[i].Z);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.SelfClosingTag(sb, indent, "ActivationBox " + FloatUtil.GetVector4XmlString(ActivationBox));
            RelXml.ValueTag(sb, indent, "RotationAngle", FloatUtil.ToString(RotationAngle));
            RelXml.StringTag(sb, indent, "NextShoreline", RelXml.HashString(NextShoreline));
            RelXml.ValueTag(sb, indent, "RiverType", RiverType.ToString());
            RelXml.ValueTag(sb, indent, "DefaultHeight", FloatUtil.ToString(DefaultHeight));
            RelXml.WriteRawArray(sb, Points, indent, "Points", "", RelXml.FormatVector3, 1);
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            ActivationBox = Xml.GetChildVector4Attributes(node, "ActivationBox");
            RotationAngle = Xml.GetChildFloatAttribute(node, "RotationAngle", "value");
            NextShoreline = XmlRel.GetHash(Xml.GetChildInnerText(node, "NextShoreline"));
            RiverType = (byte)Xml.GetChildUIntAttribute(node, "RiverType", "value");
            DefaultHeight = Xml.GetChildFloatAttribute(node, "DefaultHeight", "value");
            Points = Xml.GetChildRawVector3Array(node, "Points");
            PointsCount = (uint)(Points?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ShoreLineOceanAudioSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public Vector4 ActivationBox { get; set; }
        public float RotationAngle { get; set; }
        public uint OceanType { get; set; }
        public MetaHash NextShoreline { get; set; }
        public float WaveStartDPDistance { get; set; }
        public float WaveStartHeight { get; set; }
        public float WaveBreaksDPDistance { get; set; }
        public float WaveBreaksHeight { get; set; }
        public float WaveEndDPDistance { get; set; }
        public float WaveEndHeight { get; set; }
        public float RecedeHeight { get; set; }
        public uint PointsCount { get; set; }
        public Vector2[] Points { get; set; }

        public Dat151ShoreLineOceanAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ShoreLineOceanAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151ShoreLineOceanAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            ActivationBox = new Vector4(br.ReadSingle(), br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            RotationAngle = br.ReadSingle();
            OceanType = br.ReadUInt32();
            NextShoreline = br.ReadUInt32();
            WaveStartDPDistance = br.ReadSingle();
            WaveStartHeight = br.ReadSingle();
            WaveBreaksDPDistance = br.ReadSingle();
            WaveBreaksHeight = br.ReadSingle();
            WaveEndDPDistance = br.ReadSingle();
            WaveEndHeight = br.ReadSingle();
            RecedeHeight = br.ReadSingle();

            PointsCount = br.ReadUInt32();

            var points = new Vector2[PointsCount];
            for (int i = 0; i < PointsCount; i++)
            {
                points[i] = new Vector2(br.ReadSingle(), br.ReadSingle());
            }
            Points = points;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(ActivationBox.X);
            bw.Write(ActivationBox.Y);
            bw.Write(ActivationBox.Z);
            bw.Write(ActivationBox.W);
            bw.Write(RotationAngle);
            bw.Write(OceanType);
            bw.Write(NextShoreline);
            bw.Write(WaveStartDPDistance);
            bw.Write(WaveStartHeight);
            bw.Write(WaveBreaksDPDistance);
            bw.Write(WaveBreaksHeight);
            bw.Write(WaveEndDPDistance);
            bw.Write(WaveEndHeight);
            bw.Write(RecedeHeight);

            bw.Write(PointsCount);

            for (int i = 0; i < PointsCount; i++)
            {
                bw.Write(Points[i].X);
                bw.Write(Points[i].Y);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.SelfClosingTag(sb, indent, "ActivationBox " + FloatUtil.GetVector4XmlString(ActivationBox));
            RelXml.ValueTag(sb, indent, "RotationAngle", FloatUtil.ToString(RotationAngle));
            RelXml.ValueTag(sb, indent, "OceanType", OceanType.ToString());
            RelXml.StringTag(sb, indent, "NextShoreline", RelXml.HashString(NextShoreline));
            RelXml.ValueTag(sb, indent, "WaveStartDPDistance", FloatUtil.ToString(WaveStartDPDistance));
            RelXml.ValueTag(sb, indent, "WaveStartHeight", FloatUtil.ToString(WaveStartHeight));
            RelXml.ValueTag(sb, indent, "WaveBreaksDPDistance", FloatUtil.ToString(WaveBreaksDPDistance));
            RelXml.ValueTag(sb, indent, "WaveBreaksHeight", FloatUtil.ToString(WaveBreaksHeight));
            RelXml.ValueTag(sb, indent, "WaveEndDPDistance", FloatUtil.ToString(WaveEndDPDistance));
            RelXml.ValueTag(sb, indent, "WaveEndHeight", FloatUtil.ToString(WaveEndHeight));
            RelXml.ValueTag(sb, indent, "RecedeHeight", FloatUtil.ToString(RecedeHeight));
            RelXml.WriteRawArray(sb, Points, indent, "Points", "", RelXml.FormatVector2, 1);
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            ActivationBox = Xml.GetChildVector4Attributes(node, "ActivationBox");
            RotationAngle = Xml.GetChildFloatAttribute(node, "RotationAngle", "value");
            OceanType = Xml.GetChildUIntAttribute(node, "OceanType", "value");
            NextShoreline = XmlRel.GetHash(Xml.GetChildInnerText(node, "NextShoreline"));
            WaveStartDPDistance = Xml.GetChildFloatAttribute(node, "WaveStartDPDistance", "value");
            WaveStartHeight = Xml.GetChildFloatAttribute(node, "WaveStartHeight", "value");
            WaveBreaksDPDistance = Xml.GetChildFloatAttribute(node, "WaveBreaksDPDistance", "value");
            WaveBreaksHeight = Xml.GetChildFloatAttribute(node, "WaveBreaksHeight", "value");
            WaveEndDPDistance = Xml.GetChildFloatAttribute(node, "WaveEndDPDistance", "value");
            WaveEndHeight = Xml.GetChildFloatAttribute(node, "WaveEndHeight", "value");
            RecedeHeight = Xml.GetChildFloatAttribute(node, "RecedeHeight", "value");
            Points = Xml.GetChildRawVector2Array(node, "Points");
            PointsCount = (uint)(Points?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ShoreLineList : Dat151RelData
    {
        public uint ShoreLineCount { get; set; }
        public MetaHash[] ShoreLines { get; set; }

        public Dat151ShoreLineList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ShoreLineList;
            TypeID = (byte)Type;
        }
        public Dat151ShoreLineList(RelData d, BinaryReader br) : base(d, br)
        {
            ShoreLineCount = br.ReadUInt32();
            var shorelines = new MetaHash[ShoreLineCount];
            for (int i = 0; i < ShoreLineCount; i++)
            {
                shorelines[i] = br.ReadUInt32();
            }
            ShoreLines = shorelines;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(ShoreLineCount);
            for (int i = 0; i < ShoreLineCount; i++)
            {
                bw.Write(ShoreLines[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteHashItemArray(sb, ShoreLines, indent, "ShoreLines");
        }
        public override void ReadXml(XmlNode node)
        {
            ShoreLines = XmlRel.ReadHashItemArray(node, "ShoreLines");
            ShoreLineCount = (uint)(ShoreLines?.Length ?? 0);
        }
        public override MetaHash[] GetGameHashes()
        {
            return ShoreLines;
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151RadioTrackTextIDs : Dat151RelData
    {
        public uint EventCount { get; set; }
        public EventData[] Events { get; set; }

        public struct EventData : IMetaXmlItem
        {
            public uint OffsetMs { get; set; }
            public uint TextId { get; set; }

            public EventData(BinaryReader br)
            {
                OffsetMs = br.ReadUInt32();
                TextId = br.ReadUInt32();
            }
            public void Write(BinaryWriter bw)
            {
                bw.Write(OffsetMs);
                bw.Write(TextId);
            }
            public void WriteXml(StringBuilder sb, int indent)
            {
                RelXml.ValueTag(sb, indent, "OffsetMs", OffsetMs.ToString());
                RelXml.ValueTag(sb, indent, "TextId", TextId.ToString());
            }
            public void ReadXml(XmlNode node)
            {
                OffsetMs = Xml.GetChildUIntAttribute(node, "OffsetMs", "value");
                TextId = Xml.GetChildUIntAttribute(node, "TextId", "value");
            }

            public override string ToString()
            {
                return OffsetMs.ToString() + ": " + TextId.ToString();
            }
        }

        public Dat151RadioTrackTextIDs(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.RadioTrackTextIDs;
            TypeID = (byte)Type;
        }
        public Dat151RadioTrackTextIDs(RelData d, BinaryReader br) : base(d, br)
        {
            EventCount = br.ReadUInt32();
            Events = new EventData[EventCount];
            for (int i = 0; i < EventCount; i++)
            {
                Events[i] = new EventData(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(EventCount);
            for (int i = 0; i < EventCount; i++)
            {
                Events[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, Events, indent, "Events");
        }
        public override void ReadXml(XmlNode node)
        {
            Events = XmlRel.ReadItemArray<EventData>(node, "Events");
            EventCount = (uint)(Events?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151GranularEngineAudioSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public int MasterVolume { get; set; }
        public MetaHash EngineAccel { get; set; }
        public MetaHash ExhaustAccel { get; set; }
        public int EngineVolume_PreSubmix { get; set; }
        public int ExhaustVolume_PreSubmix { get; set; }
        public int AccelVolume_PreSubmix { get; set; }
        public int DecelVolume_PreSubmix { get; set; }
        public int IdleVolume_PreSubmix { get; set; }
        public int EngineRevsVolume_PreSubmix { get; set; }
        public int ExhaustRevsVolume_PreSubmix { get; set; }
        public int EngineThrottleVolume_PreSubmix { get; set; }
        public int ExhaustThrottleVolume_PreSubmix { get; set; }
        public int EngineVolume_PostSubmix { get; set; }
        public int ExhaustVolume_PostSubmix { get; set; }
        public int EngineMaxConeAttenuation { get; set; }
        public int ExhaustMaxConeAttenuation { get; set; }
        public int EngineRevsVolume_PostSubmix { get; set; }
        public int ExhaustRevsVolume_PostSubmix { get; set; }
        public int EngineThrottleVolume_PostSubmix { get; set; }
        public int ExhaustThrottleVolume_PostSubmix { get; set; }
        public uint GearChangeWobbleLength { get; set; }
        public float GearChangeWobbleLengthVariance { get; set; }
        public float GearChangeWobbleSpeed { get; set; }
        public float GearChangeWobbleSpeedVariance { get; set; }
        public float GearChangeWobblePitch { get; set; }
        public float GearChangeWobblePitchVariance { get; set; }
        public float GearChangeWobbleVolume { get; set; }
        public float GearChangeWobbleVolumeVariance { get; set; }
        public int EngineClutchAttenuation_PostSubmix { get; set; }
        public int ExhaustClutchAttenuation_PostSubmix { get; set; }
        public MetaHash EngineSynthDef { get; set; }
        public MetaHash EngineSynthPreset { get; set; }
        public MetaHash ExhaustSynthDef { get; set; }
        public MetaHash ExhaustSynthPreset { get; set; }
        public MetaHash NPCEngineAccel { get; set; }
        public MetaHash NPCExhaustAccel { get; set; }
        public MetaHash RevLimiterPopSound { get; set; }
        public uint MinRPMOverride { get; set; }
        public uint MaxRPMOverride { get; set; }
        public MetaHash EngineSubmixVoice { get; set; }
        public MetaHash ExhaustSubmixVoice { get; set; }
        public int ExhaustProximityVolume_PostSubmix { get; set; }
        public uint RevLimiterGrainsToPlay { get; set; }
        public uint RevLimiterGrainsToSkip { get; set; }
        public MetaHash SynchronisedSynth { get; set; }
        public int UpgradedEngineVolumeBoost_PostSubmix { get; set; }
        public MetaHash UpgradedEngineSynthDef { get; set; }
        public MetaHash UpgradedEngineSynthPreset { get; set; }
        public int UpgradedExhaustVolumeBoost_PostSubmix { get; set; }
        public MetaHash UpgradedExhaustSynthDef { get; set; }
        public MetaHash UpgradedExhaustSynthPreset { get; set; }
        public MetaHash DamageSynthHashList { get; set; }
        public MetaHash UpgradedRevLimiterPop { get; set; }
        public int EngineIdleVolume_PostSubmix { get; set; }
        public int ExhaustIdleVolume_PostSubmix { get; set; }
        public int StartupRevsVolumeBoostEngine_PostSubmix { get; set; }
        public int StartupRevsVolumeBoostExhaust_PostSubmix { get; set; }
        public int RevLimiterApplyType { get; set; }
        public float RevLimiterVolumeCut { get; set; }

        public Dat151GranularEngineAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.GranularEngineAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151GranularEngineAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            MasterVolume = br.ReadInt32();
            EngineAccel = br.ReadUInt32();
            ExhaustAccel = br.ReadUInt32();
            EngineVolume_PreSubmix = br.ReadInt32();
            ExhaustVolume_PreSubmix = br.ReadInt32();
            AccelVolume_PreSubmix = br.ReadInt32();
            DecelVolume_PreSubmix = br.ReadInt32();
            IdleVolume_PreSubmix = br.ReadInt32();
            EngineRevsVolume_PreSubmix = br.ReadInt32();
            ExhaustRevsVolume_PreSubmix = br.ReadInt32();
            EngineThrottleVolume_PreSubmix = br.ReadInt32();
            ExhaustThrottleVolume_PreSubmix = br.ReadInt32();
            EngineVolume_PostSubmix = br.ReadInt32();
            ExhaustVolume_PostSubmix = br.ReadInt32();
            EngineMaxConeAttenuation = br.ReadInt32();
            ExhaustMaxConeAttenuation = br.ReadInt32();
            EngineRevsVolume_PostSubmix = br.ReadInt32();
            ExhaustRevsVolume_PostSubmix = br.ReadInt32();
            EngineThrottleVolume_PostSubmix = br.ReadInt32();
            ExhaustThrottleVolume_PostSubmix = br.ReadInt32();
            GearChangeWobbleLength = br.ReadUInt32();
            GearChangeWobbleLengthVariance = br.ReadSingle();
            GearChangeWobbleSpeed = br.ReadSingle();
            GearChangeWobbleSpeedVariance = br.ReadSingle();
            GearChangeWobblePitch = br.ReadSingle();
            GearChangeWobblePitchVariance = br.ReadSingle();
            GearChangeWobbleVolume = br.ReadSingle();
            GearChangeWobbleVolumeVariance = br.ReadSingle();
            EngineClutchAttenuation_PostSubmix = br.ReadInt32();
            ExhaustClutchAttenuation_PostSubmix = br.ReadInt32();
            EngineSynthDef = br.ReadUInt32();
            EngineSynthPreset = br.ReadUInt32();
            ExhaustSynthDef = br.ReadUInt32();
            ExhaustSynthPreset = br.ReadUInt32();
            NPCEngineAccel = br.ReadUInt32();
            NPCExhaustAccel = br.ReadUInt32();
            RevLimiterPopSound = br.ReadUInt32();
            MinRPMOverride = br.ReadUInt32();
            MaxRPMOverride = br.ReadUInt32();
            EngineSubmixVoice = br.ReadUInt32();
            ExhaustSubmixVoice = br.ReadUInt32();
            ExhaustProximityVolume_PostSubmix = br.ReadInt32();
            RevLimiterGrainsToPlay = br.ReadUInt32();
            RevLimiterGrainsToSkip = br.ReadUInt32();
            SynchronisedSynth = br.ReadUInt32();
            UpgradedEngineVolumeBoost_PostSubmix = br.ReadInt32();
            UpgradedEngineSynthDef = br.ReadUInt32();
            UpgradedEngineSynthPreset = br.ReadUInt32();
            UpgradedExhaustVolumeBoost_PostSubmix = br.ReadInt32();
            UpgradedExhaustSynthDef = br.ReadUInt32();
            UpgradedExhaustSynthPreset = br.ReadUInt32();
            DamageSynthHashList = br.ReadUInt32();
            UpgradedRevLimiterPop = br.ReadUInt32();
            EngineIdleVolume_PostSubmix = br.ReadInt32();
            ExhaustIdleVolume_PostSubmix = br.ReadInt32();
            StartupRevsVolumeBoostEngine_PostSubmix = br.ReadInt32();
            StartupRevsVolumeBoostExhaust_PostSubmix = br.ReadInt32();


            var bytesleft = br.BaseStream.Length - br.BaseStream.Position;
            switch (bytesleft) // Check for any left over bytes
            {
                case 0: // if 0 bytes left, end
                    break;
                case 8: // if 8 bytes left, read additional values
                    RevLimiterApplyType = br.ReadInt32();
                    RevLimiterVolumeCut = br.ReadSingle();
                    break;
                default:
                    break;
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);
            bw.Write(Flags);
            bw.Write(MasterVolume);
            bw.Write(EngineAccel);
            bw.Write(ExhaustAccel);
            bw.Write(EngineVolume_PreSubmix);
            bw.Write(ExhaustVolume_PreSubmix);
            bw.Write(AccelVolume_PreSubmix);
            bw.Write(DecelVolume_PreSubmix);
            bw.Write(IdleVolume_PreSubmix);
            bw.Write(EngineRevsVolume_PreSubmix);
            bw.Write(ExhaustRevsVolume_PreSubmix);
            bw.Write(EngineThrottleVolume_PreSubmix);
            bw.Write(ExhaustThrottleVolume_PreSubmix);
            bw.Write(EngineVolume_PostSubmix);
            bw.Write(ExhaustVolume_PostSubmix);
            bw.Write(EngineMaxConeAttenuation);
            bw.Write(ExhaustMaxConeAttenuation);
            bw.Write(EngineRevsVolume_PostSubmix);
            bw.Write(ExhaustRevsVolume_PostSubmix);
            bw.Write(EngineThrottleVolume_PostSubmix);
            bw.Write(ExhaustThrottleVolume_PostSubmix);
            bw.Write(GearChangeWobbleLength);
            bw.Write(GearChangeWobbleLengthVariance);
            bw.Write(GearChangeWobbleSpeed);
            bw.Write(GearChangeWobbleSpeedVariance);
            bw.Write(GearChangeWobblePitch);
            bw.Write(GearChangeWobblePitchVariance);
            bw.Write(GearChangeWobbleVolume);
            bw.Write(GearChangeWobbleVolumeVariance);
            bw.Write(EngineClutchAttenuation_PostSubmix);
            bw.Write(ExhaustClutchAttenuation_PostSubmix);
            bw.Write(EngineSynthDef);
            bw.Write(EngineSynthPreset);
            bw.Write(ExhaustSynthDef);
            bw.Write(ExhaustSynthPreset);
            bw.Write(NPCEngineAccel);
            bw.Write(NPCExhaustAccel);
            bw.Write(RevLimiterPopSound);
            bw.Write(MinRPMOverride);
            bw.Write(MaxRPMOverride);
            bw.Write(EngineSubmixVoice);
            bw.Write(ExhaustSubmixVoice);
            bw.Write(ExhaustProximityVolume_PostSubmix);
            bw.Write(RevLimiterGrainsToPlay);
            bw.Write(RevLimiterGrainsToSkip);
            bw.Write(SynchronisedSynth);
            bw.Write(UpgradedEngineVolumeBoost_PostSubmix);
            bw.Write(UpgradedEngineSynthDef);
            bw.Write(UpgradedEngineSynthPreset);
            bw.Write(UpgradedExhaustVolumeBoost_PostSubmix);
            bw.Write(UpgradedExhaustSynthDef);
            bw.Write(UpgradedExhaustSynthPreset);
            bw.Write(DamageSynthHashList);
            bw.Write(UpgradedRevLimiterPop);
            bw.Write(EngineIdleVolume_PostSubmix);
            bw.Write(ExhaustIdleVolume_PostSubmix);
            bw.Write(StartupRevsVolumeBoostEngine_PostSubmix);
            bw.Write(StartupRevsVolumeBoostExhaust_PostSubmix);
            if ((RevLimiterApplyType != 0) || (RevLimiterVolumeCut != 0)) // if values arent 0, Write them.
            {
                bw.Write(RevLimiterApplyType);
                bw.Write(RevLimiterVolumeCut);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MasterVolume", MasterVolume.ToString());
            RelXml.StringTag(sb, indent, "EngineAccel", RelXml.HashString(EngineAccel));
            RelXml.StringTag(sb, indent, "ExhaustAccel", RelXml.HashString(ExhaustAccel));
            RelXml.ValueTag(sb, indent, "EngineVolume_PreSubmix", EngineVolume_PreSubmix.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustVolume_PreSubmix", ExhaustVolume_PreSubmix.ToString());
            RelXml.ValueTag(sb, indent, "AccelVolume_PreSubmix", AccelVolume_PreSubmix.ToString());
            RelXml.ValueTag(sb, indent, "DecelVolume_PreSubmix", DecelVolume_PreSubmix.ToString());
            RelXml.ValueTag(sb, indent, "IdleVolume_PreSubmix", IdleVolume_PreSubmix.ToString());
            RelXml.ValueTag(sb, indent, "EngineRevsVolume_PreSubmix", EngineRevsVolume_PreSubmix.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustRevsVolume_PreSubmix", ExhaustRevsVolume_PreSubmix.ToString());
            RelXml.ValueTag(sb, indent, "EngineThrottleVolume_PreSubmix", EngineThrottleVolume_PreSubmix.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustThrottleVolume_PreSubmix", ExhaustThrottleVolume_PreSubmix.ToString());
            RelXml.ValueTag(sb, indent, "EngineVolume_PostSubmix", EngineVolume_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustVolume_PostSubmix", ExhaustVolume_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "EngineMaxConeAttenuation", EngineMaxConeAttenuation.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustMaxConeAttenuation", ExhaustMaxConeAttenuation.ToString());
            RelXml.ValueTag(sb, indent, "EngineRevsVolume_PostSubmix", EngineRevsVolume_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustRevsVolume_PostSubmix", ExhaustRevsVolume_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "EngineThrottleVolume_PostSubmix", EngineThrottleVolume_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustThrottleVolume_PostSubmix", ExhaustThrottleVolume_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "GearChangeWobbleLength", GearChangeWobbleLength.ToString());
            RelXml.ValueTag(sb, indent, "GearChangeWobbleLengthVariance", FloatUtil.ToString(GearChangeWobbleLengthVariance));
            RelXml.ValueTag(sb, indent, "GearChangeWobbleSpeed", FloatUtil.ToString(GearChangeWobbleSpeed));
            RelXml.ValueTag(sb, indent, "GearChangeWobbleSpeedVariance", FloatUtil.ToString(GearChangeWobbleSpeedVariance));
            RelXml.ValueTag(sb, indent, "GearChangeWobblePitch", FloatUtil.ToString(GearChangeWobblePitch));
            RelXml.ValueTag(sb, indent, "GearChangeWobblePitchVariance", FloatUtil.ToString(GearChangeWobblePitchVariance));
            RelXml.ValueTag(sb, indent, "GearChangeWobbleVolume", FloatUtil.ToString(GearChangeWobbleVolume));
            RelXml.ValueTag(sb, indent, "GearChangeWobbleVolumeVariance", FloatUtil.ToString(GearChangeWobbleVolumeVariance));
            RelXml.ValueTag(sb, indent, "EngineClutchAttenuation_PostSubmix", EngineClutchAttenuation_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustClutchAttenuation_PostSubmix", ExhaustClutchAttenuation_PostSubmix.ToString());
            RelXml.StringTag(sb, indent, "EngineSynthDef", RelXml.HashString(EngineSynthDef));
            RelXml.StringTag(sb, indent, "EngineSynthPreset", RelXml.HashString(EngineSynthPreset));
            RelXml.StringTag(sb, indent, "ExhaustSynthDef", RelXml.HashString(ExhaustSynthDef));
            RelXml.StringTag(sb, indent, "ExhaustSynthPreset", RelXml.HashString(ExhaustSynthPreset));
            RelXml.StringTag(sb, indent, "NPCEngineAccel", RelXml.HashString(NPCEngineAccel));
            RelXml.StringTag(sb, indent, "NPCExhaustAccel", RelXml.HashString(NPCExhaustAccel));
            RelXml.StringTag(sb, indent, "RevLimiterPopSound", RelXml.HashString(RevLimiterPopSound));
            RelXml.ValueTag(sb, indent, "MinRPMOverride", MinRPMOverride.ToString());
            RelXml.ValueTag(sb, indent, "MaxRPMOverride", MaxRPMOverride.ToString());
            RelXml.StringTag(sb, indent, "EngineSubmixVoice", RelXml.HashString(EngineSubmixVoice));
            RelXml.StringTag(sb, indent, "ExhaustSubmixVoice", RelXml.HashString(ExhaustSubmixVoice));
            RelXml.ValueTag(sb, indent, "ExhaustProximityVolume_PostSubmix", ExhaustProximityVolume_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "RevLimiterGrainsToPlay", RevLimiterGrainsToPlay.ToString());
            RelXml.ValueTag(sb, indent, "RevLimiterGrainsToSkip", RevLimiterGrainsToSkip.ToString());
            RelXml.StringTag(sb, indent, "SynchronisedSynth", RelXml.HashString(SynchronisedSynth));
            RelXml.ValueTag(sb, indent, "UpgradedEngineVolumeBoost_PostSubmix", UpgradedEngineVolumeBoost_PostSubmix.ToString());
            RelXml.StringTag(sb, indent, "UpgradedEngineSynthDef", RelXml.HashString(UpgradedEngineSynthDef));
            RelXml.StringTag(sb, indent, "UpgradedEngineSynthPreset", RelXml.HashString(UpgradedEngineSynthPreset));
            RelXml.ValueTag(sb, indent, "UpgradedExhaustVolumeBoost_PostSubmix", UpgradedExhaustVolumeBoost_PostSubmix.ToString());
            RelXml.StringTag(sb, indent, "UpgradedExhaustSynthDef", RelXml.HashString(UpgradedExhaustSynthDef));
            RelXml.StringTag(sb, indent, "UpgradedExhaustSynthPreset", RelXml.HashString(UpgradedExhaustSynthPreset));
            RelXml.StringTag(sb, indent, "DamageSynthHashList", RelXml.HashString(DamageSynthHashList));
            RelXml.StringTag(sb, indent, "UpgradedRevLimiterPop", RelXml.HashString(UpgradedRevLimiterPop));
            RelXml.ValueTag(sb, indent, "EngineIdleVolume_PostSubmix", EngineIdleVolume_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustIdleVolume_PostSubmix", ExhaustIdleVolume_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "StartupRevsVolumeBoostEngine_PostSubmix", StartupRevsVolumeBoostEngine_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "StartupRevsVolumeBoostExhaust_PostSubmix", StartupRevsVolumeBoostExhaust_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "RevLimiterApplyType", RevLimiterApplyType.ToString());
            RelXml.ValueTag(sb, indent, "RevLimiterVolumeCut", FloatUtil.ToString(RevLimiterVolumeCut));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MasterVolume = Xml.GetChildIntAttribute(node, "MasterVolume", "value");
            EngineAccel = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineAccel"));
            ExhaustAccel = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustAccel"));
            EngineVolume_PreSubmix = Xml.GetChildIntAttribute(node, "EngineVolume_PreSubmix", "value");
            ExhaustVolume_PreSubmix = Xml.GetChildIntAttribute(node, "ExhaustVolume_PreSubmix", "value");
            AccelVolume_PreSubmix = Xml.GetChildIntAttribute(node, "AccelVolume_PreSubmix", "value");
            DecelVolume_PreSubmix = Xml.GetChildIntAttribute(node, "DecelVolume_PreSubmix", "value");
            IdleVolume_PreSubmix = Xml.GetChildIntAttribute(node, "IdleVolume_PreSubmix", "value");
            EngineRevsVolume_PreSubmix = Xml.GetChildIntAttribute(node, "EngineRevsVolume_PreSubmix", "value");
            ExhaustRevsVolume_PreSubmix = Xml.GetChildIntAttribute(node, "ExhaustRevsVolume_PreSubmix", "value");
            EngineThrottleVolume_PreSubmix = Xml.GetChildIntAttribute(node, "EngineThrottleVolume_PreSubmix", "value");
            ExhaustThrottleVolume_PreSubmix = Xml.GetChildIntAttribute(node, "ExhaustThrottleVolume_PreSubmix", "value");
            EngineVolume_PostSubmix = Xml.GetChildIntAttribute(node, "EngineVolume_PostSubmix", "value");
            ExhaustVolume_PostSubmix = Xml.GetChildIntAttribute(node, "ExhaustVolume_PostSubmix", "value");
            EngineMaxConeAttenuation = Xml.GetChildIntAttribute(node, "EngineMaxConeAttenuation", "value");
            ExhaustMaxConeAttenuation = Xml.GetChildIntAttribute(node, "ExhaustMaxConeAttenuation", "value");
            EngineRevsVolume_PostSubmix = Xml.GetChildIntAttribute(node, "EngineRevsVolume_PostSubmix", "value");
            ExhaustRevsVolume_PostSubmix = Xml.GetChildIntAttribute(node, "ExhaustRevsVolume_PostSubmix", "value");
            EngineThrottleVolume_PostSubmix = Xml.GetChildIntAttribute(node, "EngineThrottleVolume_PostSubmix", "value");
            ExhaustThrottleVolume_PostSubmix = Xml.GetChildIntAttribute(node, "ExhaustThrottleVolume_PostSubmix", "value");
            GearChangeWobbleLength = Xml.GetChildUIntAttribute(node, "GearChangeWobbleLength", "value");
            GearChangeWobbleLengthVariance = Xml.GetChildFloatAttribute(node, "GearChangeWobbleLengthVariance", "value");
            GearChangeWobbleSpeed = Xml.GetChildFloatAttribute(node, "GearChangeWobbleSpeed", "value");
            GearChangeWobbleSpeedVariance = Xml.GetChildFloatAttribute(node, "GearChangeWobbleSpeedVariance", "value");
            GearChangeWobblePitch = Xml.GetChildFloatAttribute(node, "GearChangeWobblePitch", "value");
            GearChangeWobblePitchVariance = Xml.GetChildFloatAttribute(node, "GearChangeWobblePitchVariance", "value");
            GearChangeWobbleVolume = Xml.GetChildFloatAttribute(node, "GearChangeWobbleVolume", "value");
            GearChangeWobbleVolumeVariance = Xml.GetChildFloatAttribute(node, "GearChangeWobbleVolumeVariance", "value");
            EngineClutchAttenuation_PostSubmix = Xml.GetChildIntAttribute(node, "EngineClutchAttenuation_PostSubmix", "value");
            ExhaustClutchAttenuation_PostSubmix = Xml.GetChildIntAttribute(node, "ExhaustClutchAttenuation_PostSubmix", "value");
            EngineSynthDef = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSynthDef"));
            EngineSynthPreset = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSynthPreset"));
            ExhaustSynthDef = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSynthDef"));
            ExhaustSynthPreset = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSynthPreset"));
            NPCEngineAccel = XmlRel.GetHash(Xml.GetChildInnerText(node, "NPCEngineAccel"));
            NPCExhaustAccel = XmlRel.GetHash(Xml.GetChildInnerText(node, "NPCExhaustAccel"));
            RevLimiterPopSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RevLimiterPopSound"));
            MinRPMOverride = Xml.GetChildUIntAttribute(node, "MinRPMOverride", "value");
            MaxRPMOverride = Xml.GetChildUIntAttribute(node, "MaxRPMOverride", "value");
            EngineSubmixVoice = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSubmixVoice"));
            ExhaustSubmixVoice = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSubmixVoice"));
            ExhaustProximityVolume_PostSubmix = Xml.GetChildIntAttribute(node, "ExhaustProximityVolume_PostSubmix", "value");
            RevLimiterGrainsToPlay = Xml.GetChildUIntAttribute(node, "RevLimiterGrainsToPlay", "value");
            RevLimiterGrainsToSkip = Xml.GetChildUIntAttribute(node, "RevLimiterGrainsToSkip", "value");
            SynchronisedSynth = XmlRel.GetHash(Xml.GetChildInnerText(node, "SynchronisedSynth"));
            UpgradedEngineVolumeBoost_PostSubmix = Xml.GetChildIntAttribute(node, "UpgradedEngineVolumeBoost_PostSubmix", "value");
            UpgradedEngineSynthDef = XmlRel.GetHash(Xml.GetChildInnerText(node, "UpgradedEngineSynthDef"));
            UpgradedEngineSynthPreset = XmlRel.GetHash(Xml.GetChildInnerText(node, "UpgradedEngineSynthPreset"));
            UpgradedExhaustVolumeBoost_PostSubmix = Xml.GetChildIntAttribute(node, "UpgradedExhaustVolumeBoost_PostSubmix", "value");
            UpgradedExhaustSynthDef = XmlRel.GetHash(Xml.GetChildInnerText(node, "UpgradedExhaustSynthDef"));
            UpgradedExhaustSynthPreset = XmlRel.GetHash(Xml.GetChildInnerText(node, "UpgradedExhaustSynthPreset"));
            DamageSynthHashList = XmlRel.GetHash(Xml.GetChildInnerText(node, "DamageSynthHashList"));
            UpgradedRevLimiterPop = XmlRel.GetHash(Xml.GetChildInnerText(node, "UpgradedRevLimiterPop"));
            EngineIdleVolume_PostSubmix = Xml.GetChildIntAttribute(node, "EngineIdleVolume_PostSubmix", "value");
            ExhaustIdleVolume_PostSubmix = Xml.GetChildIntAttribute(node, "ExhaustIdleVolume_PostSubmix", "value");
            StartupRevsVolumeBoostEngine_PostSubmix = Xml.GetChildIntAttribute(node, "StartupRevsVolumeBoostEngine_PostSubmix", "value");
            StartupRevsVolumeBoostExhaust_PostSubmix = Xml.GetChildIntAttribute(node, "StartupRevsVolumeBoostExhaust_PostSubmix", "value");
            RevLimiterApplyType = Xml.GetChildIntAttribute(node, "RevLimiterApplyType", "value");
            RevLimiterVolumeCut = Xml.GetChildFloatAttribute(node, "RevLimiterVolumeCut", "value");
        }
        public override MetaHash[] GetSynthHashes()
        {
            return new[] { EngineSynthDef, EngineSynthPreset, ExhaustSynthDef, ExhaustSynthPreset, UpgradedExhaustSynthDef, 
                UpgradedExhaustSynthPreset, UpgradedEngineSynthDef, UpgradedEngineSynthPreset };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { EngineAccel, ExhaustAccel, NPCEngineAccel, NPCExhaustAccel, RevLimiterPopSound, EngineSubmixVoice, ExhaustSubmixVoice,
                SynchronisedSynth, DamageSynthHashList, UpgradedRevLimiterPop };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151CarAudioSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash Engine { get; set; }
        public MetaHash GranularEngine { get; set; }
        public MetaHash HornSounds { get; set; }
        public MetaHash DoorOpenSound { get; set; }
        public MetaHash DoorCloseSound { get; set; }
        public MetaHash BootOpenSound { get; set; }
        public MetaHash BootCloseSound { get; set; }
        public MetaHash RollSound { get; set; }
        public float BrakeSqueekFactor { get; set; }
        public MetaHash SuspensionUp { get; set; }
        public MetaHash SuspensionDown { get; set; }
        public float MinSuspCompThresh { get; set; }
        public float MaxSuspCompThresh { get; set; }
        public MetaHash VehicleCollisions { get; set; }
        public uint CarMake { get; set; }
        public uint CarModel { get; set; }
        public uint CarCategory { get; set; }
        public MetaHash ScannerVehicleSettings { get; set; }
        public MetaHash JumpLandSound { get; set; }
        public MetaHash DamagedJumpLandSound { get; set; }
        public uint JumpLandMinThresh { get; set; }
        public uint JumpLandMaxThresh { get; set; }
        public byte VolumeCategory { get; set; }
        public byte GPSType { get; set; }
        public byte RadioType { get; set; }
        public byte RadioGenre { get; set; }
        public MetaHash IndicatorOn { get; set; }
        public MetaHash IndicatorOff { get; set; }
        public MetaHash Handbrake { get; set; }
        public byte GPSVoice { get; set; }
        public byte AmbientRadioVol { get; set; }
        public byte RadioLeakage { get; set; }
        public byte padding00 { get; set; }
        public MetaHash ParkingTone { get; set; }
        public MetaHash RoofStuckSound { get; set; }
        public MetaHash FreewayPassbyTyreBumpFront { get; set; }
        public MetaHash FreewayPassbyTyreBumpBack { get; set; }
        public MetaHash FireAudio { get; set; }
        public MetaHash StartupRevs { get; set; }
        public MetaHash WindNoise { get; set; }
        public MetaHash FreewayPassbyTyreBumpFrontSide { get; set; }
        public MetaHash FreewayPassbyTyreBumpBackSide { get; set; }
        public float MaxRollOffScalePlayer { get; set; }
        public float MaxRollOffScaleNPC { get; set; }
        public MetaHash ConvertibleRoofSoundSet { get; set; }
        public int OffRoadRumbleSoundVolume { get; set; }
        public MetaHash SirenSounds { get; set; }
        public MetaHash AlternativeGranularEngines { get; set; }
        public float AlternativeGranularEngineProbability { get; set; }
        public uint StopStartProb { get; set; }
        public MetaHash NPCRoadNoise { get; set; }
        public MetaHash NPCRoadNoiseHighway { get; set; }
        public MetaHash ForkliftSounds { get; set; }
        public MetaHash TurretSounds { get; set; }
        public int ClatterType { get; set; }
        public MetaHash DiggerSounds { get; set; }
        public MetaHash TowTruckSounds { get; set; }
        public int EngineType { get; set; }
        public MetaHash ElectricEngine { get; set; }
        public float Openness { get; set; }
        public MetaHash ReverseWarning { get; set; }
        public int RandomDamage { get; set; }
        public MetaHash WindClothSound { get; set; }
        public MetaHash CarSpecificShutdownSound { get; set; }
        public float ClatterSensitivityScalar { get; set; }
        public int ClatterVolumeBoost { get; set; }
        public float ChassisStressSensitivityScalar { get; set; }
        public int ChassisStressVolumeBoost { get; set; }
        public MetaHash VehicleRainSound { get; set; }
        public ushort AdditionalRevsIncreaseSmoothing { get; set; }
        public ushort AdditionalRevsDecreaseSmoothing { get; set; }
        public ushort AdditionalGearChangeSmoothing { get; set; }
        public ushort AdditionalGearChangeSmoothingTime { get; set; }
        public MetaHash ConvertibleRoofInteriorSoundSet { get; set; }
        public MetaHash VehicleRainSoundInterior { get; set; }
        public MetaHash CabinToneLoop { get; set; }
        public float InteriorViewEngineOpenness { get; set; }
        public MetaHash JumpLandSoundInterior { get; set; }
        public MetaHash DamagedJumpLandSoundInterior { get; set; }

        public Dat151CarAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.CarAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151CarAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Engine = br.ReadUInt32();
            GranularEngine = br.ReadUInt32();
            HornSounds = br.ReadUInt32();
            DoorOpenSound = br.ReadUInt32();
            DoorCloseSound = br.ReadUInt32();
            BootOpenSound = br.ReadUInt32();
            BootCloseSound = br.ReadUInt32();
            RollSound = br.ReadUInt32();
            BrakeSqueekFactor = br.ReadSingle();
            SuspensionUp = br.ReadUInt32();
            SuspensionDown = br.ReadUInt32();
            MinSuspCompThresh = br.ReadSingle();
            MaxSuspCompThresh = br.ReadSingle();
            VehicleCollisions = br.ReadUInt32();
            CarMake = br.ReadUInt32();
            CarModel = br.ReadUInt32();
            CarCategory = br.ReadUInt32();
            ScannerVehicleSettings = br.ReadUInt32();
            JumpLandSound = br.ReadUInt32();
            DamagedJumpLandSound = br.ReadUInt32();
            JumpLandMinThresh = br.ReadUInt32();
            JumpLandMaxThresh = br.ReadUInt32();
            VolumeCategory = br.ReadByte();
            GPSType = br.ReadByte();
            RadioType = br.ReadByte();
            RadioGenre = br.ReadByte();
            IndicatorOn = br.ReadUInt32();
            IndicatorOff = br.ReadUInt32();
            Handbrake = br.ReadUInt32();
            GPSVoice = br.ReadByte();
            AmbientRadioVol = br.ReadByte();
            RadioLeakage = br.ReadByte();
            padding00 = br.ReadByte();
            ParkingTone = br.ReadUInt32();
            RoofStuckSound = br.ReadUInt32();
            FreewayPassbyTyreBumpFront = br.ReadUInt32();
            FreewayPassbyTyreBumpBack = br.ReadUInt32();
            FireAudio = br.ReadUInt32();
            StartupRevs = br.ReadUInt32();
            WindNoise = br.ReadUInt32();
            FreewayPassbyTyreBumpFrontSide = br.ReadUInt32();
            FreewayPassbyTyreBumpBackSide = br.ReadUInt32();
            MaxRollOffScalePlayer = br.ReadSingle();
            MaxRollOffScaleNPC = br.ReadSingle();
            ConvertibleRoofSoundSet = br.ReadUInt32();
            OffRoadRumbleSoundVolume = br.ReadInt32();
            SirenSounds = br.ReadUInt32();
            AlternativeGranularEngines = br.ReadUInt32();
            AlternativeGranularEngineProbability = br.ReadSingle();
            StopStartProb = br.ReadUInt32();
            NPCRoadNoise = br.ReadUInt32();
            NPCRoadNoiseHighway = br.ReadUInt32();
            ForkliftSounds = br.ReadUInt32();
            TurretSounds = br.ReadUInt32();
            ClatterType = br.ReadInt32();
            DiggerSounds = br.ReadUInt32();
            TowTruckSounds = br.ReadUInt32();
            EngineType = br.ReadInt32();
            ElectricEngine = br.ReadUInt32();
            Openness = br.ReadSingle();
            ReverseWarning = br.ReadUInt32();
            RandomDamage = br.ReadInt32();
            WindClothSound = br.ReadUInt32();
            CarSpecificShutdownSound = br.ReadUInt32();
            ClatterSensitivityScalar = br.ReadSingle();
            ClatterVolumeBoost = br.ReadInt32();
            ChassisStressSensitivityScalar = br.ReadSingle();
            ChassisStressVolumeBoost = br.ReadInt32();

            var bytesleft = br.BaseStream.Length - br.BaseStream.Position;
            switch (bytesleft) // Check for additional left over bytes
            {
                case 0: // if 0 additional bytes, end
                    break;
                case 4: // if 4 additional bytes, read value
                    VehicleRainSound = br.ReadUInt32();
                    break;
                case 36: // if 36 additional bytes, read remaining values
                    VehicleRainSound = br.ReadUInt32();
                    AdditionalRevsIncreaseSmoothing = br.ReadUInt16();
                    AdditionalRevsDecreaseSmoothing = br.ReadUInt16();
                    AdditionalGearChangeSmoothing = br.ReadUInt16();
                    AdditionalGearChangeSmoothingTime = br.ReadUInt16();
                    ConvertibleRoofInteriorSoundSet = br.ReadUInt32();
                    VehicleRainSoundInterior = br.ReadUInt32();
                    CabinToneLoop = br.ReadUInt32();
                    InteriorViewEngineOpenness = br.ReadSingle();
                    JumpLandSoundInterior = br.ReadUInt32();
                    DamagedJumpLandSoundInterior = br.ReadUInt32();
                    break;
                default:
                    break;
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Engine);
            bw.Write(GranularEngine);
            bw.Write(HornSounds);
            bw.Write(DoorOpenSound);
            bw.Write(DoorCloseSound);
            bw.Write(BootOpenSound);
            bw.Write(BootCloseSound);
            bw.Write(RollSound);
            bw.Write(BrakeSqueekFactor);
            bw.Write(SuspensionUp);
            bw.Write(SuspensionDown);
            bw.Write(MinSuspCompThresh);
            bw.Write(MaxSuspCompThresh);
            bw.Write(VehicleCollisions);
            bw.Write(CarMake);
            bw.Write(CarModel);
            bw.Write(CarCategory);
            bw.Write(ScannerVehicleSettings);
            bw.Write(JumpLandSound);
            bw.Write(DamagedJumpLandSound);
            bw.Write(JumpLandMinThresh);
            bw.Write(JumpLandMaxThresh);
            bw.Write(VolumeCategory);
            bw.Write(GPSType);
            bw.Write(RadioType);
            bw.Write(RadioGenre);
            bw.Write(IndicatorOn);
            bw.Write(IndicatorOff);
            bw.Write(Handbrake);
            bw.Write(GPSVoice);
            bw.Write(AmbientRadioVol);
            bw.Write(RadioLeakage);
            bw.Write(padding00);
            bw.Write(ParkingTone);
            bw.Write(RoofStuckSound);
            bw.Write(FreewayPassbyTyreBumpFront);
            bw.Write(FreewayPassbyTyreBumpBack);
            bw.Write(FireAudio);
            bw.Write(StartupRevs);
            bw.Write(WindNoise);
            bw.Write(FreewayPassbyTyreBumpFrontSide);
            bw.Write(FreewayPassbyTyreBumpBackSide);
            bw.Write(MaxRollOffScalePlayer);
            bw.Write(MaxRollOffScaleNPC);
            bw.Write(ConvertibleRoofSoundSet);
            bw.Write(OffRoadRumbleSoundVolume);
            bw.Write(SirenSounds);
            bw.Write(AlternativeGranularEngines);
            bw.Write(AlternativeGranularEngineProbability);
            bw.Write(StopStartProb);
            bw.Write(NPCRoadNoise);
            bw.Write(NPCRoadNoiseHighway);
            bw.Write(ForkliftSounds);
            bw.Write(TurretSounds);
            bw.Write(ClatterType);
            bw.Write(DiggerSounds);
            bw.Write(TowTruckSounds);
            bw.Write(EngineType);
            bw.Write(ElectricEngine);
            bw.Write(Openness);
            bw.Write(ReverseWarning);
            bw.Write(RandomDamage);
            bw.Write(WindClothSound);
            bw.Write(CarSpecificShutdownSound);
            bw.Write(ClatterSensitivityScalar);
            bw.Write(ClatterVolumeBoost);
            bw.Write(ChassisStressSensitivityScalar);
            bw.Write(ChassisStressVolumeBoost);

            if (VehicleRainSound != 0) // if RainSound is not 0, Write value, then check for additional values
            {
                bw.Write(VehicleRainSound);

                if ((VehicleRainSoundInterior != 0) || (JumpLandSoundInterior != 0) || (DamagedJumpLandSoundInterior != 0))
                {
                    bw.Write(AdditionalRevsIncreaseSmoothing);
                    bw.Write(AdditionalRevsDecreaseSmoothing);
                    bw.Write(AdditionalGearChangeSmoothing);
                    bw.Write(AdditionalGearChangeSmoothingTime);
                    bw.Write(ConvertibleRoofInteriorSoundSet);
                    bw.Write(VehicleRainSoundInterior);
                    bw.Write(CabinToneLoop);
                    bw.Write(InteriorViewEngineOpenness);
                    bw.Write(JumpLandSoundInterior);
                    bw.Write(DamagedJumpLandSoundInterior);
                }
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "Engine", RelXml.HashString(Engine));
            RelXml.StringTag(sb, indent, "GranularEngine", RelXml.HashString(GranularEngine));
            RelXml.StringTag(sb, indent, "HornSounds", RelXml.HashString(HornSounds));
            RelXml.StringTag(sb, indent, "DoorOpenSound", RelXml.HashString(DoorOpenSound));
            RelXml.StringTag(sb, indent, "DoorCloseSound", RelXml.HashString(DoorCloseSound));
            RelXml.StringTag(sb, indent, "BootOpenSound", RelXml.HashString(BootOpenSound));
            RelXml.StringTag(sb, indent, "BootCloseSound", RelXml.HashString(BootCloseSound));
            RelXml.StringTag(sb, indent, "RollSound", RelXml.HashString(RollSound));
            RelXml.ValueTag(sb, indent, "BrakeSqueekFactor", FloatUtil.ToString(BrakeSqueekFactor));
            RelXml.StringTag(sb, indent, "SuspensionUp", RelXml.HashString(SuspensionUp));
            RelXml.StringTag(sb, indent, "SuspensionDown", RelXml.HashString(SuspensionDown));
            RelXml.ValueTag(sb, indent, "MinSuspCompThresh", FloatUtil.ToString(MinSuspCompThresh));
            RelXml.ValueTag(sb, indent, "MaxSuspCompThresh", FloatUtil.ToString(MaxSuspCompThresh));
            RelXml.StringTag(sb, indent, "VehicleCollisions", RelXml.HashString(VehicleCollisions));
            RelXml.ValueTag(sb, indent, "CarMake", CarMake.ToString());
            RelXml.ValueTag(sb, indent, "CarModel", CarModel.ToString());
            RelXml.ValueTag(sb, indent, "CarCategory", CarCategory.ToString());
            RelXml.StringTag(sb, indent, "ScannerVehicleSettings", RelXml.HashString(ScannerVehicleSettings));
            RelXml.StringTag(sb, indent, "JumpLandSound", RelXml.HashString(JumpLandSound));
            RelXml.StringTag(sb, indent, "DamagedJumpLandSound", RelXml.HashString(DamagedJumpLandSound));
            RelXml.ValueTag(sb, indent, "JumpLandMinThresh", JumpLandMinThresh.ToString());
            RelXml.ValueTag(sb, indent, "JumpLandMaxThresh", JumpLandMaxThresh.ToString());
            RelXml.ValueTag(sb, indent, "VolumeCategory", VolumeCategory.ToString());
            RelXml.ValueTag(sb, indent, "GPSType", GPSType.ToString());
            RelXml.ValueTag(sb, indent, "RadioType", RadioType.ToString());
            RelXml.ValueTag(sb, indent, "RadioGenre", RadioGenre.ToString());
            RelXml.StringTag(sb, indent, "IndicatorOn", RelXml.HashString(IndicatorOn));
            RelXml.StringTag(sb, indent, "IndicatorOff", RelXml.HashString(IndicatorOff));
            RelXml.StringTag(sb, indent, "Handbrake", RelXml.HashString(Handbrake));
            RelXml.ValueTag(sb, indent, "GPSVoice", GPSVoice.ToString());
            RelXml.ValueTag(sb, indent, "AmbientRadioVol", AmbientRadioVol.ToString());
            RelXml.ValueTag(sb, indent, "RadioLeakage", RadioLeakage.ToString());
            RelXml.StringTag(sb, indent, "ParkingTone", RelXml.HashString(ParkingTone));
            RelXml.StringTag(sb, indent, "RoofStuckSound", RelXml.HashString(RoofStuckSound));
            RelXml.StringTag(sb, indent, "FreewayPassbyTyreBumpFront", RelXml.HashString(FreewayPassbyTyreBumpFront));
            RelXml.StringTag(sb, indent, "FreewayPassbyTyreBumpBack", RelXml.HashString(FreewayPassbyTyreBumpBack));
            RelXml.StringTag(sb, indent, "FireAudio", RelXml.HashString(FireAudio));
            RelXml.StringTag(sb, indent, "StartupRevs", RelXml.HashString(StartupRevs));
            RelXml.StringTag(sb, indent, "WindNoise", RelXml.HashString(WindNoise));
            RelXml.StringTag(sb, indent, "FreewayPassbyTyreBumpFrontSide", RelXml.HashString(FreewayPassbyTyreBumpFrontSide));
            RelXml.StringTag(sb, indent, "FreewayPassbyTyreBumpBackSide", RelXml.HashString(FreewayPassbyTyreBumpBackSide));
            RelXml.ValueTag(sb, indent, "MaxRollOffScalePlayer", FloatUtil.ToString(MaxRollOffScalePlayer));
            RelXml.ValueTag(sb, indent, "MaxRollOffScaleNPC", FloatUtil.ToString(MaxRollOffScaleNPC));
            RelXml.StringTag(sb, indent, "ConvertibleRoofSoundSet", RelXml.HashString(ConvertibleRoofSoundSet));
            RelXml.ValueTag(sb, indent, "OffRoadRumbleSoundVolume", OffRoadRumbleSoundVolume.ToString());
            RelXml.StringTag(sb, indent, "SirenSounds", RelXml.HashString(SirenSounds));
            RelXml.StringTag(sb, indent, "AlternativeGranularEngines", RelXml.HashString(AlternativeGranularEngines));
            RelXml.ValueTag(sb, indent, "AlternativeGranularEngineProbability", FloatUtil.ToString(AlternativeGranularEngineProbability));
            RelXml.ValueTag(sb, indent, "StopStartProb", StopStartProb.ToString());
            RelXml.StringTag(sb, indent, "NPCRoadNoise", RelXml.HashString(NPCRoadNoise));
            RelXml.StringTag(sb, indent, "NPCRoadNoiseHighway", RelXml.HashString(NPCRoadNoiseHighway));
            RelXml.StringTag(sb, indent, "ForkliftSounds", RelXml.HashString(ForkliftSounds));
            RelXml.StringTag(sb, indent, "TurretSounds", RelXml.HashString(TurretSounds));
            RelXml.ValueTag(sb, indent, "ClatterType", ClatterType.ToString());
            RelXml.StringTag(sb, indent, "DiggerSounds", RelXml.HashString(DiggerSounds));
            RelXml.StringTag(sb, indent, "TowTruckSounds", RelXml.HashString(TowTruckSounds));
            RelXml.ValueTag(sb, indent, "EngineType", EngineType.ToString());
            RelXml.StringTag(sb, indent, "ElectricEngine", RelXml.HashString(ElectricEngine));
            RelXml.ValueTag(sb, indent, "Openness", FloatUtil.ToString(Openness));
            RelXml.StringTag(sb, indent, "ReverseWarning", RelXml.HashString(ReverseWarning));
            RelXml.ValueTag(sb, indent, "RandomDamage", RandomDamage.ToString());
            RelXml.StringTag(sb, indent, "WindClothSound", RelXml.HashString(WindClothSound));
            RelXml.StringTag(sb, indent, "CarSpecificShutdownSound", RelXml.HashString(CarSpecificShutdownSound));
            RelXml.ValueTag(sb, indent, "ClatterSensitivityScalar", FloatUtil.ToString(ClatterSensitivityScalar));
            RelXml.ValueTag(sb, indent, "ClatterVolumeBoost", ClatterVolumeBoost.ToString());
            RelXml.ValueTag(sb, indent, "ChassisStressSensitivityScalar", FloatUtil.ToString(ChassisStressSensitivityScalar));
            RelXml.ValueTag(sb, indent, "ChassisStressVolumeBoost", ChassisStressVolumeBoost.ToString());


            RelXml.StringTag(sb, indent, "VehicleRainSound", RelXml.HashString(VehicleRainSound));
            RelXml.ValueTag(sb, indent, "AdditionalRevsIncreaseSmoothing", AdditionalRevsIncreaseSmoothing.ToString());
            RelXml.ValueTag(sb, indent, "AdditionalRevsDecreaseSmoothing", AdditionalRevsDecreaseSmoothing.ToString());
            RelXml.ValueTag(sb, indent, "AdditionalGearChangeSmoothing", AdditionalGearChangeSmoothing.ToString());
            RelXml.ValueTag(sb, indent, "AdditionalGearChangeSmoothingTime", AdditionalGearChangeSmoothingTime.ToString());
            RelXml.StringTag(sb, indent, "ConvertibleRoofInteriorSoundSet", RelXml.HashString(ConvertibleRoofInteriorSoundSet));
            RelXml.StringTag(sb, indent, "VehicleRainSoundInterior", RelXml.HashString(VehicleRainSoundInterior));
            RelXml.StringTag(sb, indent, "CabinToneLoop", RelXml.HashString(CabinToneLoop));
            RelXml.ValueTag(sb, indent, "InteriorViewEngineOpenness", FloatUtil.ToString(InteriorViewEngineOpenness));
            RelXml.StringTag(sb, indent, "JumpLandSoundInterior", RelXml.HashString(JumpLandSoundInterior));
            RelXml.StringTag(sb, indent, "DamagedJumpLandSoundInterior", RelXml.HashString(DamagedJumpLandSoundInterior));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Engine = XmlRel.GetHash(Xml.GetChildInnerText(node, "Engine"));
            GranularEngine = XmlRel.GetHash(Xml.GetChildInnerText(node, "GranularEngine"));
            HornSounds = XmlRel.GetHash(Xml.GetChildInnerText(node, "HornSounds"));
            DoorOpenSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorOpenSound"));
            DoorCloseSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorCloseSound"));
            BootOpenSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BootOpenSound"));
            BootCloseSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BootCloseSound"));
            RollSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RollSound"));
            BrakeSqueekFactor = Xml.GetChildFloatAttribute(node, "BrakeSqueekFactor", "value");
            SuspensionUp = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuspensionUp"));
            SuspensionDown = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuspensionDown"));
            MinSuspCompThresh = Xml.GetChildFloatAttribute(node, "MinSuspCompThresh", "value");
            MaxSuspCompThresh = Xml.GetChildFloatAttribute(node, "MaxSuspCompThresh", "value");
            VehicleCollisions = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleCollisions"));
            CarMake = Xml.GetChildUIntAttribute(node, "CarMake", "value");
            CarModel = Xml.GetChildUIntAttribute(node, "CarModel", "value");
            CarCategory = Xml.GetChildUIntAttribute(node, "CarCategory", "value");
            ScannerVehicleSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScannerVehicleSettings"));
            JumpLandSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "JumpLandSound"));
            DamagedJumpLandSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "DamagedJumpLandSound"));
            JumpLandMinThresh = Xml.GetChildUIntAttribute(node, "JumpLandMinThresh", "value");
            JumpLandMaxThresh = Xml.GetChildUIntAttribute(node, "JumpLandMaxThresh", "value");
            VolumeCategory = (byte)Xml.GetChildUIntAttribute(node, "VolumeCategory", "value");
            GPSType = (byte)Xml.GetChildUIntAttribute(node, "GPSType", "value");
            RadioType = (byte)Xml.GetChildUIntAttribute(node, "RadioType", "value");
            RadioGenre = (byte)Xml.GetChildUIntAttribute(node, "RadioGenre", "value");
            IndicatorOn = XmlRel.GetHash(Xml.GetChildInnerText(node, "IndicatorOn"));
            IndicatorOff = XmlRel.GetHash(Xml.GetChildInnerText(node, "IndicatorOff"));
            Handbrake = XmlRel.GetHash(Xml.GetChildInnerText(node, "Handbrake"));
            GPSVoice = (byte)Xml.GetChildUIntAttribute(node, "GPSVoice", "value");
            AmbientRadioVol = (byte)Xml.GetChildUIntAttribute(node, "AmbientRadioVol", "value");
            RadioLeakage = (byte)Xml.GetChildUIntAttribute(node, "RadioLeakage", "value");
            ParkingTone = XmlRel.GetHash(Xml.GetChildInnerText(node, "ParkingTone"));
            RoofStuckSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RoofStuckSound"));
            FreewayPassbyTyreBumpFront = XmlRel.GetHash(Xml.GetChildInnerText(node, "FreewayPassbyTyreBumpFront"));
            FreewayPassbyTyreBumpBack = XmlRel.GetHash(Xml.GetChildInnerText(node, "FreewayPassbyTyreBumpBack"));
            FireAudio = XmlRel.GetHash(Xml.GetChildInnerText(node, "FireAudio"));
            StartupRevs = XmlRel.GetHash(Xml.GetChildInnerText(node, "StartupRevs"));
            WindNoise = XmlRel.GetHash(Xml.GetChildInnerText(node, "WindNoise"));
            FreewayPassbyTyreBumpFrontSide = XmlRel.GetHash(Xml.GetChildInnerText(node, "FreewayPassbyTyreBumpFrontSide"));
            FreewayPassbyTyreBumpBackSide = XmlRel.GetHash(Xml.GetChildInnerText(node, "FreewayPassbyTyreBumpBackSide"));
            MaxRollOffScalePlayer = Xml.GetChildFloatAttribute(node, "MaxRollOffScalePlayer", "value");
            MaxRollOffScaleNPC = Xml.GetChildFloatAttribute(node, "MaxRollOffScaleNPC", "value");
            ConvertibleRoofSoundSet = XmlRel.GetHash(Xml.GetChildInnerText(node, "ConvertibleRoofSoundSet"));
            OffRoadRumbleSoundVolume = Xml.GetChildIntAttribute(node, "OffRoadRumbleSoundVolume", "value");
            SirenSounds = XmlRel.GetHash(Xml.GetChildInnerText(node, "SirenSounds"));
            AlternativeGranularEngines = XmlRel.GetHash(Xml.GetChildInnerText(node, "AlternativeGranularEngines"));
            AlternativeGranularEngineProbability = Xml.GetChildFloatAttribute(node, "AlternativeGranularEngineProbability", "value");
            StopStartProb = Xml.GetChildUIntAttribute(node, "StopStartProb", "value");
            NPCRoadNoise = XmlRel.GetHash(Xml.GetChildInnerText(node, "NPCRoadNoise"));
            NPCRoadNoiseHighway = XmlRel.GetHash(Xml.GetChildInnerText(node, "NPCRoadNoiseHighway"));
            ForkliftSounds = XmlRel.GetHash(Xml.GetChildInnerText(node, "ForkliftSounds"));
            TurretSounds = XmlRel.GetHash(Xml.GetChildInnerText(node, "TurretSounds"));
            ClatterType = Xml.GetChildIntAttribute(node, "ClatterType", "value");
            DiggerSounds = XmlRel.GetHash(Xml.GetChildInnerText(node, "DiggerSounds"));
            TowTruckSounds = XmlRel.GetHash(Xml.GetChildInnerText(node, "TowTruckSounds"));
            EngineType = Xml.GetChildIntAttribute(node, "EngineType", "value");
            ElectricEngine = XmlRel.GetHash(Xml.GetChildInnerText(node, "ElectricEngine"));
            Openness = Xml.GetChildFloatAttribute(node, "Openness", "value");
            ReverseWarning = XmlRel.GetHash(Xml.GetChildInnerText(node, "ReverseWarning"));
            RandomDamage = Xml.GetChildIntAttribute(node, "RandomDamage", "value");
            WindClothSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "WindClothSound"));
            CarSpecificShutdownSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "CarSpecificShutdownSound"));
            ClatterSensitivityScalar = Xml.GetChildFloatAttribute(node, "ClatterSensitivityScalar", "value");
            ClatterVolumeBoost = Xml.GetChildIntAttribute(node, "ClatterVolumeBoost", "value");
            ChassisStressSensitivityScalar = Xml.GetChildFloatAttribute(node, "ChassisStressSensitivityScalar", "value");
            ChassisStressVolumeBoost = Xml.GetChildIntAttribute(node, "ChassisStressVolumeBoost", "value");


            VehicleRainSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleRainSound"));
            AdditionalRevsIncreaseSmoothing = (ushort)Xml.GetChildUIntAttribute(node, "AdditionalRevsIncreaseSmoothing", "value");
            AdditionalRevsDecreaseSmoothing = (ushort)Xml.GetChildUIntAttribute(node, "AdditionalRevsDecreaseSmoothing", "value");
            AdditionalGearChangeSmoothing = (ushort)Xml.GetChildUIntAttribute(node, "AdditionalGearChangeSmoothing", "value");
            AdditionalGearChangeSmoothingTime = (ushort)Xml.GetChildUIntAttribute(node, "AdditionalGearChangeSmoothingTime", "value");
            ConvertibleRoofInteriorSoundSet = XmlRel.GetHash(Xml.GetChildInnerText(node, "ConvertibleRoofInteriorSoundSet"));
            VehicleRainSoundInterior = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleRainSoundInterior"));
            CabinToneLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "CabinToneLoop"));
            InteriorViewEngineOpenness = Xml.GetChildFloatAttribute(node, "InteriorViewEngineOpenness", "value");
            JumpLandSoundInterior = XmlRel.GetHash(Xml.GetChildInnerText(node, "JumpLandSoundInterior"));
            DamagedJumpLandSoundInterior = XmlRel.GetHash(Xml.GetChildInnerText(node, "DamagedJumpLandSoundInterior"));
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { HornSounds, DoorOpenSound, DoorCloseSound, BootOpenSound, BootCloseSound, RollSound, SuspensionUp, SuspensionDown, JumpLandSound, DamagedJumpLandSound,
                IndicatorOn, IndicatorOff, Handbrake, ParkingTone, RoofStuckSound, FreewayPassbyTyreBumpFront, FreewayPassbyTyreBumpBack, FireAudio, StartupRevs, WindNoise, FreewayPassbyTyreBumpFrontSide, FreewayPassbyTyreBumpBackSide, ConvertibleRoofSoundSet,
                SirenSounds, NPCRoadNoise, NPCRoadNoiseHighway, ForkliftSounds, TurretSounds, DiggerSounds, TowTruckSounds, ReverseWarning, WindClothSound, CarSpecificShutdownSound,
                VehicleRainSound, ConvertibleRoofInteriorSoundSet, VehicleRainSoundInterior, CabinToneLoop, JumpLandSoundInterior, DamagedJumpLandSoundInterior, AlternativeGranularEngines };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { Engine, GranularEngine, VehicleCollisions, ScannerVehicleSettings, ElectricEngine };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151VehicleEngineAudioSettings : Dat151RelData
    {
        public int MasterVolume { get; set; }
        public int MaxConeAttenuation { get; set; }
        public int FXCompensation { get; set; }
        public int NonPlayerFXComp { get; set; }
        public MetaHash LowEngineLoop { get; set; }
        public MetaHash HighEngineLoop { get; set; }
        public MetaHash LowExhaustLoop { get; set; }
        public MetaHash HighExhaustLoop { get; set; }
        public MetaHash RevsOffLoop { get; set; }
        public int MinPitch { get; set; }
        public int MaxPitch { get; set; }
        public MetaHash IdleEngineSimpleLoop { get; set; }
        public MetaHash IdleExhaustSimpleLoop { get; set; }
        public int IdleMinPitch { get; set; }
        public int IdleMaxPitch { get; set; }
        public MetaHash InductionLoop { get; set; }
        public int InductionMinPitch { get; set; }
        public int InductionMaxPitch { get; set; }
        public MetaHash TurboWhine { get; set; }
        public int TurboMinPitch { get; set; }
        public int TurboMaxPitch { get; set; }
        public MetaHash DumpValve { get; set; }
        public uint DumpValveProb { get; set; }
        public uint TurboSpinupSpeed { get; set; }
        public MetaHash GearTransLoop { get; set; }
        public int GearTransMinPitch { get; set; }
        public int GearTransMaxPitch { get; set; }
        public int GTThrottleVol { get; set; }
        public MetaHash Ignition { get; set; }
        public MetaHash EngineShutdown { get; set; }
        public MetaHash CoolingFan { get; set; }
        public MetaHash ExhaustPops { get; set; }
        public MetaHash StartLoop { get; set; }
        public int MasterTurboVolume { get; set; }
        public int MasterTransmissionVolume { get; set; }
        public MetaHash EngineStartUp { get; set; }
        public MetaHash EngineSynthDef { get; set; }
        public MetaHash EngineSynthPreset { get; set; }
        public MetaHash ExhaustSynthDef { get; set; }
        public MetaHash ExhaustSynthPreset { get; set; }
        public MetaHash EngineSubmixVoice { get; set; }
        public MetaHash ExhaustSubmixVoice { get; set; }
        public int UpgradedTransmissionVolumeBoost { get; set; }
        public MetaHash UpgradedGearChangeInt { get; set; }
        public MetaHash UpgradedGearChangeExt { get; set; }
        public int UpgradedEngineVolumeBoost_PostSubmix { get; set; }
        public uint UpgradedEngineSynthDef { get; set; }
        public uint UpgradedEngineSynthPreset { get; set; }
        public int UpgradedExhaustVolumeBoost_PostSubmix { get; set; }
        public uint UpgradedExhaustSynthDef { get; set; }
        public uint UpgradedExhaustSynthPreset { get; set; }
        public MetaHash UpgradedDumpValve { get; set; }
        public int UpgradedTurboVolumeBoost { get; set; }
        public MetaHash UpgradedGearTransLoop { get; set; }
        public MetaHash UpgradedTurboWhine { get; set; }
        public MetaHash UpgradedInductionLoop { get; set; }
        public MetaHash UpgradedExhaustPops { get; set; }

        public Dat151VehicleEngineAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.VehicleEngineAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151VehicleEngineAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            MasterVolume = br.ReadInt32();
            MaxConeAttenuation = br.ReadInt32();
            FXCompensation = br.ReadInt32();
            NonPlayerFXComp = br.ReadInt32();
            LowEngineLoop = br.ReadUInt32();
            HighEngineLoop = br.ReadUInt32();
            LowExhaustLoop = br.ReadUInt32();
            HighExhaustLoop = br.ReadUInt32();
            RevsOffLoop = br.ReadUInt32();
            MinPitch = br.ReadInt32();
            MaxPitch = br.ReadInt32();
            IdleEngineSimpleLoop = br.ReadUInt32();
            IdleExhaustSimpleLoop = br.ReadUInt32();
            IdleMinPitch = br.ReadInt32();
            IdleMaxPitch = br.ReadInt32();
            InductionLoop = br.ReadUInt32();
            InductionMinPitch = br.ReadInt32();
            InductionMaxPitch = br.ReadInt32();
            TurboWhine = br.ReadUInt32();
            TurboMinPitch = br.ReadInt32();
            TurboMaxPitch = br.ReadInt32();
            DumpValve = br.ReadUInt32();
            DumpValveProb = br.ReadUInt32();
            TurboSpinupSpeed = br.ReadUInt32();
            GearTransLoop = br.ReadUInt32();
            GearTransMinPitch = br.ReadInt32();
            GearTransMaxPitch = br.ReadInt32();
            GTThrottleVol = br.ReadInt32();
            Ignition = br.ReadUInt32();
            EngineShutdown = br.ReadUInt32();
            CoolingFan = br.ReadUInt32();
            ExhaustPops = br.ReadUInt32();
            StartLoop = br.ReadUInt32();
            MasterTurboVolume = br.ReadInt32();
            MasterTransmissionVolume = br.ReadInt32();
            EngineStartUp = br.ReadUInt32();
            EngineSynthDef = br.ReadUInt32();
            EngineSynthPreset = br.ReadUInt32();
            ExhaustSynthDef = br.ReadUInt32();
            ExhaustSynthPreset = br.ReadUInt32();
            EngineSubmixVoice = br.ReadUInt32();
            ExhaustSubmixVoice = br.ReadUInt32();
            UpgradedTransmissionVolumeBoost = br.ReadInt32();
            UpgradedGearChangeInt = br.ReadUInt32();
            UpgradedGearChangeExt = br.ReadUInt32();
            UpgradedEngineVolumeBoost_PostSubmix = br.ReadInt32();
            UpgradedEngineSynthDef = br.ReadUInt32();
            UpgradedEngineSynthPreset = br.ReadUInt32();
            UpgradedExhaustVolumeBoost_PostSubmix = br.ReadInt32();
            UpgradedExhaustSynthDef = br.ReadUInt32();
            UpgradedExhaustSynthPreset = br.ReadUInt32();
            UpgradedDumpValve = br.ReadUInt32();
            UpgradedTurboVolumeBoost = br.ReadInt32();
            UpgradedGearTransLoop = br.ReadUInt32();
            UpgradedTurboWhine = br.ReadUInt32();
            UpgradedInductionLoop = br.ReadUInt32();
            UpgradedExhaustPops = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(MasterVolume);
            bw.Write(MaxConeAttenuation);
            bw.Write(FXCompensation);
            bw.Write(NonPlayerFXComp);
            bw.Write(LowEngineLoop);
            bw.Write(HighEngineLoop);
            bw.Write(LowExhaustLoop);
            bw.Write(HighExhaustLoop);
            bw.Write(RevsOffLoop);
            bw.Write(MinPitch);
            bw.Write(MaxPitch);
            bw.Write(IdleEngineSimpleLoop);
            bw.Write(IdleExhaustSimpleLoop);
            bw.Write(IdleMinPitch);
            bw.Write(IdleMaxPitch);
            bw.Write(InductionLoop);
            bw.Write(InductionMinPitch);
            bw.Write(InductionMaxPitch);
            bw.Write(TurboWhine);
            bw.Write(TurboMinPitch);
            bw.Write(TurboMaxPitch);
            bw.Write(DumpValve);
            bw.Write(DumpValveProb);
            bw.Write(TurboSpinupSpeed);
            bw.Write(GearTransLoop);
            bw.Write(GearTransMinPitch);
            bw.Write(GearTransMaxPitch);
            bw.Write(GTThrottleVol);
            bw.Write(Ignition);
            bw.Write(EngineShutdown);
            bw.Write(CoolingFan);
            bw.Write(ExhaustPops);
            bw.Write(StartLoop);
            bw.Write(MasterTurboVolume);
            bw.Write(MasterTransmissionVolume);
            bw.Write(EngineStartUp);
            bw.Write(EngineSynthDef);
            bw.Write(EngineSynthPreset);
            bw.Write(ExhaustSynthDef);
            bw.Write(ExhaustSynthPreset);
            bw.Write(EngineSubmixVoice);
            bw.Write(ExhaustSubmixVoice);
            bw.Write(UpgradedTransmissionVolumeBoost);
            bw.Write(UpgradedGearChangeInt);
            bw.Write(UpgradedGearChangeExt);
            bw.Write(UpgradedEngineVolumeBoost_PostSubmix);
            bw.Write(UpgradedEngineSynthDef);
            bw.Write(UpgradedEngineSynthPreset);
            bw.Write(UpgradedExhaustVolumeBoost_PostSubmix);
            bw.Write(UpgradedExhaustSynthDef);
            bw.Write(UpgradedExhaustSynthPreset);
            bw.Write(UpgradedDumpValve);
            bw.Write(UpgradedTurboVolumeBoost);
            bw.Write(UpgradedGearTransLoop);
            bw.Write(UpgradedTurboWhine);
            bw.Write(UpgradedInductionLoop);
            bw.Write(UpgradedExhaustPops);

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "MasterVolume", MasterVolume.ToString());
            RelXml.ValueTag(sb, indent, "MaxConeAttenuation", MaxConeAttenuation.ToString());
            RelXml.ValueTag(sb, indent, "FXCompensation", FXCompensation.ToString());
            RelXml.ValueTag(sb, indent, "NonPlayerFXComp", NonPlayerFXComp.ToString());
            RelXml.StringTag(sb, indent, "LowEngineLoop", RelXml.HashString(LowEngineLoop));
            RelXml.StringTag(sb, indent, "HighEngineLoop", RelXml.HashString(HighEngineLoop));
            RelXml.StringTag(sb, indent, "LowExhaustLoop", RelXml.HashString(LowExhaustLoop));
            RelXml.StringTag(sb, indent, "HighExhaustLoop", RelXml.HashString(HighExhaustLoop));
            RelXml.StringTag(sb, indent, "RevsOffLoop", RelXml.HashString(RevsOffLoop));
            RelXml.ValueTag(sb, indent, "MinPitch", MinPitch.ToString());
            RelXml.ValueTag(sb, indent, "MaxPitch", MaxPitch.ToString());
            RelXml.StringTag(sb, indent, "IdleEngineSimpleLoop", RelXml.HashString(IdleEngineSimpleLoop));
            RelXml.StringTag(sb, indent, "IdleExhaustSimpleLoop", RelXml.HashString(IdleExhaustSimpleLoop));
            RelXml.ValueTag(sb, indent, "IdleMinPitch", IdleMinPitch.ToString());
            RelXml.ValueTag(sb, indent, "IdleMaxPitch", IdleMaxPitch.ToString());
            RelXml.StringTag(sb, indent, "InductionLoop", RelXml.HashString(InductionLoop));
            RelXml.ValueTag(sb, indent, "InductionMinPitch", InductionMinPitch.ToString());
            RelXml.ValueTag(sb, indent, "InductionMaxPitch", InductionMaxPitch.ToString());
            RelXml.StringTag(sb, indent, "TurboWhine", RelXml.HashString(TurboWhine));
            RelXml.ValueTag(sb, indent, "TurboMinPitch", TurboMinPitch.ToString());
            RelXml.ValueTag(sb, indent, "TurboMaxPitch", TurboMaxPitch.ToString());
            RelXml.StringTag(sb, indent, "DumpValve", RelXml.HashString(DumpValve));
            RelXml.ValueTag(sb, indent, "DumpValveProb", DumpValveProb.ToString());
            RelXml.ValueTag(sb, indent, "TurboSpinupSpeed", TurboSpinupSpeed.ToString());
            RelXml.StringTag(sb, indent, "GearTransLoop", RelXml.HashString(GearTransLoop));
            RelXml.ValueTag(sb, indent, "GearTransMinPitch", GearTransMinPitch.ToString());
            RelXml.ValueTag(sb, indent, "GearTransMaxPitch", GearTransMaxPitch.ToString());
            RelXml.ValueTag(sb, indent, "GTThrottleVol", GTThrottleVol.ToString());
            RelXml.StringTag(sb, indent, "Ignition", RelXml.HashString(Ignition));
            RelXml.StringTag(sb, indent, "EngineShutdown", RelXml.HashString(EngineShutdown));
            RelXml.StringTag(sb, indent, "CoolingFan", RelXml.HashString(CoolingFan));
            RelXml.StringTag(sb, indent, "ExhaustPops", RelXml.HashString(ExhaustPops));
            RelXml.StringTag(sb, indent, "StartLoop", RelXml.HashString(StartLoop));
            RelXml.ValueTag(sb, indent, "MasterTurboVolume", MasterTurboVolume.ToString());
            RelXml.ValueTag(sb, indent, "MasterTransmissionVolume", MasterTransmissionVolume.ToString());
            RelXml.StringTag(sb, indent, "EngineStartUp", RelXml.HashString(EngineStartUp));
            RelXml.StringTag(sb, indent, "EngineSynthDef", RelXml.HashString(EngineSynthDef));
            RelXml.StringTag(sb, indent, "EngineSynthPreset", RelXml.HashString(EngineSynthPreset));
            RelXml.StringTag(sb, indent, "ExhaustSynthDef", RelXml.HashString(ExhaustSynthDef));
            RelXml.StringTag(sb, indent, "ExhaustSynthPreset", RelXml.HashString(ExhaustSynthPreset));
            RelXml.StringTag(sb, indent, "EngineSubmixVoice", RelXml.HashString(EngineSubmixVoice));
            RelXml.StringTag(sb, indent, "ExhaustSubmixVoice", RelXml.HashString(ExhaustSubmixVoice));
            RelXml.ValueTag(sb, indent, "UpgradedTransmissionVolumeBoost", UpgradedTransmissionVolumeBoost.ToString());
            RelXml.StringTag(sb, indent, "UpgradedGearChangeInt", RelXml.HashString(UpgradedGearChangeInt));
            RelXml.StringTag(sb, indent, "UpgradedGearChangeExt", RelXml.HashString(UpgradedGearChangeExt));
            RelXml.ValueTag(sb, indent, "UpgradedEngineVolumeBoost_PostSubmix", UpgradedEngineVolumeBoost_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "UpgradedEngineSynthDef", UpgradedEngineSynthDef.ToString());
            RelXml.ValueTag(sb, indent, "UpgradedEngineSynthPreset", UpgradedEngineSynthPreset.ToString());
            RelXml.ValueTag(sb, indent, "UpgradedExhaustVolumeBoost_PostSubmix", UpgradedExhaustVolumeBoost_PostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "UpgradedExhaustSynthDef", UpgradedExhaustSynthDef.ToString());
            RelXml.ValueTag(sb, indent, "UpgradedExhaustSynthPreset", UpgradedExhaustSynthPreset.ToString());
            RelXml.StringTag(sb, indent, "UpgradedDumpValve", RelXml.HashString(UpgradedDumpValve));
            RelXml.ValueTag(sb, indent, "UpgradedTurboVolumeBoost", UpgradedTurboVolumeBoost.ToString());
            RelXml.StringTag(sb, indent, "UpgradedGearTransLoop", RelXml.HashString(UpgradedGearTransLoop));
            RelXml.StringTag(sb, indent, "UpgradedTurboWhine", RelXml.HashString(UpgradedTurboWhine));
            RelXml.StringTag(sb, indent, "UpgradedInductionLoop", RelXml.HashString(UpgradedInductionLoop));
            RelXml.StringTag(sb, indent, "UpgradedExhaustPops", RelXml.HashString(UpgradedExhaustPops));
        }
        public override void ReadXml(XmlNode node)
        {
            MasterVolume = Xml.GetChildIntAttribute(node, "MasterVolume", "value");
            MaxConeAttenuation = Xml.GetChildIntAttribute(node, "MaxConeAttenuation", "value");
            FXCompensation = Xml.GetChildIntAttribute(node, "FXCompensation", "value");
            NonPlayerFXComp = Xml.GetChildIntAttribute(node, "NonPlayerFXComp", "value");
            LowEngineLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "LowEngineLoop"));
            HighEngineLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "HighEngineLoop"));
            LowExhaustLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "LowExhaustLoop"));
            HighExhaustLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "HighExhaustLoop"));
            RevsOffLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "RevsOffLoop"));
            MinPitch = Xml.GetChildIntAttribute(node, "MinPitch", "value");
            MaxPitch = Xml.GetChildIntAttribute(node, "MaxPitch", "value");
            IdleEngineSimpleLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "IdleEngineSimpleLoop"));
            IdleExhaustSimpleLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "IdleExhaustSimpleLoop"));
            IdleMinPitch = Xml.GetChildIntAttribute(node, "IdleMinPitch", "value");
            IdleMaxPitch = Xml.GetChildIntAttribute(node, "IdleMaxPitch", "value");
            InductionLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "InductionLoop"));
            InductionMinPitch = Xml.GetChildIntAttribute(node, "InductionMinPitch", "value");
            InductionMaxPitch = Xml.GetChildIntAttribute(node, "InductionMaxPitch", "value");
            TurboWhine = XmlRel.GetHash(Xml.GetChildInnerText(node, "TurboWhine"));
            TurboMinPitch = Xml.GetChildIntAttribute(node, "TurboMinPitch", "value");
            TurboMaxPitch = Xml.GetChildIntAttribute(node, "TurboMaxPitch", "value");
            DumpValve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DumpValve"));
            DumpValveProb = Xml.GetChildUIntAttribute(node, "DumpValveProb", "value");
            TurboSpinupSpeed = Xml.GetChildUIntAttribute(node, "TurboSpinupSpeed", "value");
            GearTransLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "GearTransLoop"));
            GearTransMinPitch = Xml.GetChildIntAttribute(node, "GearTransMinPitch", "value");
            GearTransMaxPitch = Xml.GetChildIntAttribute(node, "GearTransMaxPitch", "value");
            GTThrottleVol = Xml.GetChildIntAttribute(node, "GTThrottleVol", "value");
            Ignition = XmlRel.GetHash(Xml.GetChildInnerText(node, "Ignition"));
            EngineShutdown = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineShutdown"));
            CoolingFan = XmlRel.GetHash(Xml.GetChildInnerText(node, "CoolingFan"));
            ExhaustPops = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustPops"));
            StartLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "StartLoop"));
            MasterTurboVolume = Xml.GetChildIntAttribute(node, "MasterTurboVolume", "value");
            MasterTransmissionVolume = Xml.GetChildIntAttribute(node, "MasterTransmissionVolume", "value");
            EngineStartUp = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineStartUp"));
            EngineSynthDef = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSynthDef"));
            EngineSynthPreset = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSynthPreset"));
            ExhaustSynthDef = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSynthDef"));
            ExhaustSynthPreset = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSynthPreset"));
            EngineSubmixVoice = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSubmixVoice"));
            ExhaustSubmixVoice = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSubmixVoice"));
            UpgradedTransmissionVolumeBoost = Xml.GetChildIntAttribute(node, "UpgradedTransmissionVolumeBoost", "value");
            UpgradedGearChangeInt = XmlRel.GetHash(Xml.GetChildInnerText(node, "UpgradedGearChangeInt"));
            UpgradedGearChangeExt = XmlRel.GetHash(Xml.GetChildInnerText(node, "UpgradedGearChangeExt"));
            UpgradedEngineVolumeBoost_PostSubmix = Xml.GetChildIntAttribute(node, "UpgradedEngineVolumeBoost_PostSubmix", "value");
            UpgradedEngineSynthDef = Xml.GetChildUIntAttribute(node, "UpgradedEngineSynthDef", "value");
            UpgradedEngineSynthPreset = Xml.GetChildUIntAttribute(node, "UpgradedEngineSynthPreset", "value");
            UpgradedExhaustVolumeBoost_PostSubmix = Xml.GetChildIntAttribute(node, "UpgradedExhaustVolumeBoost_PostSubmix", "value");
            UpgradedExhaustSynthDef = Xml.GetChildUIntAttribute(node, "UpgradedExhaustSynthDef", "value");
            UpgradedExhaustSynthPreset = Xml.GetChildUIntAttribute(node, "UpgradedExhaustSynthPreset", "value");
            UpgradedDumpValve = XmlRel.GetHash(Xml.GetChildInnerText(node, "UpgradedDumpValve"));
            UpgradedTurboVolumeBoost = Xml.GetChildIntAttribute(node, "UpgradedTurboVolumeBoost", "value");
            UpgradedGearTransLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "UpgradedGearTransLoop"));
            UpgradedTurboWhine = XmlRel.GetHash(Xml.GetChildInnerText(node, "UpgradedTurboWhine"));
            UpgradedInductionLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "UpgradedInductionLoop"));
            UpgradedExhaustPops = XmlRel.GetHash(Xml.GetChildInnerText(node, "UpgradedExhaustPops"));
        }
        public override MetaHash[] GetSynthHashes()
        {
            return new[] { EngineSynthDef, EngineSynthPreset, ExhaustSynthDef, ExhaustSynthPreset };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { LowEngineLoop, HighEngineLoop, LowExhaustLoop, HighExhaustLoop, RevsOffLoop, IdleEngineSimpleLoop, IdleExhaustSimpleLoop, InductionLoop, TurboWhine, DumpValve,
                GearTransLoop, Ignition, EngineShutdown, CoolingFan, ExhaustPops, StartLoop, EngineStartUp, EngineSubmixVoice, ExhaustSubmixVoice,
                UpgradedGearChangeInt, UpgradedGearChangeExt, UpgradedDumpValve, UpgradedGearTransLoop,
                UpgradedTurboWhine, UpgradedInductionLoop, UpgradedExhaustPops };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ScannerVehicleParams : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public int ParamCount { get; set; }
        public Param[] Params;

        public class Param : IMetaXmlItem
        {
            public MetaHash Manufacturer { get; set; }
            public MetaHash Model { get; set; }
            public MetaHash Category { get; set; }
            public MetaHash ColorOverride { get; set; }

            public Param()
            { }
            public Param(BinaryReader br)
            {
                Manufacturer = br.ReadUInt32();
                Model = br.ReadUInt32();
                Category = br.ReadUInt32();
                ColorOverride = br.ReadUInt32();
            }
            public void Write(BinaryWriter bw)
            {
                bw.Write(Manufacturer);
                bw.Write(Model);
                bw.Write(Category);
                bw.Write(ColorOverride);
            }
            public void WriteXml(StringBuilder sb, int indent)
            {
                RelXml.StringTag(sb, indent, "Manufacturer", RelXml.HashString(Manufacturer));
                RelXml.StringTag(sb, indent, "Model", RelXml.HashString(Model));
                RelXml.StringTag(sb, indent, "Category", RelXml.HashString(Category));
                RelXml.StringTag(sb, indent, "ColorOverride", RelXml.HashString(ColorOverride));
            }
            public void ReadXml(XmlNode node)
            {
                Manufacturer = XmlRel.GetHash(Xml.GetChildInnerText(node, "Manufacturer"));
                Model = XmlRel.GetHash(Xml.GetChildInnerText(node, "Model"));
                Category = XmlRel.GetHash(Xml.GetChildInnerText(node, "Category"));
                ColorOverride = XmlRel.GetHash(Xml.GetChildInnerText(node, "ColorOverride"));
            }
        }

        public Dat151ScannerVehicleParams(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ScannerVehicleParams;
            TypeID = (byte)Type;
        }
        public Dat151ScannerVehicleParams(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            ParamCount = br.ReadInt32();
            Params = new Param[ParamCount];
            for (int i = 0; i < ParamCount; i++)
            {
                Params[i] = new Param(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(ParamCount);
            for (int i = 0; i < ParamCount; i++)
            {
                Params[i].Write(bw);
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.WriteItemArray(sb, Params, indent, "Params");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Params = XmlRel.ReadItemArray<Param>(node, "Params");
            ParamCount = (Params?.Length ?? 0);
        }
        public override MetaHash[] GetSoundHashes()
        {
            var list = new List<MetaHash>();
            foreach (var p in Params)
            {
                list.Add(p.Manufacturer);
                list.Add(p.Model);
                list.Add(p.Category);
                list.Add(p.ColorOverride);
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151WeaponSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash FireSound { get; set; }
        public MetaHash SuppressedFireSound { get; set; }
        public MetaHash AutoSound { get; set; }
        public MetaHash ReportSound { get; set; }
        public float ReportVolumeDelta { get; set; }
        public int ReportPredelayDelta { get; set; }
        public float TailEnergyValue { get; set; }
        public MetaHash EchoSound { get; set; }
        public MetaHash SuppressedEchoSound { get; set; }
        public MetaHash ShellCasingSound { get; set; }
        public MetaHash SwipeSound { get; set; }
        public MetaHash GeneralStrikeSound { get; set; }
        public MetaHash PedStrikeSound { get; set; }
        public MetaHash HeftSound { get; set; }
        public MetaHash PutDownSound { get; set; }
        public MetaHash RattleSound { get; set; }
        public MetaHash RattleLandSound { get; set; }
        public MetaHash PickupSound { get; set; }
        public int ShellCasing { get; set; }
        public MetaHash SafetyOn { get; set; }
        public MetaHash SafetyOff { get; set; }
        public MetaHash SpecialWeaponSoundSet { get; set; }
        public MetaHash BankSound { get; set; }
        public MetaHash InteriorShotSound { get; set; }
        public MetaHash ReloadSounds { get; set; }
        public MetaHash IntoCoverSound { get; set; }
        public MetaHash OutOfCoverSound { get; set; }
        public int BulletImpactTimeFilter { get; set; }
        public int LastBulletImpactTime { get; set; }
        public MetaHash RattleAimSound { get; set; }
        public MetaHash SmallAnimalStrikeSound { get; set; }
        public MetaHash BigAnimalStrikeSound { get; set; }
        public MetaHash SlowMoFireSound { get; set; }
        public MetaHash HitPedSound { get; set; }
        public MetaHash SlowMoFireSoundPresuck { get; set; }
        public MetaHash SlowMoSuppressedFireSound { get; set; }
        public MetaHash SlowMoSuppressedFireSoundPresuck { get; set; }
        public MetaHash SlowMoReportSound { get; set; }
        public MetaHash SlowMoInteriorShotSound { get; set; }
        public MetaHash SlowMoPedStrikeSound { get; set; }
        public MetaHash SlowMoPedStrikeSoundPresuck { get; set; }
        public MetaHash SlowMoBigAnimalStrikeSound { get; set; }
        public MetaHash SlowMoBigAnimalStrikeSoundPresuck { get; set; }
        public MetaHash SlowMoSmallAnimalStrikeSound { get; set; }
        public MetaHash SlowMoSmallAnimalStrikeSoundPresuck { get; set; }
        public int SlowMoFireSoundPresuckTime { get; set; }
        public int SlowMoSuppressedFireSoundPresuckTime { get; set; }
        public int SlowMoPedStrikeSoundPresuckTime { get; set; }
        public int SlowMoBigAnimalStrikeSoundPresuckTime { get; set; }
        public int SlowMoSmallAnimalStrikeSoundPresuckTime { get; set; }
        public MetaHash SuperSlowMoFireSound { get; set; }
        public MetaHash SuperSlowMoFireSoundPresuck { get; set; }
        public MetaHash SuperSlowMoSuppressedFireSound { get; set; }
        public MetaHash SuperSlowMoSuppressedFireSoundPresuck { get; set; }
        public MetaHash SuperSlowMoReportSound { get; set; }
        public MetaHash SuperSlowMoInteriorShotSound { get; set; }
        public MetaHash SuperSlowMoPedStrikeSound { get; set; }
        public MetaHash SuperSlowMoPedStrikeSoundPresuck { get; set; }
        public MetaHash SuperSlowMoBigAnimalStrikeSound { get; set; }
        public MetaHash SuperSlowMoBigAnimalStrikeSoundPresuck { get; set; }
        public MetaHash SuperSlowMoSmallAnimalStrikeSound { get; set; }
        public MetaHash SuperSlowMoSmallAnimalStrikeSoundPresuck { get; set; }
        public int SuperSlowMoFireSoundPresuckTime { get; set; }
        public int SuperSlowMoSuppressedFireSoundPresuckTime { get; set; }
        public int SuperSlowMoPedStrikeSoundPresuckTime { get; set; }
        public int SuperSlowMoBigAnimalStrikeSoundPresuckTime { get; set; }
        public int SuperSlowMoSmallAnimalStrikeSoundPresuckTime { get; set; }

        public int Version { get; set; }


        public Dat151WeaponSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.WeaponSettings;
            TypeID = (byte)Type;
        }
        public Dat151WeaponSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            FireSound = br.ReadUInt32();
            SuppressedFireSound = br.ReadUInt32();
            AutoSound = br.ReadUInt32();
            ReportSound = br.ReadUInt32();
            ReportVolumeDelta = br.ReadSingle();
            ReportPredelayDelta = br.ReadInt32();
            TailEnergyValue = br.ReadSingle();
            EchoSound = br.ReadUInt32();
            SuppressedEchoSound = br.ReadUInt32();
            ShellCasingSound = br.ReadUInt32();
            SwipeSound = br.ReadUInt32();
            GeneralStrikeSound = br.ReadUInt32();
            PedStrikeSound = br.ReadUInt32();
            HeftSound = br.ReadUInt32();
            PutDownSound = br.ReadUInt32();
            RattleSound = br.ReadUInt32();
            RattleLandSound = br.ReadUInt32();
            PickupSound = br.ReadUInt32();
            ShellCasing = br.ReadInt32();
            SafetyOn = br.ReadUInt32();
            SafetyOff = br.ReadUInt32();
            SpecialWeaponSoundSet = br.ReadUInt32();
            BankSound = br.ReadUInt32();
            InteriorShotSound = br.ReadUInt32();
            ReloadSounds = br.ReadUInt32();
            IntoCoverSound = br.ReadUInt32();
            OutOfCoverSound = br.ReadUInt32();
            BulletImpactTimeFilter = br.ReadInt32();
            LastBulletImpactTime = br.ReadInt32();
            RattleAimSound = br.ReadUInt32();
            SmallAnimalStrikeSound = br.ReadUInt32();
            BigAnimalStrikeSound = br.ReadUInt32();
            SlowMoFireSound = br.ReadUInt32();
            HitPedSound = br.ReadUInt32();

            Version = 0;

            var bytesleft = br.BaseStream.Length - br.BaseStream.Position;
            if (bytesleft > 0)
            {
                Version = 1;
                SlowMoFireSoundPresuck = br.ReadUInt32();
                SlowMoSuppressedFireSound = br.ReadUInt32();
                SlowMoSuppressedFireSoundPresuck = br.ReadUInt32();
                SlowMoReportSound = br.ReadUInt32();
                SlowMoInteriorShotSound = br.ReadUInt32();
                SlowMoPedStrikeSound = br.ReadUInt32();
                SlowMoPedStrikeSoundPresuck = br.ReadUInt32();
                SlowMoBigAnimalStrikeSound = br.ReadUInt32();
                SlowMoBigAnimalStrikeSoundPresuck = br.ReadUInt32();
                SlowMoSmallAnimalStrikeSound = br.ReadUInt32();
                SlowMoSmallAnimalStrikeSoundPresuck = br.ReadUInt32();
                SlowMoFireSoundPresuckTime = br.ReadInt32();
                SlowMoSuppressedFireSoundPresuckTime = br.ReadInt32();

                if (bytesleft >= 64)
                {
                    Version = 2;
                    SlowMoPedStrikeSoundPresuckTime = br.ReadInt32();
                    SlowMoBigAnimalStrikeSoundPresuckTime = br.ReadInt32();
                    SlowMoSmallAnimalStrikeSoundPresuckTime = br.ReadInt32();

                    if (bytesleft >= 132)
                    {
                        Version = 3;
                        SuperSlowMoFireSound = br.ReadUInt32();
                        SuperSlowMoFireSoundPresuck = br.ReadUInt32();
                        SuperSlowMoSuppressedFireSound = br.ReadUInt32();
                        SuperSlowMoSuppressedFireSoundPresuck = br.ReadUInt32();
                        SuperSlowMoReportSound = br.ReadUInt32();
                        SuperSlowMoInteriorShotSound = br.ReadUInt32();
                        SuperSlowMoPedStrikeSound = br.ReadUInt32();
                        SuperSlowMoPedStrikeSoundPresuck = br.ReadUInt32();
                        SuperSlowMoBigAnimalStrikeSound = br.ReadUInt32();
                        SuperSlowMoBigAnimalStrikeSoundPresuck = br.ReadUInt32();
                        SuperSlowMoSmallAnimalStrikeSound = br.ReadUInt32();
                        SuperSlowMoSmallAnimalStrikeSoundPresuck = br.ReadUInt32();
                        SuperSlowMoFireSoundPresuckTime = br.ReadInt32();
                        SuperSlowMoSuppressedFireSoundPresuckTime = br.ReadInt32();
                        SuperSlowMoPedStrikeSoundPresuckTime = br.ReadInt32();
                        SuperSlowMoBigAnimalStrikeSoundPresuckTime = br.ReadInt32();
                        SuperSlowMoSmallAnimalStrikeSoundPresuckTime = br.ReadInt32();
                    }
                }
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(FireSound);
            bw.Write(SuppressedFireSound);
            bw.Write(AutoSound);
            bw.Write(ReportSound);
            bw.Write(ReportVolumeDelta);
            bw.Write(ReportPredelayDelta);
            bw.Write(TailEnergyValue);
            bw.Write(EchoSound);
            bw.Write(SuppressedEchoSound);
            bw.Write(ShellCasingSound);
            bw.Write(SwipeSound);
            bw.Write(GeneralStrikeSound);
            bw.Write(PedStrikeSound);
            bw.Write(HeftSound);
            bw.Write(PutDownSound);
            bw.Write(RattleSound);
            bw.Write(RattleLandSound);
            bw.Write(PickupSound);
            bw.Write(ShellCasing);
            bw.Write(SafetyOn);
            bw.Write(SafetyOff);
            bw.Write(SpecialWeaponSoundSet);
            bw.Write(BankSound);
            bw.Write(InteriorShotSound);
            bw.Write(ReloadSounds);
            bw.Write(IntoCoverSound);
            bw.Write(OutOfCoverSound);
            bw.Write(BulletImpactTimeFilter);
            bw.Write(LastBulletImpactTime);
            bw.Write(RattleAimSound);
            bw.Write(SmallAnimalStrikeSound);
            bw.Write(BigAnimalStrikeSound);
            bw.Write(SlowMoFireSound);
            bw.Write(HitPedSound);

            if (Version >= 1) // if version 1, write values (132 bytes left)
            {
                bw.Write(SlowMoFireSoundPresuck);
                bw.Write(SlowMoSuppressedFireSound);
                bw.Write(SlowMoSuppressedFireSoundPresuck);
                bw.Write(SlowMoReportSound);
                bw.Write(SlowMoInteriorShotSound);
                bw.Write(SlowMoPedStrikeSound);
                bw.Write(SlowMoPedStrikeSoundPresuck);
                bw.Write(SlowMoBigAnimalStrikeSound);
                bw.Write(SlowMoBigAnimalStrikeSoundPresuck);
                bw.Write(SlowMoSmallAnimalStrikeSound);
                bw.Write(SlowMoSmallAnimalStrikeSoundPresuck);
                bw.Write(SlowMoFireSoundPresuckTime);
                bw.Write(SlowMoSuppressedFireSoundPresuckTime);

                if (Version >= 2) // if version 2, write values (greater or equal to 64)
                {
                    bw.Write(SlowMoPedStrikeSoundPresuckTime);
                    bw.Write(SlowMoBigAnimalStrikeSoundPresuckTime);
                    bw.Write(SlowMoSmallAnimalStrikeSoundPresuckTime);

                    if (Version >= 3) // if version 3, write values (greater or equal to 132)
                    {
                        bw.Write(SuperSlowMoFireSound);
                        bw.Write(SuperSlowMoFireSoundPresuck);
                        bw.Write(SuperSlowMoSuppressedFireSound);
                        bw.Write(SuperSlowMoSuppressedFireSoundPresuck);
                        bw.Write(SuperSlowMoReportSound);
                        bw.Write(SuperSlowMoInteriorShotSound);
                        bw.Write(SuperSlowMoPedStrikeSound);
                        bw.Write(SuperSlowMoPedStrikeSoundPresuck);
                        bw.Write(SuperSlowMoBigAnimalStrikeSound);
                        bw.Write(SuperSlowMoBigAnimalStrikeSoundPresuck);
                        bw.Write(SuperSlowMoSmallAnimalStrikeSound);
                        bw.Write(SuperSlowMoSmallAnimalStrikeSoundPresuck);
                        bw.Write(SuperSlowMoFireSoundPresuckTime);
                        bw.Write(SuperSlowMoSuppressedFireSoundPresuckTime);
                        bw.Write(SuperSlowMoPedStrikeSoundPresuckTime);
                        bw.Write(SuperSlowMoBigAnimalStrikeSoundPresuckTime);
                        bw.Write(SuperSlowMoSmallAnimalStrikeSoundPresuckTime);
                    }
                }
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Version", Version.ToString());
            RelXml.StringTag(sb, indent, "FireSound", RelXml.HashString(FireSound));
            RelXml.StringTag(sb, indent, "SuppressedFireSound", RelXml.HashString(SuppressedFireSound));
            RelXml.StringTag(sb, indent, "AutoSound", RelXml.HashString(AutoSound));
            RelXml.StringTag(sb, indent, "ReportSound", RelXml.HashString(ReportSound));
            RelXml.ValueTag(sb, indent, "ReportVolumeDelta", FloatUtil.ToString(ReportVolumeDelta));
            RelXml.ValueTag(sb, indent, "ReportPredelayDelta", ReportPredelayDelta.ToString());
            RelXml.ValueTag(sb, indent, "TailEnergyValue", FloatUtil.ToString(TailEnergyValue));
            RelXml.StringTag(sb, indent, "EchoSound", RelXml.HashString(EchoSound));
            RelXml.StringTag(sb, indent, "SuppressedEchoSound", RelXml.HashString(SuppressedEchoSound));
            RelXml.StringTag(sb, indent, "ShellCasingSound", RelXml.HashString(ShellCasingSound));
            RelXml.StringTag(sb, indent, "SwipeSound", RelXml.HashString(SwipeSound));
            RelXml.StringTag(sb, indent, "GeneralStrikeSound", RelXml.HashString(GeneralStrikeSound));
            RelXml.StringTag(sb, indent, "PedStrikeSound", RelXml.HashString(PedStrikeSound));
            RelXml.StringTag(sb, indent, "HeftSound", RelXml.HashString(HeftSound));
            RelXml.StringTag(sb, indent, "PutDownSound", RelXml.HashString(PutDownSound));
            RelXml.StringTag(sb, indent, "RattleSound", RelXml.HashString(RattleSound));
            RelXml.StringTag(sb, indent, "RattleLandSound", RelXml.HashString(RattleLandSound));
            RelXml.StringTag(sb, indent, "PickupSound", RelXml.HashString(PickupSound));
            RelXml.ValueTag(sb, indent, "ShellCasing", ShellCasing.ToString());
            RelXml.StringTag(sb, indent, "SafetyOn", RelXml.HashString(SafetyOn));
            RelXml.StringTag(sb, indent, "SafetyOff", RelXml.HashString(SafetyOff));
            RelXml.StringTag(sb, indent, "SpecialWeaponSoundSet", RelXml.HashString(SpecialWeaponSoundSet));
            RelXml.StringTag(sb, indent, "BankSound", RelXml.HashString(BankSound));
            RelXml.StringTag(sb, indent, "InteriorShotSound", RelXml.HashString(InteriorShotSound));
            RelXml.StringTag(sb, indent, "ReloadSounds", RelXml.HashString(ReloadSounds));
            RelXml.StringTag(sb, indent, "IntoCoverSound", RelXml.HashString(IntoCoverSound));
            RelXml.StringTag(sb, indent, "OutOfCoverSound", RelXml.HashString(OutOfCoverSound));
            RelXml.ValueTag(sb, indent, "BulletImpactTimeFilter", BulletImpactTimeFilter.ToString());
            RelXml.ValueTag(sb, indent, "LastBulletImpactTime", LastBulletImpactTime.ToString());
            RelXml.StringTag(sb, indent, "RattleAimSound", RelXml.HashString(RattleAimSound));
            RelXml.StringTag(sb, indent, "SmallAnimalStrikeSound", RelXml.HashString(SmallAnimalStrikeSound));
            RelXml.StringTag(sb, indent, "BigAnimalStrikeSound", RelXml.HashString(BigAnimalStrikeSound));
            RelXml.StringTag(sb, indent, "SlowMoFireSound", RelXml.HashString(SlowMoFireSound));
            RelXml.StringTag(sb, indent, "HitPedSound", RelXml.HashString(HitPedSound));

            if (Version >= 1)
            {
                RelXml.StringTag(sb, indent, "SlowMoFireSoundPresuck", RelXml.HashString(SlowMoFireSoundPresuck));
                RelXml.StringTag(sb, indent, "SlowMoSuppressedFireSound", RelXml.HashString(SlowMoSuppressedFireSound));
                RelXml.StringTag(sb, indent, "SlowMoSuppressedFireSoundPresuck", RelXml.HashString(SlowMoSuppressedFireSoundPresuck));
                RelXml.StringTag(sb, indent, "SlowMoReportSound", RelXml.HashString(SlowMoReportSound));
                RelXml.StringTag(sb, indent, "SlowMoInteriorShotSound", RelXml.HashString(SlowMoInteriorShotSound));
                RelXml.StringTag(sb, indent, "SlowMoPedStrikeSound", RelXml.HashString(SlowMoPedStrikeSound));
                RelXml.StringTag(sb, indent, "SlowMoPedStrikeSoundPresuck", RelXml.HashString(SlowMoPedStrikeSoundPresuck));
                RelXml.StringTag(sb, indent, "SlowMoBigAnimalStrikeSound", RelXml.HashString(SlowMoBigAnimalStrikeSound));
                RelXml.StringTag(sb, indent, "SlowMoBigAnimalStrikeSoundPresuck", RelXml.HashString(SlowMoBigAnimalStrikeSoundPresuck));
                RelXml.StringTag(sb, indent, "SlowMoSmallAnimalStrikeSound", RelXml.HashString(SlowMoSmallAnimalStrikeSound));
                RelXml.StringTag(sb, indent, "SlowMoSmallAnimalStrikeSoundPresuck", RelXml.HashString(SlowMoSmallAnimalStrikeSoundPresuck));
                RelXml.ValueTag(sb, indent, "SlowMoFireSoundPresuckTime", SlowMoFireSoundPresuckTime.ToString());
                RelXml.ValueTag(sb, indent, "SlowMoSuppressedFireSoundPresuckTime", SlowMoSuppressedFireSoundPresuckTime.ToString());

                if (Version >= 2)
                {
                    RelXml.ValueTag(sb, indent, "SlowMoPedStrikeSoundPresuckTime", SlowMoPedStrikeSoundPresuckTime.ToString());
                    RelXml.ValueTag(sb, indent, "SlowMoBigAnimalStrikeSoundPresuckTime", SlowMoBigAnimalStrikeSoundPresuckTime.ToString());
                    RelXml.ValueTag(sb, indent, "SlowMoSmallAnimalStrikeSoundPresuckTime", SlowMoSmallAnimalStrikeSoundPresuckTime.ToString());

                    if (Version >= 3)
                    {
                        RelXml.StringTag(sb, indent, "SuperSlowMoFireSound", RelXml.HashString(SuperSlowMoFireSound));
                        RelXml.StringTag(sb, indent, "SuperSlowMoFireSoundPresuck", RelXml.HashString(SuperSlowMoFireSoundPresuck));
                        RelXml.StringTag(sb, indent, "SuperSlowMoSuppressedFireSound", RelXml.HashString(SuperSlowMoSuppressedFireSound));
                        RelXml.StringTag(sb, indent, "SuperSlowMoSuppressedFireSoundPresuck", RelXml.HashString(SuperSlowMoSuppressedFireSoundPresuck));
                        RelXml.StringTag(sb, indent, "SuperSlowMoReportSound", RelXml.HashString(SuperSlowMoReportSound));
                        RelXml.StringTag(sb, indent, "SuperSlowMoInteriorShotSound", RelXml.HashString(SuperSlowMoInteriorShotSound));
                        RelXml.StringTag(sb, indent, "SuperSlowMoPedStrikeSound", RelXml.HashString(SuperSlowMoPedStrikeSound));
                        RelXml.StringTag(sb, indent, "SuperSlowMoPedStrikeSoundPresuck", RelXml.HashString(SuperSlowMoPedStrikeSoundPresuck));
                        RelXml.StringTag(sb, indent, "SuperSlowMoBigAnimalStrikeSound", RelXml.HashString(SuperSlowMoBigAnimalStrikeSound));
                        RelXml.StringTag(sb, indent, "SuperSlowMoBigAnimalStrikeSoundPresuck", RelXml.HashString(SuperSlowMoBigAnimalStrikeSoundPresuck));
                        RelXml.StringTag(sb, indent, "SuperSlowMoSmallAnimalStrikeSound", RelXml.HashString(SuperSlowMoSmallAnimalStrikeSound));
                        RelXml.StringTag(sb, indent, "SuperSlowMoSmallAnimalStrikeSoundPresuck", RelXml.HashString(SuperSlowMoSmallAnimalStrikeSoundPresuck));
                        RelXml.ValueTag(sb, indent, "SuperSlowMoFireSoundPresuckTime", SuperSlowMoFireSoundPresuckTime.ToString());
                        RelXml.ValueTag(sb, indent, "SuperSlowMoSuppressedFireSoundPresuckTime", SuperSlowMoSuppressedFireSoundPresuckTime.ToString());
                        RelXml.ValueTag(sb, indent, "SuperSlowMoPedStrikeSoundPresuckTime", SuperSlowMoPedStrikeSoundPresuckTime.ToString());
                        RelXml.ValueTag(sb, indent, "SuperSlowMoBigAnimalStrikeSoundPresuckTime", SuperSlowMoBigAnimalStrikeSoundPresuckTime.ToString());
                        RelXml.ValueTag(sb, indent, "SuperSlowMoSmallAnimalStrikeSoundPresuckTime", SuperSlowMoSmallAnimalStrikeSoundPresuckTime.ToString());
                    }
                }
            }
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Version = Xml.GetChildIntAttribute(node, "Version", "value");
            FireSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "FireSound"));
            SuppressedFireSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuppressedFireSound"));
            AutoSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "AutoSound"));
            ReportSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ReportSound"));
            ReportVolumeDelta = Xml.GetChildFloatAttribute(node, "ReportVolumeDelta", "value");
            ReportPredelayDelta = Xml.GetChildIntAttribute(node, "ReportPredelayDelta", "value");
            TailEnergyValue = Xml.GetChildFloatAttribute(node, "TailEnergyValue", "value");
            EchoSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "EchoSound"));
            SuppressedEchoSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuppressedEchoSound"));
            ShellCasingSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ShellCasingSound"));
            SwipeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SwipeSound"));
            GeneralStrikeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "GeneralStrikeSound"));
            PedStrikeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "PedStrikeSound"));
            HeftSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "HeftSound"));
            PutDownSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "PutDownSound"));
            RattleSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RattleSound"));
            RattleLandSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RattleLandSound"));
            PickupSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "PickupSound"));
            ShellCasing = Xml.GetChildIntAttribute(node, "ShellCasing", "value");
            SafetyOn = XmlRel.GetHash(Xml.GetChildInnerText(node, "SafetyOn"));
            SafetyOff = XmlRel.GetHash(Xml.GetChildInnerText(node, "SafetyOff"));
            SpecialWeaponSoundSet = XmlRel.GetHash(Xml.GetChildInnerText(node, "SpecialWeaponSoundSet"));
            BankSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankSound"));
            InteriorShotSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "InteriorShotSound"));
            ReloadSounds = XmlRel.GetHash(Xml.GetChildInnerText(node, "ReloadSounds"));
            IntoCoverSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "IntoCoverSound"));
            OutOfCoverSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "OutOfCoverSound"));
            BulletImpactTimeFilter = Xml.GetChildIntAttribute(node, "BulletImpactTimeFilter", "value");
            LastBulletImpactTime = Xml.GetChildIntAttribute(node, "LastBulletImpactTime", "value");
            RattleAimSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RattleAimSound"));
            SmallAnimalStrikeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SmallAnimalStrikeSound"));
            BigAnimalStrikeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BigAnimalStrikeSound"));
            SlowMoFireSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoFireSound"));
            HitPedSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "HitPedSound"));

            if (Version >= 1)
            {
                SlowMoFireSoundPresuck = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoFireSoundPresuck"));
                SlowMoSuppressedFireSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoSuppressedFireSound"));
                SlowMoSuppressedFireSoundPresuck = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoSuppressedFireSoundPresuck"));
                SlowMoReportSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoReportSound"));
                SlowMoInteriorShotSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoInteriorShotSound"));
                SlowMoPedStrikeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoPedStrikeSound"));
                SlowMoPedStrikeSoundPresuck = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoPedStrikeSoundPresuck"));
                SlowMoBigAnimalStrikeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoBigAnimalStrikeSound"));
                SlowMoBigAnimalStrikeSoundPresuck = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoBigAnimalStrikeSoundPresuck"));
                SlowMoSmallAnimalStrikeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoSmallAnimalStrikeSound"));
                SlowMoSmallAnimalStrikeSoundPresuck = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoSmallAnimalStrikeSoundPresuck"));
                SlowMoFireSoundPresuckTime = Xml.GetChildIntAttribute(node, "SlowMoFireSoundPresuckTime", "value");
                SlowMoSuppressedFireSoundPresuckTime = Xml.GetChildIntAttribute(node, "SlowMoSuppressedFireSoundPresuckTime", "value");

                if (Version >= 2)
                {
                    SlowMoPedStrikeSoundPresuckTime = Xml.GetChildIntAttribute(node, "SlowMoPedStrikeSoundPresuckTime", "value");
                    SlowMoBigAnimalStrikeSoundPresuckTime = Xml.GetChildIntAttribute(node, "SlowMoBigAnimalStrikeSoundPresuckTime", "value");
                    SlowMoSmallAnimalStrikeSoundPresuckTime = Xml.GetChildIntAttribute(node, "SlowMoSmallAnimalStrikeSoundPresuckTime", "value");

                    if (Version >= 3)
                    {
                        SuperSlowMoFireSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuperSlowMoFireSound"));
                        SuperSlowMoFireSoundPresuck = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuperSlowMoFireSoundPresuck"));
                        SuperSlowMoSuppressedFireSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuperSlowMoSuppressedFireSound"));
                        SuperSlowMoSuppressedFireSoundPresuck = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuperSlowMoSuppressedFireSoundPresuck"));
                        SuperSlowMoReportSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuperSlowMoReportSound"));
                        SuperSlowMoInteriorShotSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuperSlowMoInteriorShotSound"));
                        SuperSlowMoPedStrikeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuperSlowMoPedStrikeSound"));
                        SuperSlowMoPedStrikeSoundPresuck = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuperSlowMoPedStrikeSoundPresuck"));
                        SuperSlowMoBigAnimalStrikeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuperSlowMoBigAnimalStrikeSound"));
                        SuperSlowMoBigAnimalStrikeSoundPresuck = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuperSlowMoBigAnimalStrikeSoundPresuck"));
                        SuperSlowMoSmallAnimalStrikeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuperSlowMoSmallAnimalStrikeSound"));
                        SuperSlowMoSmallAnimalStrikeSoundPresuck = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuperSlowMoSmallAnimalStrikeSoundPresuck"));
                        SuperSlowMoFireSoundPresuckTime = Xml.GetChildIntAttribute(node, "SuperSlowMoFireSoundPresuckTime", "value");
                        SuperSlowMoSuppressedFireSoundPresuckTime = Xml.GetChildIntAttribute(node, "SuperSlowMoSuppressedFireSoundPresuckTime", "value");
                        SuperSlowMoPedStrikeSoundPresuckTime = Xml.GetChildIntAttribute(node, "SuperSlowMoPedStrikeSoundPresuckTime", "value");
                        SuperSlowMoBigAnimalStrikeSoundPresuckTime = Xml.GetChildIntAttribute(node, "SuperSlowMoBigAnimalStrikeSoundPresuckTime", "value");
                        SuperSlowMoSmallAnimalStrikeSoundPresuckTime = Xml.GetChildIntAttribute(node, "SuperSlowMoSmallAnimalStrikeSoundPresuckTime", "value");
                    }
                }
            }
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { FireSound, SuppressedFireSound, AutoSound, ReportSound, EchoSound, SuppressedEchoSound, ShellCasingSound, SwipeSound, GeneralStrikeSound, PedStrikeSound, HeftSound, PutDownSound, RattleSound, RattleLandSound, PickupSound,
                SafetyOn, SafetyOff, SpecialWeaponSoundSet, BankSound, InteriorShotSound, ReloadSounds, IntoCoverSound, OutOfCoverSound, RattleAimSound, SmallAnimalStrikeSound, BigAnimalStrikeSound, SlowMoFireSound, HitPedSound, SlowMoFireSoundPresuck, SlowMoSuppressedFireSound, SlowMoSuppressedFireSoundPresuck, SlowMoReportSound,
                SlowMoInteriorShotSound, SlowMoPedStrikeSound, SlowMoPedStrikeSoundPresuck, SlowMoBigAnimalStrikeSound, SlowMoBigAnimalStrikeSoundPresuck, SlowMoSmallAnimalStrikeSound, SlowMoSmallAnimalStrikeSoundPresuck, SuperSlowMoFireSound, SuperSlowMoFireSoundPresuck, SuperSlowMoSuppressedFireSound, SuperSlowMoSuppressedFireSoundPresuck, SuperSlowMoReportSound, SuperSlowMoInteriorShotSound, SuperSlowMoPedStrikeSound, SuperSlowMoPedStrikeSoundPresuck, SuperSlowMoBigAnimalStrikeSound, SuperSlowMoBigAnimalStrikeSoundPresuck, SuperSlowMoSmallAnimalStrikeSound, SuperSlowMoSmallAnimalStrikeSoundPresuck };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ExplosionAudioSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash ExplosionSound { get; set; }
        public MetaHash DebrisSound { get; set; }
        public float DeafeningVolume { get; set; }
        public float DebrisTimeScale { get; set; }
        public float DebrisVolume { get; set; }
        public float ShockwaveIntensity { get; set; }
        public float ShockwaveDelay { get; set; }
        public MetaHash SlowMoExplosionSound { get; set; }
        public MetaHash SlowMoExplosionPreSuckSound { get; set; }
        public int SlowMoExplosionPreSuckSoundTime { get; set; }
        public MetaHash SlowMoExplosionPreSuckMixerScene { get; set; }

        public Dat151ExplosionAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ExplosionAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151ExplosionAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            ExplosionSound = br.ReadUInt32();
            DebrisSound = br.ReadUInt32();
            DeafeningVolume = br.ReadSingle();
            DebrisTimeScale = br.ReadSingle();
            DebrisVolume = br.ReadSingle();
            ShockwaveIntensity = br.ReadSingle();
            ShockwaveDelay = br.ReadSingle();
            SlowMoExplosionSound = br.ReadUInt32();
            SlowMoExplosionPreSuckSound = br.ReadUInt32();
            SlowMoExplosionPreSuckSoundTime = br.ReadInt32();
            SlowMoExplosionPreSuckMixerScene = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(ExplosionSound);
            bw.Write(DebrisSound);
            bw.Write(DeafeningVolume);
            bw.Write(DebrisTimeScale);
            bw.Write(DebrisVolume);
            bw.Write(ShockwaveIntensity);
            bw.Write(ShockwaveDelay);
            bw.Write(SlowMoExplosionSound);
            bw.Write(SlowMoExplosionPreSuckSound);
            bw.Write(SlowMoExplosionPreSuckSoundTime);
            bw.Write(SlowMoExplosionPreSuckMixerScene);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "ExplosionSound", RelXml.HashString(ExplosionSound));
            RelXml.StringTag(sb, indent, "DebrisSound", RelXml.HashString(DebrisSound));
            RelXml.ValueTag(sb, indent, "DeafeningVolume", FloatUtil.ToString(DeafeningVolume));
            RelXml.ValueTag(sb, indent, "DebrisTimeScale", FloatUtil.ToString(DebrisTimeScale));
            RelXml.ValueTag(sb, indent, "DebrisVolume", FloatUtil.ToString(DebrisVolume));
            RelXml.ValueTag(sb, indent, "ShockwaveIntensity", FloatUtil.ToString(ShockwaveIntensity));
            RelXml.ValueTag(sb, indent, "ShockwaveDelay", FloatUtil.ToString(ShockwaveDelay));
            RelXml.StringTag(sb, indent, "SlowMoExplosionSound", RelXml.HashString(SlowMoExplosionSound));
            RelXml.StringTag(sb, indent, "SlowMoExplosionPreSuckSound", RelXml.HashString(SlowMoExplosionPreSuckSound));
            RelXml.ValueTag(sb, indent, "SlowMoExplosionPreSuckSoundTime", SlowMoExplosionPreSuckSoundTime.ToString());
            RelXml.ValueTag(sb, indent, "SlowMoExplosionPreSuckMixerScene", SlowMoExplosionPreSuckMixerScene.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            ExplosionSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExplosionSound"));
            DebrisSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "DebrisSound"));
            DeafeningVolume = Xml.GetChildFloatAttribute(node, "DeafeningVolume", "value");
            DebrisTimeScale = Xml.GetChildFloatAttribute(node, "DebrisTimeScale", "value");
            DebrisVolume = Xml.GetChildFloatAttribute(node, "DebrisVolume", "value");
            ShockwaveIntensity = Xml.GetChildFloatAttribute(node, "ShockwaveIntensity", "value");
            ShockwaveDelay = Xml.GetChildFloatAttribute(node, "ShockwaveDelay", "value");
            SlowMoExplosionSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoExplosionSound"));
            SlowMoExplosionPreSuckSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoExplosionPreSuckSound"));
            SlowMoExplosionPreSuckSoundTime = Xml.GetChildIntAttribute(node, "SlowMoExplosionPreSuckSoundTime", "value");
            SlowMoExplosionPreSuckMixerScene = Xml.GetChildUIntAttribute(node, "SlowMoExplosionPreSuckMixerScene", "value");
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { ExplosionSound, DebrisSound, SlowMoExplosionSound, SlowMoExplosionPreSuckSound };
        }
        public override MetaHash[] GetMixerHashes()
        {
            return new[] { SlowMoExplosionPreSuckMixerScene };
        }
    }

    [TC(typeof(EXP))]
    public class Dat151PedVoiceGroupsItem : IMetaXmlItem
    {
        public MetaHash VoiceName { get; set; }
        public uint ReferenceCount { get; set; }
        public uint RunningTab { get; set; }

        public Dat151PedVoiceGroupsItem()
        { }
        public Dat151PedVoiceGroupsItem(BinaryReader br)
        {
            VoiceName = br.ReadUInt32();
            ReferenceCount = br.ReadUInt32();
            RunningTab = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(VoiceName);
            bw.Write(ReferenceCount);
            bw.Write(RunningTab);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "VoiceName", RelXml.HashString(VoiceName));
            RelXml.ValueTag(sb, indent, "ReferenceCount", ReferenceCount.ToString());
            RelXml.ValueTag(sb, indent, "RunningTab", RunningTab.ToString());
        }
        public void ReadXml(XmlNode node)
        {
            VoiceName = XmlRel.GetHash(Xml.GetChildInnerText(node, "VoiceName"));
            ReferenceCount = Xml.GetChildUIntAttribute(node, "ReferenceCount", "value");
            RunningTab = Xml.GetChildUIntAttribute(node, "RunningTab", "value");
        }
        public override string ToString()
        {
            return VoiceName.ToString() + ", " + ReferenceCount.ToString() + ", " + RunningTab.ToString();
        }
    }
 

    [TC(typeof(EXP))]
    public class Dat151PedVoiceGroups : Dat151RelData
    {
        public byte PVGType { get; set; }
        public byte PVGBits { get; set; }
        public byte VoicePriority { get; set; }
        public MetaHash RingtoneSounds { get; set; }
        public byte PrimaryVoicesCount { get; set; }
        public Dat151PedVoiceGroupsItem[] PrimaryVoices { get; set; }
        public byte MiniVoicesCount { get; set; }
        public Dat151PedVoiceGroupsItem[] MiniVoices { get; set; }
        public byte GangVoicesCount { get; set; }
        public Dat151PedVoiceGroupsItem[] GangVoices { get; set; }
        public byte BackupPVGCount { get; set; }
        public MetaHash[] BackupPVGs { get; set; }
        public int Version { get; set; }


        public Dat151PedVoiceGroups(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.PedVoiceGroups;
            TypeID = (byte)Type;
        }
        public Dat151PedVoiceGroups(RelData d, BinaryReader br) : base(d, br)
        {
            PVGType = br.ReadByte();
            PVGBits = br.ReadByte();
            VoicePriority = br.ReadByte();
            RingtoneSounds = br.ReadUInt32();

            PrimaryVoicesCount = br.ReadByte();
            if (PrimaryVoicesCount != 0)
            {
                PrimaryVoices = new Dat151PedVoiceGroupsItem[PrimaryVoicesCount];
                for (int i = 0; i < PrimaryVoicesCount; i++)
                {
                    PrimaryVoices[i] = new Dat151PedVoiceGroupsItem(br);
                }
            }

            MiniVoicesCount = br.ReadByte();
            if (MiniVoicesCount != 0)
            {
                MiniVoices = new Dat151PedVoiceGroupsItem[MiniVoicesCount];
                for (int i = 0; i < MiniVoicesCount; i++)
                {
                    MiniVoices[i] = new Dat151PedVoiceGroupsItem(br);
                }
            }

            GangVoicesCount = br.ReadByte();
            if (GangVoicesCount != 0)
            {
                GangVoices = new Dat151PedVoiceGroupsItem[GangVoicesCount];
                for (int i = 0; i < GangVoicesCount; i++)
                {
                    GangVoices[i] = new Dat151PedVoiceGroupsItem(br);
                }
            }

            Version = 0;

            BackupPVGCount = br.ReadByte();
            var bytesleft = br.BaseStream.Length - br.BaseStream.Position;
            if (bytesleft > 0)
            {
                Version = 1;
                BackupPVGs = new MetaHash[BackupPVGCount];
                for (int i = 0; i < BackupPVGCount; i++)
                {
                    BackupPVGs[i] = br.ReadUInt32();
                }
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(PVGType);
            bw.Write(PVGBits);
            bw.Write(VoicePriority);
            bw.Write(RingtoneSounds);
            bw.Write(PrimaryVoicesCount);
            for (int i = 0; i < PrimaryVoicesCount; i++)
            {
                PrimaryVoices[i].Write(bw);
            }
            bw.Write(MiniVoicesCount);
            for (int i = 0; i < MiniVoicesCount; i++)
            {
                MiniVoices[i].Write(bw);
            }
            bw.Write(GangVoicesCount);
            for (int i = 0; i < GangVoicesCount; i++)
            {
                GangVoices[i].Write(bw);
            }
            bw.Write(BackupPVGCount);
            if (Version >= 1)
            {
                for (int i = 0; i < BackupPVGCount; i++)
                {
                    bw.Write(BackupPVGs[i]);
                }
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "PVGType", PVGType.ToString());
            RelXml.ValueTag(sb, indent, "PVGBits", PVGBits.ToString());
            RelXml.ValueTag(sb, indent, "VoicePriority", VoicePriority.ToString());
            RelXml.StringTag(sb, indent, "RingtoneSounds", RelXml.HashString(RingtoneSounds));
            RelXml.WriteItemArray(sb, PrimaryVoices, indent, "PrimaryVoices");
            RelXml.WriteItemArray(sb, MiniVoices, indent, "MiniVoices");
            RelXml.WriteItemArray(sb, GangVoices, indent, "GangVoices");
            RelXml.WriteHashItemArray(sb, BackupPVGs, indent, "BackupPVGs");
        }
        public override void ReadXml(XmlNode node)
        {
            PVGType = (byte)Xml.GetChildUIntAttribute(node, "PVGType", "value");
            PVGBits = (byte)Xml.GetChildUIntAttribute(node, "PVGBits", "value");
            VoicePriority = (byte)Xml.GetChildUIntAttribute(node, "VoicePriority", "value");
            RingtoneSounds = XmlRel.GetHash(Xml.GetChildInnerText(node, "RingtoneSounds"));
            PrimaryVoices = XmlRel.ReadItemArray<Dat151PedVoiceGroupsItem>(node, "PrimaryVoices");
            PrimaryVoicesCount = (byte)(PrimaryVoices?.Length ?? 0);
            MiniVoices = XmlRel.ReadItemArray<Dat151PedVoiceGroupsItem>(node, "MiniVoices");
            MiniVoicesCount = (byte)(MiniVoices?.Length ?? 0);
            GangVoices = XmlRel.ReadItemArray<Dat151PedVoiceGroupsItem>(node, "GangVoices");
            GangVoicesCount = (byte)(GangVoices?.Length ?? 0);
            BackupPVGs = XmlRel.ReadHashItemArray(node, "BackupPVGs");
            BackupPVGCount = (byte)(BackupPVGs?.Length ?? 0);
        }
        public override MetaHash[] GetSpeechHashes()
        {
            var list = new List<MetaHash>();
            if (PrimaryVoices != null)
            {
                foreach (var item in PrimaryVoices)
                {
                    list.Add(item.VoiceName);
                }
            }
            if (MiniVoices != null)
            {
                foreach (var item in MiniVoices)
                {
                    list.Add(item.VoiceName);
                }
            }
            if (GangVoices != null)
            {
                foreach (var item in GangVoices)
                {
                    list.Add(item.VoiceName);
                }
            }
            if (BackupPVGs != null)
            {
                foreach (var hash in BackupPVGs)
                {
                    list.Add(hash);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151EntityEmitter : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash Sound { get; set; }
        public float MaxDistance { get; set; }
        public float BusinessHoursProb { get; set; }
        public float EveningProb { get; set; }
        public float NightProb { get; set; }
        public float ConeInnerAngle { get; set; }
        public float ConeOuterAngle { get; set; }
        public float ConeMaxAtten { get; set; }
        public MetaHash StopAfterLoudSound { get; set; }
        public byte MaxPathDepth { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public float BrokenHealth { get; set; }

        public Dat151EntityEmitter(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.EntityEmitter;
            TypeID = (byte)Type;
        }
        public Dat151EntityEmitter(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Sound = br.ReadUInt32();
            MaxDistance = br.ReadSingle();
            BusinessHoursProb = br.ReadSingle();
            EveningProb = br.ReadSingle();
            NightProb = br.ReadSingle();
            ConeInnerAngle = br.ReadSingle();
            ConeOuterAngle = br.ReadSingle();
            ConeMaxAtten = br.ReadSingle();
            StopAfterLoudSound = br.ReadUInt32();
            MaxPathDepth = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            BrokenHealth = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Sound);
            bw.Write(MaxDistance);
            bw.Write(BusinessHoursProb);
            bw.Write(EveningProb);
            bw.Write(NightProb);
            bw.Write(ConeInnerAngle);
            bw.Write(ConeOuterAngle);
            bw.Write(ConeMaxAtten);
            bw.Write(StopAfterLoudSound);
            bw.Write(MaxPathDepth);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(BrokenHealth);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "Sound", RelXml.HashString(Sound));
            RelXml.ValueTag(sb, indent, "MaxDistance", FloatUtil.ToString(MaxDistance));
            RelXml.ValueTag(sb, indent, "BusinessHoursProb", FloatUtil.ToString(BusinessHoursProb));
            RelXml.ValueTag(sb, indent, "EveningProb", FloatUtil.ToString(EveningProb));
            RelXml.ValueTag(sb, indent, "NightProb", FloatUtil.ToString(NightProb));
            RelXml.ValueTag(sb, indent, "ConeInnerAngle", FloatUtil.ToString(ConeInnerAngle));
            RelXml.ValueTag(sb, indent, "ConeOuterAngle", FloatUtil.ToString(ConeOuterAngle));
            RelXml.ValueTag(sb, indent, "ConeMaxAtten", FloatUtil.ToString(ConeMaxAtten));
            RelXml.StringTag(sb, indent, "StopAfterLoudSound", RelXml.HashString(StopAfterLoudSound));
            RelXml.ValueTag(sb, indent, "MaxPathDepth", MaxPathDepth.ToString());
            RelXml.ValueTag(sb, indent, "BrokenHealth", FloatUtil.ToString(BrokenHealth));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Sound = XmlRel.GetHash(Xml.GetChildInnerText(node, "Sound"));
            MaxDistance = Xml.GetChildFloatAttribute(node, "MaxDistance", "value");
            BusinessHoursProb = Xml.GetChildFloatAttribute(node, "BusinessHoursProb", "value");
            EveningProb = Xml.GetChildFloatAttribute(node, "EveningProb", "value");
            NightProb = Xml.GetChildFloatAttribute(node, "NightProb", "value");
            ConeInnerAngle = Xml.GetChildFloatAttribute(node, "ConeInnerAngle", "value");
            ConeOuterAngle = Xml.GetChildFloatAttribute(node, "ConeOuterAngle", "value");
            ConeMaxAtten = Xml.GetChildFloatAttribute(node, "ConeMaxAtten", "value");
            StopAfterLoudSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "StopAfterLoudSound"));
            MaxPathDepth = (byte)Xml.GetChildUIntAttribute(node, "MaxPathDepth", "value");
            BrokenHealth = Xml.GetChildFloatAttribute(node, "BrokenHealth", "value");
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { Sound };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151BoatAudioSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash Engine1Loop { get; set; }
        public MetaHash Engine1Vol { get; set; }
        public MetaHash Engine1Pitch { get; set; }
        public MetaHash Engine2Loop { get; set; }
        public MetaHash Engine2Vol { get; set; }
        public MetaHash Engine2Pitch { get; set; }
        public MetaHash LowResoLoop { get; set; }
        public MetaHash LowResoLoopVol { get; set; }
        public MetaHash LowResoPitch { get; set; }
        public MetaHash ResoLoop { get; set; }
        public MetaHash ResoLoopVol { get; set; }
        public MetaHash ResoPitch { get; set; }
        public MetaHash WaterTurbulence { get; set; }
        public MetaHash WaterTurbulanceVol { get; set; }
        public MetaHash WaterTurbulancePitch { get; set; }
        public MetaHash ScannerMake { get; set; }
        public MetaHash ScannerModel { get; set; }
        public MetaHash ScannerCategory { get; set; }
        public MetaHash ScannerVehicleSettings { get; set; }
        public byte RadioType { get; set; }
        public byte RadioGenre { get; set; }
        public short padding00 { get; set; }
        public MetaHash HornLoop { get; set; }
        public MetaHash IgnitionOneShot { get; set; }
        public MetaHash ShutdownOneShot { get; set; }
        public short EngineVolPostSubmix { get; set; }
        public short ExhaustVolPostSubmix { get; set; }
        public MetaHash EngineSynthDef { get; set; }
        public MetaHash EngineSynthPreset { get; set; }
        public MetaHash ExhaustSynthDef { get; set; }
        public MetaHash ExhaustSynthPreset { get; set; }
        public MetaHash VehicleCollisions { get; set; }
        public MetaHash EngineSubmixVoice { get; set; }
        public MetaHash ExhaustSubmixVoice { get; set; }
        public MetaHash WaveHitSound { get; set; }
        public MetaHash LeftWaterSound { get; set; }
        public MetaHash IdleHullSlapLoop { get; set; }
        public MetaHash IdleHullSlapSpeedToVol { get; set; }
        public MetaHash GranularEngine { get; set; }
        public MetaHash BankSpraySound { get; set; }
        public MetaHash IgnitionLoop { get; set; }
        public MetaHash EngineStartUp { get; set; }
        public MetaHash SubTurningEnginePitchModifier { get; set; }
        public MetaHash SubTurningSweetenerSound { get; set; }
        public MetaHash RevsToSweetenerVolume { get; set; }
        public MetaHash TurningToSweetenerVolume { get; set; }
        public MetaHash TurningToSweetenerPitch { get; set; }
        public MetaHash DryLandScrape { get; set; }
        public float MaxRollOffScalePlayer { get; set; }
        public float MaxRollOffScaleNPC { get; set; }
        public float Openness { get; set; }
        public MetaHash DryLandHardScrape { get; set; }
        public MetaHash DryLandHardImpact { get; set; }
        public MetaHash WindClothSound { get; set; }
        public MetaHash FireAudio { get; set; }
        public MetaHash DoorOpen { get; set; }
        public MetaHash DoorClose { get; set; }
        public MetaHash DoorLimit { get; set; }
        public MetaHash DoorStartClose { get; set; }
        public MetaHash SubExtrasSound { get; set; }
        public MetaHash SFXBankSound { get; set; }
        public MetaHash SubmersibleCreaksSound { get; set; }
        public MetaHash WaveHitBigAirSound { get; set; }
        public float BigAirMinTime { get; set; }
        public MetaHash VehicleRainSound { get; set; }
        public MetaHash VehicleRainSoundInterior { get; set; }


        public Dat151BoatAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.BoatAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151BoatAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Engine1Loop = br.ReadUInt32();
            Engine1Vol = br.ReadUInt32();
            Engine1Pitch = br.ReadUInt32();
            Engine2Loop = br.ReadUInt32();
            Engine2Vol = br.ReadUInt32();
            Engine2Pitch = br.ReadUInt32();
            LowResoLoop = br.ReadUInt32();
            LowResoLoopVol = br.ReadUInt32();
            LowResoPitch = br.ReadUInt32();
            ResoLoop = br.ReadUInt32();
            ResoLoopVol = br.ReadUInt32();
            ResoPitch = br.ReadUInt32();
            WaterTurbulence = br.ReadUInt32();
            WaterTurbulanceVol = br.ReadUInt32();
            WaterTurbulancePitch = br.ReadUInt32();
            ScannerMake = br.ReadUInt32();
            ScannerModel = br.ReadUInt32();
            ScannerCategory = br.ReadUInt32();
            ScannerVehicleSettings = br.ReadUInt32();
            RadioType = br.ReadByte();
            RadioGenre = br.ReadByte();
            padding00 = br.ReadInt16();
            HornLoop = br.ReadUInt32();
            IgnitionOneShot = br.ReadUInt32();
            ShutdownOneShot = br.ReadUInt32();
            EngineVolPostSubmix = br.ReadInt16();
            ExhaustVolPostSubmix = br.ReadInt16();
            EngineSynthDef = br.ReadUInt32();
            EngineSynthPreset = br.ReadUInt32();
            ExhaustSynthDef = br.ReadUInt32();
            ExhaustSynthPreset = br.ReadUInt32();
            VehicleCollisions = br.ReadUInt32();
            EngineSubmixVoice = br.ReadUInt32();
            ExhaustSubmixVoice = br.ReadUInt32();
            WaveHitSound = br.ReadUInt32();
            LeftWaterSound = br.ReadUInt32();
            IdleHullSlapLoop = br.ReadUInt32();
            IdleHullSlapSpeedToVol = br.ReadUInt32();
            GranularEngine = br.ReadUInt32();
            BankSpraySound = br.ReadUInt32();
            IgnitionLoop = br.ReadUInt32();
            EngineStartUp = br.ReadUInt32();
            SubTurningEnginePitchModifier = br.ReadUInt32();
            SubTurningSweetenerSound = br.ReadUInt32();
            RevsToSweetenerVolume = br.ReadUInt32();
            TurningToSweetenerVolume = br.ReadUInt32();
            TurningToSweetenerPitch = br.ReadUInt32();
            DryLandScrape = br.ReadUInt32();
            MaxRollOffScalePlayer = br.ReadSingle();
            MaxRollOffScaleNPC = br.ReadSingle();
            Openness = br.ReadSingle();
            DryLandHardScrape = br.ReadUInt32();
            DryLandHardImpact = br.ReadUInt32();
            WindClothSound = br.ReadUInt32();
            FireAudio = br.ReadUInt32();
            DoorOpen = br.ReadUInt32();
            DoorClose = br.ReadUInt32();
            DoorLimit = br.ReadUInt32();
            DoorStartClose = br.ReadUInt32();
            SubExtrasSound = br.ReadUInt32();
            SFXBankSound = br.ReadUInt32();
            SubmersibleCreaksSound = br.ReadUInt32();
            WaveHitBigAirSound = br.ReadUInt32();
            BigAirMinTime = br.ReadSingle();
            VehicleRainSound = br.ReadUInt32();
            VehicleRainSoundInterior = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Engine1Loop);
            bw.Write(Engine1Vol);
            bw.Write(Engine1Pitch);
            bw.Write(Engine2Loop);
            bw.Write(Engine2Vol);
            bw.Write(Engine2Pitch);
            bw.Write(LowResoLoop);
            bw.Write(LowResoLoopVol);
            bw.Write(LowResoPitch);
            bw.Write(ResoLoop);
            bw.Write(ResoLoopVol);
            bw.Write(ResoPitch);
            bw.Write(WaterTurbulence);
            bw.Write(WaterTurbulanceVol);
            bw.Write(WaterTurbulancePitch);
            bw.Write(ScannerMake);
            bw.Write(ScannerModel);
            bw.Write(ScannerCategory);
            bw.Write(ScannerVehicleSettings);
            bw.Write(RadioType);
            bw.Write(RadioGenre);
            bw.Write(padding00);
            bw.Write(HornLoop);
            bw.Write(IgnitionOneShot);
            bw.Write(ShutdownOneShot);
            bw.Write(EngineVolPostSubmix);
            bw.Write(ExhaustVolPostSubmix);
            bw.Write(EngineSynthDef);
            bw.Write(EngineSynthPreset);
            bw.Write(ExhaustSynthDef);
            bw.Write(ExhaustSynthPreset);
            bw.Write(VehicleCollisions);
            bw.Write(EngineSubmixVoice);
            bw.Write(ExhaustSubmixVoice);
            bw.Write(WaveHitSound);
            bw.Write(LeftWaterSound);
            bw.Write(IdleHullSlapLoop);
            bw.Write(IdleHullSlapSpeedToVol);
            bw.Write(GranularEngine);
            bw.Write(BankSpraySound);
            bw.Write(IgnitionLoop);
            bw.Write(EngineStartUp);
            bw.Write(SubTurningEnginePitchModifier);
            bw.Write(SubTurningSweetenerSound);
            bw.Write(RevsToSweetenerVolume);
            bw.Write(TurningToSweetenerVolume);
            bw.Write(TurningToSweetenerPitch);
            bw.Write(DryLandScrape);
            bw.Write(MaxRollOffScalePlayer);
            bw.Write(MaxRollOffScaleNPC);
            bw.Write(Openness);
            bw.Write(DryLandHardScrape);
            bw.Write(DryLandHardImpact);
            bw.Write(WindClothSound);
            bw.Write(FireAudio);
            bw.Write(DoorOpen);
            bw.Write(DoorClose);
            bw.Write(DoorLimit);
            bw.Write(DoorStartClose);
            bw.Write(SubExtrasSound);
            bw.Write(SFXBankSound);
            bw.Write(SubmersibleCreaksSound);
            bw.Write(WaveHitBigAirSound);
            bw.Write(BigAirMinTime);
            bw.Write(VehicleRainSound);
            bw.Write(VehicleRainSoundInterior);

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "Engine1Loop", RelXml.HashString(Engine1Loop));
            RelXml.StringTag(sb, indent, "Engine1Vol", RelXml.HashString(Engine1Vol));
            RelXml.StringTag(sb, indent, "Engine1Pitch", RelXml.HashString(Engine1Pitch));
            RelXml.StringTag(sb, indent, "Engine2Loop", RelXml.HashString(Engine2Loop));
            RelXml.StringTag(sb, indent, "Engine2Vol", RelXml.HashString(Engine2Vol));
            RelXml.StringTag(sb, indent, "Engine2Pitch", RelXml.HashString(Engine2Pitch));
            RelXml.StringTag(sb, indent, "LowResoLoop", RelXml.HashString(LowResoLoop));
            RelXml.StringTag(sb, indent, "LowResoLoopVol", RelXml.HashString(LowResoLoopVol));
            RelXml.StringTag(sb, indent, "LowResoPitch", RelXml.HashString(LowResoPitch));
            RelXml.StringTag(sb, indent, "ResoLoop", RelXml.HashString(ResoLoop));
            RelXml.StringTag(sb, indent, "ResoLoopVol", RelXml.HashString(ResoLoopVol));
            RelXml.StringTag(sb, indent, "ResoPitch", RelXml.HashString(ResoPitch));
            RelXml.StringTag(sb, indent, "WaterTurbulence", RelXml.HashString(WaterTurbulence));
            RelXml.StringTag(sb, indent, "WaterTurbulanceVol", RelXml.HashString(WaterTurbulanceVol));
            RelXml.StringTag(sb, indent, "WaterTurbulancePitch", RelXml.HashString(WaterTurbulancePitch));
            RelXml.StringTag(sb, indent, "ScannerMake", RelXml.HashString(ScannerMake));
            RelXml.StringTag(sb, indent, "ScannerModel", RelXml.HashString(ScannerModel));
            RelXml.StringTag(sb, indent, "ScannerCategory", RelXml.HashString(ScannerCategory));
            RelXml.StringTag(sb, indent, "ScannerVehicleSettings", RelXml.HashString(ScannerVehicleSettings));
            RelXml.ValueTag(sb, indent, "RadioType", RadioType.ToString());
            RelXml.ValueTag(sb, indent, "RadioGenre", RadioGenre.ToString());
            RelXml.StringTag(sb, indent, "HornLoop", RelXml.HashString(HornLoop));
            RelXml.StringTag(sb, indent, "IgnitionOneShot", RelXml.HashString(IgnitionOneShot));
            RelXml.StringTag(sb, indent, "ShutdownOneShot", RelXml.HashString(ShutdownOneShot));
            RelXml.ValueTag(sb, indent, "EngineVolPostSubmix", EngineVolPostSubmix.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustVolPostSubmix", ExhaustVolPostSubmix.ToString());
            RelXml.StringTag(sb, indent, "EngineSynthDef", RelXml.HashString(EngineSynthDef));
            RelXml.StringTag(sb, indent, "EngineSynthPreset", RelXml.HashString(EngineSynthPreset));
            RelXml.StringTag(sb, indent, "ExhaustSynthDef", RelXml.HashString(ExhaustSynthDef));
            RelXml.StringTag(sb, indent, "ExhaustSubmixPreset", RelXml.HashString(ExhaustSynthPreset));
            RelXml.StringTag(sb, indent, "VehicleCollisions", RelXml.HashString(VehicleCollisions));
            RelXml.StringTag(sb, indent, "EngineSubmixVoice", RelXml.HashString(EngineSubmixVoice));
            RelXml.StringTag(sb, indent, "ExhaustSubmixVoice", RelXml.HashString(ExhaustSubmixVoice));
            RelXml.StringTag(sb, indent, "WaveHitSound", RelXml.HashString(WaveHitSound));
            RelXml.StringTag(sb, indent, "LeftWaterSound", RelXml.HashString(LeftWaterSound));
            RelXml.StringTag(sb, indent, "IdleHullSlapLoop", RelXml.HashString(IdleHullSlapLoop));
            RelXml.StringTag(sb, indent, "IdleHullSlapSpeedToVol", RelXml.HashString(IdleHullSlapSpeedToVol));
            RelXml.StringTag(sb, indent, "GranularEngine", RelXml.HashString(GranularEngine));
            RelXml.StringTag(sb, indent, "BankSpraySound", RelXml.HashString(BankSpraySound));
            RelXml.StringTag(sb, indent, "IgnitionLoop", RelXml.HashString(IgnitionLoop));
            RelXml.StringTag(sb, indent, "EngineStartUp", RelXml.HashString(EngineStartUp));
            RelXml.StringTag(sb, indent, "SubTurningEnginePitchModifier", RelXml.HashString(SubTurningEnginePitchModifier));
            RelXml.StringTag(sb, indent, "SubTurningSweetenerSound", RelXml.HashString(SubTurningSweetenerSound));
            RelXml.StringTag(sb, indent, "RevsToSweetenerVolume", RelXml.HashString(RevsToSweetenerVolume));
            RelXml.StringTag(sb, indent, "TurningToSweetenerVolume", RelXml.HashString(TurningToSweetenerVolume));
            RelXml.StringTag(sb, indent, "TurningToSweetenerPitch", RelXml.HashString(TurningToSweetenerPitch));
            RelXml.StringTag(sb, indent, "DryLandScrape", RelXml.HashString(DryLandScrape));
            RelXml.ValueTag(sb, indent, "MaxRollOffScalePlayer", FloatUtil.ToString(MaxRollOffScalePlayer));
            RelXml.ValueTag(sb, indent, "MaxRollOffScaleNPC", FloatUtil.ToString(MaxRollOffScaleNPC));
            RelXml.ValueTag(sb, indent, "Openness", FloatUtil.ToString(Openness));
            RelXml.StringTag(sb, indent, "DryLandHardScrape", RelXml.HashString(DryLandHardScrape));
            RelXml.StringTag(sb, indent, "DryLandHardImpact", RelXml.HashString(DryLandHardImpact));
            RelXml.StringTag(sb, indent, "WindClothSound", RelXml.HashString(WindClothSound));
            RelXml.StringTag(sb, indent, "FireAudio", RelXml.HashString(FireAudio));
            RelXml.StringTag(sb, indent, "DoorOpen", RelXml.HashString(DoorOpen));
            RelXml.StringTag(sb, indent, "DoorClose", RelXml.HashString(DoorClose));
            RelXml.StringTag(sb, indent, "DoorLimit", RelXml.HashString(DoorLimit));
            RelXml.StringTag(sb, indent, "DoorStartClose", RelXml.HashString(DoorStartClose));
            RelXml.StringTag(sb, indent, "SubExtrasSound", RelXml.HashString(SubExtrasSound));
            RelXml.StringTag(sb, indent, "SFXBankSound", RelXml.HashString(SFXBankSound));
            RelXml.StringTag(sb, indent, "SubmersibleCreaksSound", RelXml.HashString(SubmersibleCreaksSound));
            RelXml.StringTag(sb, indent, "WaveHitBigAirSound", RelXml.HashString(WaveHitBigAirSound));
            RelXml.ValueTag(sb, indent, "BigAirMinTime", FloatUtil.ToString(BigAirMinTime));
            RelXml.StringTag(sb, indent, "VehicleRainSound", RelXml.HashString(VehicleRainSound));
            RelXml.StringTag(sb, indent, "VehicleRainSoundInterior", RelXml.HashString(VehicleRainSoundInterior));

        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Engine1Loop = XmlRel.GetHash(Xml.GetChildInnerText(node, "Engine1Loop"));
            Engine1Vol = XmlRel.GetHash(Xml.GetChildInnerText(node, "Engine1Vol"));
            Engine1Pitch = XmlRel.GetHash(Xml.GetChildInnerText(node, "Engine1Pitch"));
            Engine2Loop = XmlRel.GetHash(Xml.GetChildInnerText(node, "Engine2Loop"));
            Engine2Vol = XmlRel.GetHash(Xml.GetChildInnerText(node, "Engine2Vol"));
            Engine2Pitch = XmlRel.GetHash(Xml.GetChildInnerText(node, "Engine2Pitch"));
            LowResoLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "LowResoLoop"));
            LowResoLoopVol = XmlRel.GetHash(Xml.GetChildInnerText(node, "LowResoLoopVol"));
            LowResoPitch = XmlRel.GetHash(Xml.GetChildInnerText(node, "LowResoPitch"));
            ResoLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "ResoLoop"));
            ResoLoopVol = XmlRel.GetHash(Xml.GetChildInnerText(node, "ResoLoopVol"));
            ResoPitch = XmlRel.GetHash(Xml.GetChildInnerText(node, "ResoPitch"));
            WaterTurbulence = XmlRel.GetHash(Xml.GetChildInnerText(node, "WaterTurbulence"));
            WaterTurbulanceVol = XmlRel.GetHash(Xml.GetChildInnerText(node, "WaterTurbulanceVol"));
            WaterTurbulancePitch = XmlRel.GetHash(Xml.GetChildInnerText(node, "WaterTurbulancePitch"));
            ScannerMake = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScannerMake"));
            ScannerModel = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScannerModel"));
            ScannerCategory = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScannerCategory"));
            ScannerVehicleSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScannerVehicleSettings"));
            RadioType = (byte)Xml.GetChildUIntAttribute(node, "RadioType", "value");
            RadioGenre = (byte)Xml.GetChildUIntAttribute(node, "RadioGenre", "value");
            HornLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "HornLoop"));
            IgnitionOneShot = XmlRel.GetHash(Xml.GetChildInnerText(node, "IgnitionOneShot"));
            ShutdownOneShot = XmlRel.GetHash(Xml.GetChildInnerText(node, "ShutdownOneShot"));
            EngineVolPostSubmix = (short)Xml.GetChildUIntAttribute(node, "EngineVolPostSubmix", "value");
            ExhaustVolPostSubmix = (short)Xml.GetChildUIntAttribute(node, "ExhaustVolPostSubmix", "value");
            EngineSynthDef = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSynthDef"));
            EngineSynthPreset = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSynthPreset"));
            ExhaustSynthDef = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSynthDef"));
            ExhaustSynthPreset = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSynthPreset"));
            VehicleCollisions = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleCollisions"));
            EngineSubmixVoice = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSubmixVoice"));
            ExhaustSubmixVoice = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSubmixVoice"));
            WaveHitSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "WaveHitSound"));
            LeftWaterSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "LeftWaterSound"));
            IdleHullSlapLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "IdleHullSlapLoop"));
            IdleHullSlapSpeedToVol = XmlRel.GetHash(Xml.GetChildInnerText(node, "IdleHullSlapSpeedToVol"));
            GranularEngine = XmlRel.GetHash(Xml.GetChildInnerText(node, "GranularEngine"));
            BankSpraySound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankSpraySound"));
            IgnitionLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "IgnitionLoop"));
            EngineStartUp = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineStartUp"));
            SubTurningEnginePitchModifier = XmlRel.GetHash(Xml.GetChildInnerText(node, "SubTurningEnginePitchModifier"));
            SubTurningSweetenerSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SubTurningSweetenerSound"));
            RevsToSweetenerVolume = XmlRel.GetHash(Xml.GetChildInnerText(node, "RevsToSweetenerVolume"));
            TurningToSweetenerVolume = XmlRel.GetHash(Xml.GetChildInnerText(node, "TurningToSweetenerVolume"));
            TurningToSweetenerPitch = XmlRel.GetHash(Xml.GetChildInnerText(node, "TurningToSweetenerPitch"));
            DryLandScrape = XmlRel.GetHash(Xml.GetChildInnerText(node, "DryLandScrape"));
            MaxRollOffScalePlayer = Xml.GetChildFloatAttribute(node, "MaxRollOffScalePlayer", "value");
            MaxRollOffScaleNPC = Xml.GetChildFloatAttribute(node, "MaxRollOffScaleNPC", "value");
            Openness = Xml.GetChildFloatAttribute(node, "Openness", "value");
            DryLandHardScrape = XmlRel.GetHash(Xml.GetChildInnerText(node, "DryLandHardScrape"));
            DryLandHardImpact = XmlRel.GetHash(Xml.GetChildInnerText(node, "DryLandHardImpact"));
            WindClothSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "WindClothSound"));
            FireAudio = XmlRel.GetHash(Xml.GetChildInnerText(node, "FireAudio"));
            DoorOpen = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorOpen"));
            DoorClose = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorClose"));
            DoorLimit = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorLimit"));
            DoorStartClose = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorStartClose"));
            SubExtrasSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SubExtrasSound"));
            SFXBankSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SFXBankSound"));
            SubmersibleCreaksSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SubmersibleCreaksSound"));
            WaveHitBigAirSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "WaveHitBigAirSound"));
            BigAirMinTime = Xml.GetChildFloatAttribute(node, "BigAirMinTime", "value");
            VehicleRainSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleRainSound"));
            VehicleRainSoundInterior = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleRainSoundInterior"));

        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { Engine1Vol, Engine1Pitch, Engine2Vol, Engine2Pitch, LowResoLoopVol, LowResoPitch, ResoLoopVol, ResoPitch,
                WaterTurbulanceVol, IdleHullSlapSpeedToVol, SubTurningEnginePitchModifier, RevsToSweetenerVolume, TurningToSweetenerVolume, TurningToSweetenerPitch };
        }
        public override MetaHash[] GetSynthHashes()
        {
            return new[] { EngineSynthDef, EngineSynthPreset, ExhaustSynthDef, ExhaustSynthPreset };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { Engine1Loop, Engine2Loop, LowResoLoop, ResoLoop, WaterTurbulence, ScannerMake, ScannerModel, ScannerCategory, HornLoop, IgnitionOneShot, ShutdownOneShot, EngineSubmixVoice, ExhaustSubmixVoice,
                WaveHitSound, IdleHullSlapLoop, BankSpraySound, IgnitionLoop, EngineStartUp, SubTurningSweetenerSound, DryLandScrape, DryLandHardScrape, DryLandHardImpact, WindClothSound, FireAudio, DoorOpen, DoorClose,
                DoorLimit, DoorStartClose, SubExtrasSound, SFXBankSound, SubmersibleCreaksSound, WaveHitBigAirSound, VehicleRainSound, VehicleRainSoundInterior };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { ScannerVehicleSettings, VehicleCollisions, GranularEngine };
        }
    }


    [TC(typeof(EXP))] 
    public class Dat151BicycleAudioSettings : Dat151RelData
    {
        public MetaHash ChainLoop { get; set; }
        public MetaHash SprocketSound { get; set; }
        public MetaHash RePedalSound { get; set; }
        public MetaHash GearChangeSound { get; set; }
        public float RoadNoiseVolumeScale { get; set; }
        public float SkidVolumeScale { get; set; }
        public MetaHash SuspensionUp { get; set; }
        public MetaHash SuspensionDown { get; set; }
        public float MinSuspCompThresh { get; set; }
        public float MaxSuspCompThresh { get; set; }
        public MetaHash JumpLandSound { get; set; }
        public MetaHash DamagedJumpLandSound { get; set; }
        public uint JumpLandMinThresh { get; set; }
        public uint JumpLandMaxThresh { get; set; }
        public MetaHash VehicleCollisions { get; set; }
        public MetaHash BellSound { get; set; }
        public MetaHash BrakeBlock { get; set; }
        public MetaHash BrakeBlockWet { get; set; }

        public Dat151BicycleAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.BicycleAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151BicycleAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            ChainLoop = br.ReadUInt32();
            SprocketSound = br.ReadUInt32();
            RePedalSound = br.ReadUInt32();
            GearChangeSound = br.ReadUInt32();
            RoadNoiseVolumeScale = br.ReadSingle();
            SkidVolumeScale = br.ReadSingle();
            SuspensionUp = br.ReadUInt32();
            SuspensionDown = br.ReadUInt32();
            MinSuspCompThresh = br.ReadSingle();
            MaxSuspCompThresh = br.ReadSingle();
            JumpLandSound = br.ReadUInt32();
            DamagedJumpLandSound = br.ReadUInt32();
            JumpLandMinThresh = br.ReadUInt32();
            JumpLandMaxThresh = br.ReadUInt32();
            VehicleCollisions = br.ReadUInt32();
            BellSound = br.ReadUInt32();
            BrakeBlock = br.ReadUInt32();
            BrakeBlockWet = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(ChainLoop);
            bw.Write(SprocketSound);
            bw.Write(RePedalSound);
            bw.Write(GearChangeSound);
            bw.Write(RoadNoiseVolumeScale);
            bw.Write(SkidVolumeScale);
            bw.Write(SuspensionUp);
            bw.Write(SuspensionDown);
            bw.Write(MinSuspCompThresh);
            bw.Write(MaxSuspCompThresh);
            bw.Write(JumpLandSound);
            bw.Write(DamagedJumpLandSound);
            bw.Write(JumpLandMinThresh);
            bw.Write(JumpLandMaxThresh);
            bw.Write(VehicleCollisions);
            bw.Write(BellSound);
            bw.Write(BrakeBlock);
            bw.Write(BrakeBlockWet);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "ChainLoop", RelXml.HashString(ChainLoop));
            RelXml.StringTag(sb, indent, "SprocketSound", RelXml.HashString(SprocketSound));
            RelXml.StringTag(sb, indent, "RePedalSound", RelXml.HashString(RePedalSound));
            RelXml.StringTag(sb, indent, "GearChangeSound", RelXml.HashString(GearChangeSound));
            RelXml.ValueTag(sb, indent, "RoadNoiseVolumeScale", FloatUtil.ToString(RoadNoiseVolumeScale));
            RelXml.ValueTag(sb, indent, "SkidVolumeScale", FloatUtil.ToString(SkidVolumeScale));
            RelXml.StringTag(sb, indent, "SuspensionUp", RelXml.HashString(SuspensionUp));
            RelXml.StringTag(sb, indent, "SuspensionDown", RelXml.HashString(SuspensionDown));
            RelXml.ValueTag(sb, indent, "MinSuspCompThresh", FloatUtil.ToString(MinSuspCompThresh));
            RelXml.ValueTag(sb, indent, "MaxSuspCompThresh", FloatUtil.ToString(MaxSuspCompThresh));
            RelXml.StringTag(sb, indent, "JumpLandSound", RelXml.HashString(JumpLandSound));
            RelXml.StringTag(sb, indent, "DamagedJumpLandSound", RelXml.HashString(DamagedJumpLandSound));
            RelXml.ValueTag(sb, indent, "JumpLandMinThresh", JumpLandMinThresh.ToString());
            RelXml.ValueTag(sb, indent, "JumpLandMaxThresh", JumpLandMaxThresh.ToString());
            RelXml.StringTag(sb, indent, "VehicleCollisions", RelXml.HashString(VehicleCollisions));
            RelXml.StringTag(sb, indent, "BellSound", RelXml.HashString(BellSound));
            RelXml.StringTag(sb, indent, "BrakeBlock", RelXml.HashString(BrakeBlock));
            RelXml.StringTag(sb, indent, "BrakeBlockWet", RelXml.HashString(BrakeBlockWet));
        }
        public override void ReadXml(XmlNode node)
        {
            ChainLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "ChainLoop"));
            SprocketSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SprocketSound"));
            RePedalSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RePedalSound"));
            GearChangeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "GearChangeSound"));
            RoadNoiseVolumeScale = Xml.GetChildFloatAttribute(node, "RoadNoiseVolumeScale", "value");
            SkidVolumeScale = Xml.GetChildFloatAttribute(node, "SkidVolumeScale", "value");
            SuspensionUp = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuspensionUp"));
            SuspensionDown = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuspensionDown"));
            MinSuspCompThresh = Xml.GetChildFloatAttribute(node, "MinSuspCompThresh", "value");
            MaxSuspCompThresh = Xml.GetChildFloatAttribute(node, "MaxSuspCompThresh", "value");
            JumpLandSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "JumpLandSound"));
            DamagedJumpLandSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "DamagedJumpLandSound"));
            JumpLandMinThresh = Xml.GetChildUIntAttribute(node, "JumpLandMinThresh", "value");
            JumpLandMaxThresh = Xml.GetChildUIntAttribute(node, "JumpLandMaxThresh", "value");
            VehicleCollisions = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleCollisions"));
            BellSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BellSound"));
            BrakeBlock = XmlRel.GetHash(Xml.GetChildInnerText(node, "BrakeBlock"));
            BrakeBlockWet = XmlRel.GetHash(Xml.GetChildInnerText(node, "BrakeBlockWet"));
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { ChainLoop, SprocketSound, RePedalSound, GearChangeSound, SuspensionUp, SuspensionDown, JumpLandSound, DamagedJumpLandSound, BellSound, BrakeBlock, BrakeBlockWet };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { VehicleCollisions };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151PlaneAudioSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash EngineLoop { get; set; }
        public MetaHash ExhaustLoop { get; set; }
        public MetaHash IdleLoop { get; set; }
        public MetaHash DistanceLoop { get; set; }
        public MetaHash PropellorLoop { get; set; }
        public MetaHash BankingLoop { get; set; }
        public ushort EngineConeFrontAngle { get; set; }
        public ushort EngineConeRearAngle { get; set; }
        public short EngineConeAtten { get; set; }
        public ushort ExhaustConeFrontAngle { get; set; }
        public ushort ExhaustConeRearAngle { get; set; }
        public short ExhaustConeAtten { get; set; }
        public ushort PropellorConeFrontAngle { get; set; }
        public ushort PropellorConeRearAngle { get; set; }
        public short PropellorConeAtten { get; set; }
        public short padding00 { get; set; }
        public MetaHash EngineThrottleVolumeCurve { get; set; }
        public MetaHash EngineThrottlePitchCurve { get; set; }
        public MetaHash ExhaustThrottleVolumeCurve { get; set; }
        public MetaHash ExhaustThrottlePitchCurve { get; set; }
        public MetaHash PropellorThrottleVolumeCurve { get; set; }
        public MetaHash PropellorThrottlePitchCurve { get; set; }
        public MetaHash IdleThrottleVolumeCurve { get; set; }
        public MetaHash IdleThrottlePitchCurve { get; set; }
        public MetaHash DistanceThrottleVolumeCurve { get; set; }
        public MetaHash DistanceThrottlePitchCurve { get; set; }
        public MetaHash DistanceVolumeCurve { get; set; }
        public MetaHash StallWarning { get; set; }
        public MetaHash DoorOpen { get; set; }
        public MetaHash DoorClose { get; set; }
        public MetaHash DoorLimit { get; set; }
        public MetaHash LandingGearDeploy { get; set; }
        public MetaHash LandingGearRetract { get; set; }
        public MetaHash Ignition { get; set; }
        public MetaHash TyreSqueal { get; set; }
        public MetaHash BankingThrottleVolumeCurve { get; set; }
        public MetaHash BankingThrottlePitchCurve { get; set; }
        public MetaHash BankingAngleVolCurve { get; set; }
        public MetaHash AfterburnerLoop { get; set; }
        public int BankingStyle { get; set; }
        public MetaHash AfterburnerThrottleVolCurve { get; set; }
        public MetaHash EngineSynthDef { get; set; }
        public MetaHash EngineSynthPreset { get; set; }
        public MetaHash ExhaustSynthDef { get; set; }
        public MetaHash ExhaustSynthPreset { get; set; }
        public MetaHash EngineSubmixVoice { get; set; }
        public MetaHash ExhaustSubmixVoice { get; set; }
        public MetaHash PropellorBreakOneShot { get; set; }
        public MetaHash WindNoise { get; set; }
        public MetaHash PeelingPitchCurve { get; set; }
        public short DivingFactor { get; set; }
        public short MaxDivePitch { get; set; }
        public short DiveAirSpeedThreshold { get; set; }
        public short DivingRateApproachingGround { get; set; }
        public float PeelingAfterburnerPitchScalingFactor { get; set; }
        public MetaHash Rudder { get; set; }
        public MetaHash Aileron { get; set; }
        public MetaHash Elevator { get; set; }
        public MetaHash DoorStartOpen { get; set; }
        public MetaHash DoorStartClose { get; set; }
        public MetaHash VehicleCollisions { get; set; }
        public MetaHash FireAudio { get; set; }
        public MetaHash EngineMissFire { get; set; }
        public uint IsRealLODRange { get; set; }
        public MetaHash SuspensionUp { get; set; }
        public MetaHash SuspensionDown { get; set; }
        public float MinSuspCompThresh { get; set; }
        public float MaxSuspCompThresh { get; set; }
        public MetaHash DamageEngineSpeedVolumeCurve { get; set; }
        public MetaHash DamageEngineSpeedPitchCurve { get; set; }
        public MetaHash DamageHealthVolumeCurve { get; set; }
        public MetaHash TurbineWindDown { get; set; }
        public MetaHash JetDamageLoop { get; set; }
        public MetaHash AfterburnerThrottlePitchCurve { get; set; }
        public float NPCEngineSmoothAmount { get; set; }
        public MetaHash FlybySound { get; set; }
        public MetaHash DivingSound { get; set; }
        public short DivingSoundPitchFactor { get; set; }
        public short DivingSoundVolumeFactor { get; set; }
        public short MaxDiveSoundPitch { get; set; }
        public short RadioType { get; set; }
        public float AircraftWarningSeriousDamageThresh { get; set; }
        public float AircraftWarningCriticalDamageThresh { get; set; }
        public float AircraftWarningMaxSpeed { get; set; }
        public MetaHash SimpleSoundForLoading { get; set; }
        public MetaHash FlyAwaySound { get; set; }
        public MetaHash VehicleRainSound { get; set; }
        public MetaHash VehicleRainSoundInterior { get; set; }
        public MetaHash CabinToneLoop { get; set; }
        public MetaHash WaveHitSound { get; set; }
        public MetaHash WaveHitBigAirSound { get; set; }
        public float BigAirMinTime { get; set; }
        public MetaHash LeftWaterSound { get; set; }
        public MetaHash IdleHullSlapLoop { get; set; }
        public MetaHash IdleHullSlapSpeedToVol { get; set; }
        public MetaHash WaterTurbulenceSound { get; set; }

        public int Version { get; set; }

        public Dat151PlaneAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.PlaneAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151PlaneAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            EngineLoop = br.ReadUInt32();
            ExhaustLoop = br.ReadUInt32();
            IdleLoop = br.ReadUInt32();
            DistanceLoop = br.ReadUInt32();
            PropellorLoop = br.ReadUInt32();
            BankingLoop = br.ReadUInt32();
            EngineConeFrontAngle = br.ReadUInt16();
            EngineConeRearAngle = br.ReadUInt16();
            EngineConeAtten = br.ReadInt16();
            ExhaustConeFrontAngle = br.ReadUInt16();
            ExhaustConeRearAngle = br.ReadUInt16();
            ExhaustConeAtten = br.ReadInt16();
            PropellorConeFrontAngle = br.ReadUInt16();
            PropellorConeRearAngle = br.ReadUInt16();
            PropellorConeAtten = br.ReadInt16();
            padding00 = br.ReadInt16();
            EngineThrottleVolumeCurve = br.ReadUInt32();
            EngineThrottlePitchCurve = br.ReadUInt32();
            ExhaustThrottleVolumeCurve = br.ReadUInt32();
            ExhaustThrottlePitchCurve = br.ReadUInt32();
            PropellorThrottleVolumeCurve = br.ReadUInt32();
            PropellorThrottlePitchCurve = br.ReadUInt32();
            IdleThrottleVolumeCurve = br.ReadUInt32();
            IdleThrottlePitchCurve = br.ReadUInt32();
            DistanceThrottleVolumeCurve = br.ReadUInt32();
            DistanceThrottlePitchCurve = br.ReadUInt32();
            DistanceVolumeCurve = br.ReadUInt32();
            StallWarning = br.ReadUInt32();
            DoorOpen = br.ReadUInt32();
            DoorClose = br.ReadUInt32();
            DoorLimit = br.ReadUInt32();
            LandingGearDeploy = br.ReadUInt32();
            LandingGearRetract = br.ReadUInt32();
            Ignition = br.ReadUInt32();
            TyreSqueal = br.ReadUInt32();
            BankingThrottleVolumeCurve = br.ReadUInt32();
            BankingThrottlePitchCurve = br.ReadUInt32();
            BankingAngleVolCurve = br.ReadUInt32();
            AfterburnerLoop = br.ReadUInt32();
            BankingStyle = br.ReadInt32();
            AfterburnerThrottleVolCurve = br.ReadUInt32();
            EngineSynthDef = br.ReadUInt32();
            EngineSynthPreset = br.ReadUInt32();
            ExhaustSynthDef = br.ReadUInt32();
            ExhaustSynthPreset = br.ReadUInt32();
            EngineSubmixVoice = br.ReadUInt32();
            ExhaustSubmixVoice = br.ReadUInt32();
            PropellorBreakOneShot = br.ReadUInt32();
            WindNoise = br.ReadUInt32();
            PeelingPitchCurve = br.ReadUInt32();
            DivingFactor = br.ReadInt16();
            MaxDivePitch = br.ReadInt16();
            DiveAirSpeedThreshold = br.ReadInt16();
            DivingRateApproachingGround = br.ReadInt16();
            PeelingAfterburnerPitchScalingFactor = br.ReadSingle();
            Rudder = br.ReadUInt32();
            Aileron = br.ReadUInt32();
            Elevator = br.ReadUInt32();
            DoorStartOpen = br.ReadUInt32();
            DoorStartClose = br.ReadUInt32();
            VehicleCollisions = br.ReadUInt32();
            FireAudio = br.ReadUInt32();
            EngineMissFire = br.ReadUInt32();
            IsRealLODRange = br.ReadUInt32();
            SuspensionUp = br.ReadUInt32();
            SuspensionDown = br.ReadUInt32();
            MinSuspCompThresh = br.ReadSingle();
            MaxSuspCompThresh = br.ReadSingle();
            DamageEngineSpeedVolumeCurve = br.ReadUInt32();
            DamageEngineSpeedPitchCurve = br.ReadUInt32();
            DamageHealthVolumeCurve = br.ReadUInt32();
            TurbineWindDown = br.ReadUInt32();
            JetDamageLoop = br.ReadUInt32();
            AfterburnerThrottlePitchCurve = br.ReadUInt32();
            NPCEngineSmoothAmount = br.ReadSingle();
            FlybySound = br.ReadUInt32();
            DivingSound = br.ReadUInt32();
            DivingSoundPitchFactor = br.ReadInt16();
            DivingSoundVolumeFactor = br.ReadInt16();
            MaxDiveSoundPitch = br.ReadInt16();
            RadioType = br.ReadInt16();
            AircraftWarningSeriousDamageThresh = br.ReadSingle();
            AircraftWarningCriticalDamageThresh = br.ReadSingle();
            AircraftWarningMaxSpeed = br.ReadSingle();
            SimpleSoundForLoading = br.ReadUInt32();
            FlyAwaySound = br.ReadUInt32();

            Version = 0;

            var bytesleft = br.BaseStream.Length - br.BaseStream.Position;
            if (bytesleft == 40) // If remaining bytes is equal to 40, write values
            {
                Version = 1;

                VehicleRainSound = br.ReadUInt32();
                VehicleRainSoundInterior = br.ReadUInt32();
                CabinToneLoop = br.ReadUInt32();
                WaveHitSound = br.ReadUInt32();
                WaveHitBigAirSound = br.ReadUInt32();
                BigAirMinTime = br.ReadSingle();
                LeftWaterSound = br.ReadUInt32();
                IdleHullSlapLoop = br.ReadUInt32();
                IdleHullSlapSpeedToVol = br.ReadUInt32();
                WaterTurbulenceSound = br.ReadUInt32();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(EngineLoop);
            bw.Write(ExhaustLoop);
            bw.Write(IdleLoop);
            bw.Write(DistanceLoop);
            bw.Write(PropellorLoop);
            bw.Write(BankingLoop);
            bw.Write(EngineConeFrontAngle);
            bw.Write(EngineConeRearAngle);
            bw.Write(EngineConeAtten);
            bw.Write(ExhaustConeFrontAngle);
            bw.Write(ExhaustConeRearAngle);
            bw.Write(ExhaustConeAtten);
            bw.Write(PropellorConeFrontAngle);
            bw.Write(PropellorConeRearAngle);
            bw.Write(PropellorConeAtten);
            bw.Write(padding00);
            bw.Write(EngineThrottleVolumeCurve);
            bw.Write(EngineThrottlePitchCurve);
            bw.Write(ExhaustThrottleVolumeCurve);
            bw.Write(ExhaustThrottlePitchCurve);
            bw.Write(PropellorThrottleVolumeCurve);
            bw.Write(PropellorThrottlePitchCurve);
            bw.Write(IdleThrottleVolumeCurve);
            bw.Write(IdleThrottlePitchCurve);
            bw.Write(DistanceThrottleVolumeCurve);
            bw.Write(DistanceThrottlePitchCurve);
            bw.Write(DistanceVolumeCurve);
            bw.Write(StallWarning);
            bw.Write(DoorOpen);
            bw.Write(DoorClose);
            bw.Write(DoorLimit);
            bw.Write(LandingGearDeploy);
            bw.Write(LandingGearRetract);
            bw.Write(Ignition);
            bw.Write(TyreSqueal);
            bw.Write(BankingThrottleVolumeCurve);
            bw.Write(BankingThrottlePitchCurve);
            bw.Write(BankingAngleVolCurve);
            bw.Write(AfterburnerLoop);
            bw.Write(BankingStyle);
            bw.Write(AfterburnerThrottleVolCurve);
            bw.Write(EngineSynthDef);
            bw.Write(EngineSynthPreset);
            bw.Write(ExhaustSynthDef);
            bw.Write(ExhaustSynthPreset);
            bw.Write(EngineSubmixVoice);
            bw.Write(ExhaustSubmixVoice);
            bw.Write(PropellorBreakOneShot);
            bw.Write(WindNoise);
            bw.Write(PeelingPitchCurve);
            bw.Write(DivingFactor);
            bw.Write(MaxDivePitch);
            bw.Write(DiveAirSpeedThreshold);
            bw.Write(DivingRateApproachingGround);
            bw.Write(PeelingAfterburnerPitchScalingFactor);
            bw.Write(Rudder);
            bw.Write(Aileron);
            bw.Write(Elevator);
            bw.Write(DoorStartOpen);
            bw.Write(DoorStartClose);
            bw.Write(VehicleCollisions);
            bw.Write(FireAudio);
            bw.Write(EngineMissFire);
            bw.Write(IsRealLODRange);
            bw.Write(SuspensionUp);
            bw.Write(SuspensionDown);
            bw.Write(MinSuspCompThresh);
            bw.Write(MaxSuspCompThresh);
            bw.Write(DamageEngineSpeedVolumeCurve);
            bw.Write(DamageEngineSpeedPitchCurve);
            bw.Write(DamageHealthVolumeCurve);
            bw.Write(TurbineWindDown);
            bw.Write(JetDamageLoop);
            bw.Write(AfterburnerThrottlePitchCurve);
            bw.Write(NPCEngineSmoothAmount);
            bw.Write(FlybySound);
            bw.Write(DivingSound);
            bw.Write(DivingSoundPitchFactor);
            bw.Write(DivingSoundVolumeFactor);
            bw.Write(MaxDiveSoundPitch);
            bw.Write(RadioType);
            bw.Write(AircraftWarningSeriousDamageThresh);
            bw.Write(AircraftWarningCriticalDamageThresh);
            bw.Write(AircraftWarningMaxSpeed);
            bw.Write(SimpleSoundForLoading);
            bw.Write(FlyAwaySound);

            if (Version >= 1)
            {
                bw.Write(VehicleRainSound);
                bw.Write(VehicleRainSoundInterior);
                bw.Write(CabinToneLoop);
                bw.Write(WaveHitSound);
                bw.Write(WaveHitBigAirSound);
                bw.Write(BigAirMinTime);
                bw.Write(LeftWaterSound);
                bw.Write(IdleHullSlapLoop);
                bw.Write(IdleHullSlapSpeedToVol);
                bw.Write(WaterTurbulenceSound);
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Version", Version.ToString());
            RelXml.StringTag(sb, indent, "EngineLoop", RelXml.HashString(EngineLoop));
            RelXml.StringTag(sb, indent, "ExhaustLoop", RelXml.HashString(ExhaustLoop));
            RelXml.StringTag(sb, indent, "IdleLoop", RelXml.HashString(IdleLoop));
            RelXml.StringTag(sb, indent, "DistanceLoop", RelXml.HashString(DistanceLoop));
            RelXml.StringTag(sb, indent, "PropellorLoop", RelXml.HashString(PropellorLoop));
            RelXml.StringTag(sb, indent, "BankingLoop", RelXml.HashString(BankingLoop));
            RelXml.ValueTag(sb, indent, "EngineConeFrontAngle", EngineConeFrontAngle.ToString());
            RelXml.ValueTag(sb, indent, "EngineConeRearAngle", EngineConeRearAngle.ToString());
            RelXml.ValueTag(sb, indent, "EngineConeAtten", EngineConeAtten.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustConeFrontAngle", ExhaustConeFrontAngle.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustConeRearAngle", ExhaustConeRearAngle.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustConeAtten", ExhaustConeAtten.ToString());
            RelXml.ValueTag(sb, indent, "PropellorConeFrontAngle", PropellorConeFrontAngle.ToString());
            RelXml.ValueTag(sb, indent, "PropellorConeRearAngle", PropellorConeRearAngle.ToString());
            RelXml.ValueTag(sb, indent, "PropellorConeAtten", PropellorConeAtten.ToString());
            RelXml.StringTag(sb, indent, "EngineThrottleVolumeCurve", RelXml.HashString(EngineThrottleVolumeCurve));
            RelXml.StringTag(sb, indent, "EngineThrottlePitchCurve", RelXml.HashString(EngineThrottlePitchCurve));
            RelXml.StringTag(sb, indent, "ExhaustThrottleVolumeCurve", RelXml.HashString(ExhaustThrottleVolumeCurve));
            RelXml.StringTag(sb, indent, "ExhaustThrottlePitchCurve", RelXml.HashString(ExhaustThrottlePitchCurve));
            RelXml.StringTag(sb, indent, "PropellorThrottleVolumeCurve", RelXml.HashString(PropellorThrottleVolumeCurve));
            RelXml.StringTag(sb, indent, "PropellorThrottlePitchCurve", RelXml.HashString(PropellorThrottlePitchCurve));
            RelXml.StringTag(sb, indent, "IdleThrottleVolumeCurve", RelXml.HashString(IdleThrottleVolumeCurve));
            RelXml.StringTag(sb, indent, "IdleThrottlePitchCurve", RelXml.HashString(IdleThrottlePitchCurve));
            RelXml.StringTag(sb, indent, "DistanceThrottleVolumeCurve", RelXml.HashString(DistanceThrottleVolumeCurve));
            RelXml.StringTag(sb, indent, "DistanceThrottlePitchCurve", RelXml.HashString(DistanceThrottlePitchCurve));
            RelXml.StringTag(sb, indent, "DistanceVolumeCurve", RelXml.HashString(DistanceVolumeCurve));
            RelXml.StringTag(sb, indent, "StallWarning", RelXml.HashString(StallWarning));
            RelXml.StringTag(sb, indent, "DoorOpen", RelXml.HashString(DoorOpen));
            RelXml.StringTag(sb, indent, "DoorClose", RelXml.HashString(DoorClose));
            RelXml.StringTag(sb, indent, "DoorLimit", RelXml.HashString(DoorLimit));
            RelXml.StringTag(sb, indent, "LandingGearDeploy", RelXml.HashString(LandingGearDeploy));
            RelXml.StringTag(sb, indent, "LandingGearRetract", RelXml.HashString(LandingGearRetract));
            RelXml.StringTag(sb, indent, "Ignition", RelXml.HashString(Ignition));
            RelXml.StringTag(sb, indent, "TyreSqueal", RelXml.HashString(TyreSqueal));
            RelXml.StringTag(sb, indent, "BankingThrottleVolumeCurve", RelXml.HashString(BankingThrottleVolumeCurve));
            RelXml.StringTag(sb, indent, "BankingThrottlePitchCurve", RelXml.HashString(BankingThrottlePitchCurve));
            RelXml.StringTag(sb, indent, "BankingAngleVolCurve", RelXml.HashString(BankingAngleVolCurve));
            RelXml.StringTag(sb, indent, "AfterburnerLoop", RelXml.HashString(AfterburnerLoop));
            RelXml.ValueTag(sb, indent, "BankingStyle", BankingStyle.ToString());
            RelXml.StringTag(sb, indent, "AfterburnerThrottleVolCurve", RelXml.HashString(AfterburnerThrottleVolCurve));
            RelXml.StringTag(sb, indent, "EngineSynthDef", RelXml.HashString(EngineSynthDef));
            RelXml.StringTag(sb, indent, "EngineSynthPreset", RelXml.HashString(EngineSynthPreset));
            RelXml.StringTag(sb, indent, "ExhaustSynthDef", RelXml.HashString(ExhaustSynthDef));
            RelXml.StringTag(sb, indent, "ExhaustSynthPreset", RelXml.HashString(ExhaustSynthPreset));
            RelXml.StringTag(sb, indent, "EngineSubmixVoice", RelXml.HashString(EngineSubmixVoice));
            RelXml.StringTag(sb, indent, "ExhaustSubmixVoice", RelXml.HashString(ExhaustSubmixVoice));
            RelXml.StringTag(sb, indent, "PropellorBreakOneShot", RelXml.HashString(PropellorBreakOneShot));
            RelXml.StringTag(sb, indent, "WindNoise", RelXml.HashString(WindNoise));
            RelXml.StringTag(sb, indent, "PeelingPitchCurve", RelXml.HashString(PeelingPitchCurve));
            RelXml.ValueTag(sb, indent, "DivingFactor", DivingFactor.ToString());
            RelXml.ValueTag(sb, indent, "MaxDivePitch", MaxDivePitch.ToString());
            RelXml.ValueTag(sb, indent, "DiveAirSpeedThreshold", DiveAirSpeedThreshold.ToString());
            RelXml.ValueTag(sb, indent, "DivingRateApproachingGround", DivingRateApproachingGround.ToString());
            RelXml.ValueTag(sb, indent, "PeelingAfterburnerPitchScalingFactor", FloatUtil.ToString(PeelingAfterburnerPitchScalingFactor));
            RelXml.StringTag(sb, indent, "Rudder", RelXml.HashString(Rudder));
            RelXml.StringTag(sb, indent, "Aileron", RelXml.HashString(Aileron));
            RelXml.StringTag(sb, indent, "Elevator", RelXml.HashString(Elevator));
            RelXml.StringTag(sb, indent, "DoorStartOpen", RelXml.HashString(DoorStartOpen));
            RelXml.StringTag(sb, indent, "DoorStartClose", RelXml.HashString(DoorStartClose));
            RelXml.StringTag(sb, indent, "VehicleCollisions", RelXml.HashString(VehicleCollisions));
            RelXml.StringTag(sb, indent, "FireAudio", RelXml.HashString(FireAudio));
            RelXml.StringTag(sb, indent, "EngineMissFire", RelXml.HashString(EngineMissFire));
            RelXml.ValueTag(sb, indent, "IsRealLODRange", IsRealLODRange.ToString());
            RelXml.StringTag(sb, indent, "SuspensionUp", RelXml.HashString(SuspensionUp));
            RelXml.StringTag(sb, indent, "SuspensionDown", RelXml.HashString(SuspensionDown));
            RelXml.ValueTag(sb, indent, "MinSuspCompThresh", FloatUtil.ToString(MinSuspCompThresh));
            RelXml.ValueTag(sb, indent, "MaxSuspCompThresh", FloatUtil.ToString(MaxSuspCompThresh));
            RelXml.StringTag(sb, indent, "DamageEngineSpeedVolumeCurve", RelXml.HashString(DamageEngineSpeedVolumeCurve));
            RelXml.StringTag(sb, indent, "DamageEngineSpeedPitchCurve", RelXml.HashString(DamageEngineSpeedPitchCurve));
            RelXml.StringTag(sb, indent, "DamageHealthVolumeCurve", RelXml.HashString(DamageHealthVolumeCurve));
            RelXml.StringTag(sb, indent, "TurbineWindDown", RelXml.HashString(TurbineWindDown));
            RelXml.StringTag(sb, indent, "JetDamageLoop", RelXml.HashString(JetDamageLoop));
            RelXml.StringTag(sb, indent, "AfterburnerThrottlePitchCurve", RelXml.HashString(AfterburnerThrottlePitchCurve));
            RelXml.ValueTag(sb, indent, "NPCEngineSmoothAmount", FloatUtil.ToString(NPCEngineSmoothAmount));
            RelXml.StringTag(sb, indent, "FlybySound", RelXml.HashString(FlybySound));
            RelXml.StringTag(sb, indent, "DivingSound", RelXml.HashString(DivingSound));
            RelXml.ValueTag(sb, indent, "DivingSoundPitchFactor", DivingSoundPitchFactor.ToString());
            RelXml.ValueTag(sb, indent, "DivingSoundVolumeFactor", DivingSoundVolumeFactor.ToString());
            RelXml.ValueTag(sb, indent, "MaxDiveSoundPitch", MaxDiveSoundPitch.ToString());
            RelXml.ValueTag(sb, indent, "RadioType", RadioType.ToString());
            RelXml.ValueTag(sb, indent, "AircraftWarningSeriousDamageThresh", FloatUtil.ToString(AircraftWarningSeriousDamageThresh));
            RelXml.ValueTag(sb, indent, "AircraftWarningCriticalDamageThresh", FloatUtil.ToString(AircraftWarningCriticalDamageThresh));
            RelXml.ValueTag(sb, indent, "AircraftWarningMaxSpeed", FloatUtil.ToString(AircraftWarningMaxSpeed));
            RelXml.StringTag(sb, indent, "SimpleSoundForLoading", RelXml.HashString(SimpleSoundForLoading));
            RelXml.StringTag(sb, indent, "FlyAwaySound", RelXml.HashString(FlyAwaySound));

            if (Version >= 1)
            {
                RelXml.StringTag(sb, indent, "VehicleRainSound", RelXml.HashString(VehicleRainSound));
                RelXml.StringTag(sb, indent, "VehicleRainSoundInterior", RelXml.HashString(VehicleRainSoundInterior));
                RelXml.StringTag(sb, indent, "CabinToneLoop", RelXml.HashString(CabinToneLoop));
                RelXml.StringTag(sb, indent, "WaveHitSound", RelXml.HashString(WaveHitSound));
                RelXml.StringTag(sb, indent, "WaveHitBigAirSound", RelXml.HashString(WaveHitBigAirSound));
                RelXml.ValueTag(sb, indent, "BigAirMinTime", FloatUtil.ToString(BigAirMinTime));
                RelXml.StringTag(sb, indent, "LeftWaterSound", RelXml.HashString(LeftWaterSound));
                RelXml.StringTag(sb, indent, "IdleHullSlapLoop", RelXml.HashString(IdleHullSlapLoop));
                RelXml.StringTag(sb, indent, "IdleHullSlapSpeedToVol", RelXml.HashString(IdleHullSlapSpeedToVol));
                RelXml.StringTag(sb, indent, "WaterTurbulenceSound", RelXml.HashString(WaterTurbulenceSound));
            }

        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Version = Xml.GetChildIntAttribute(node, "Version", "value");
            EngineLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineLoop"));
            ExhaustLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustLoop"));
            IdleLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "IdleLoop"));
            DistanceLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "DistanceLoop"));
            PropellorLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "PropellorLoop"));
            BankingLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankingLoop"));
            EngineConeFrontAngle = (ushort)Xml.GetChildIntAttribute(node, "EngineConeFrontAngle", "value");
            EngineConeRearAngle = (ushort)Xml.GetChildIntAttribute(node, "EngineConeRearAngle", "value");
            EngineConeAtten = (short)Xml.GetChildIntAttribute(node, "EngineConeAtten", "value");
            ExhaustConeFrontAngle = (ushort)Xml.GetChildIntAttribute(node, "ExhaustConeFrontAngle", "value");
            ExhaustConeRearAngle = (ushort)Xml.GetChildIntAttribute(node, "ExhaustConeRearAngle", "value");
            ExhaustConeAtten = (short)Xml.GetChildIntAttribute(node, "ExhaustConeAtten", "value");
            PropellorConeFrontAngle = (ushort)Xml.GetChildIntAttribute(node, "PropellorConeFrontAngle", "value");
            PropellorConeRearAngle = (ushort)Xml.GetChildIntAttribute(node, "PropellorConeRearAngle", "value");
            PropellorConeAtten = (short)Xml.GetChildIntAttribute(node, "PropellorConeAtten", "value");
            EngineThrottleVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineThrottleVolumeCurve"));
            EngineThrottlePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineThrottlePitchCurve"));
            ExhaustThrottleVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustThrottleVolumeCurve"));
            ExhaustThrottlePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustThrottlePitchCurve"));
            PropellorThrottleVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "PropellorThrottleVolumeCurve"));
            PropellorThrottlePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "PropellorThrottlePitchCurve"));
            IdleThrottleVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "IdleThrottleVolumeCurve"));
            IdleThrottlePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "IdleThrottlePitchCurve"));
            DistanceThrottleVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DistanceThrottleVolumeCurve"));
            DistanceThrottlePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DistanceThrottlePitchCurve"));
            DistanceVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DistanceVolumeCurve"));
            StallWarning = XmlRel.GetHash(Xml.GetChildInnerText(node, "StallWarning"));
            DoorOpen = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorOpen"));
            DoorClose = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorClose"));
            DoorLimit = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorLimit"));
            LandingGearDeploy = XmlRel.GetHash(Xml.GetChildInnerText(node, "LandingGearDeploy"));
            LandingGearRetract = XmlRel.GetHash(Xml.GetChildInnerText(node, "LandingGearRetract"));
            Ignition = XmlRel.GetHash(Xml.GetChildInnerText(node, "Ignition"));
            TyreSqueal = XmlRel.GetHash(Xml.GetChildInnerText(node, "TyreSqueal"));
            BankingThrottleVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankingThrottleVolumeCurve"));
            BankingThrottlePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankingThrottlePitchCurve"));
            BankingAngleVolCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankingAngleVolCurve"));
            AfterburnerLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "AfterburnerLoop"));
            BankingStyle = Xml.GetChildIntAttribute(node, "BankingStyle", "value");
            AfterburnerThrottleVolCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "AfterburnerThrottleVolCurve"));
            EngineSynthDef = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSynthDef"));
            EngineSynthPreset = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSynthPreset"));
            ExhaustSynthDef = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSynthDef"));
            ExhaustSynthPreset = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSynthPreset"));
            EngineSubmixVoice = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSubmixVoice"));
            ExhaustSubmixVoice = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSubmixVoice"));
            PropellorBreakOneShot = XmlRel.GetHash(Xml.GetChildInnerText(node, "PropellorBreakOneShot"));
            WindNoise = XmlRel.GetHash(Xml.GetChildInnerText(node, "WindNoise"));
            PeelingPitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "PeelingPitchCurve"));
            DivingFactor = (short)Xml.GetChildIntAttribute(node, "DivingFactor", "value");
            MaxDivePitch = (short)Xml.GetChildIntAttribute(node, "MaxDivePitch", "value");
            DiveAirSpeedThreshold = (short)Xml.GetChildIntAttribute(node, "DiveAirSpeedThreshold", "value");
            DivingRateApproachingGround = (short)Xml.GetChildIntAttribute(node, "DivingRateApproachingGround", "value");
            PeelingAfterburnerPitchScalingFactor = Xml.GetChildFloatAttribute(node, "PeelingAfterburnerPitchScalingFactor", "value");
            Rudder = XmlRel.GetHash(Xml.GetChildInnerText(node, "Rudder"));
            Aileron = XmlRel.GetHash(Xml.GetChildInnerText(node, "Aileron"));
            Elevator = XmlRel.GetHash(Xml.GetChildInnerText(node, "Elevator"));
            DoorStartOpen = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorStartOpen"));
            DoorStartClose = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorStartClose"));
            VehicleCollisions = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleCollisions"));
            FireAudio = XmlRel.GetHash(Xml.GetChildInnerText(node, "FireAudio"));
            EngineMissFire = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineMissFire"));
            IsRealLODRange = Xml.GetChildUIntAttribute(node, "IsRealLODRange", "value");
            SuspensionUp = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuspensionUp"));
            SuspensionDown = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuspensionDown"));
            MinSuspCompThresh = Xml.GetChildFloatAttribute(node, "MinSuspCompThresh", "value");
            MaxSuspCompThresh = Xml.GetChildFloatAttribute(node, "MaxSuspCompThresh", "value");
            DamageEngineSpeedVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DamageEngineSpeedVolumeCurve"));
            DamageEngineSpeedPitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DamageEngineSpeedPitchCurve"));
            DamageHealthVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DamageHealthVolumeCurve"));
            TurbineWindDown = XmlRel.GetHash(Xml.GetChildInnerText(node, "TurbineWindDown"));
            JetDamageLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "JetDamageLoop"));
            AfterburnerThrottlePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "AfterburnerThrottlePitchCurve"));
            NPCEngineSmoothAmount = Xml.GetChildFloatAttribute(node, "NPCEngineSmoothAmount", "value");
            FlybySound = XmlRel.GetHash(Xml.GetChildInnerText(node, "FlybySound"));
            DivingSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "DivingSound"));
            DivingSoundPitchFactor = (short)Xml.GetChildIntAttribute(node, "DivingSoundPitchFactor", "value");
            DivingSoundVolumeFactor = (short)Xml.GetChildIntAttribute(node, "DivingSoundVolumeFactor", "value");
            MaxDiveSoundPitch = (short)Xml.GetChildIntAttribute(node, "MaxDiveSoundPitch", "value");
            RadioType = (short)Xml.GetChildIntAttribute(node, "RadioType", "value");
            AircraftWarningSeriousDamageThresh = Xml.GetChildFloatAttribute(node, "AircraftWarningSeriousDamageThresh", "value");
            AircraftWarningCriticalDamageThresh = Xml.GetChildFloatAttribute(node, "AircraftWarningCriticalDamageThresh", "value");
            AircraftWarningMaxSpeed = Xml.GetChildFloatAttribute(node, "AircraftWarningMaxSpeed", "value");
            SimpleSoundForLoading = XmlRel.GetHash(Xml.GetChildInnerText(node, "SimpleSoundForLoading"));
            FlyAwaySound = XmlRel.GetHash(Xml.GetChildInnerText(node, "FlyAwaySound"));

            if (Version >= 1)
            {
                VehicleRainSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleRainSound"));
                VehicleRainSoundInterior = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleRainSoundInterior"));
                CabinToneLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "CabinToneLoop"));
                WaveHitSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "WaveHitSound"));
                WaveHitBigAirSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "WaveHitBigAirSound"));
                BigAirMinTime = Xml.GetChildFloatAttribute(node, "BigAirMinTime", "value");
                LeftWaterSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "LeftWaterSound"));
                IdleHullSlapLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "IdleHullSlapLoop"));
                IdleHullSlapSpeedToVol = XmlRel.GetHash(Xml.GetChildInnerText(node, "IdleHullSlapSpeedToVol"));
                WaterTurbulenceSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "WaterTurbulenceSound"));
            }


        }
        public override MetaHash[] GetSynthHashes()
        {
            return new[] { EngineSynthDef, EngineSynthPreset };
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { EngineThrottleVolumeCurve, EngineThrottlePitchCurve, ExhaustThrottleVolumeCurve, ExhaustThrottlePitchCurve, PropellorThrottleVolumeCurve, PropellorThrottlePitchCurve, IdleThrottleVolumeCurve, IdleThrottlePitchCurve, DistanceThrottleVolumeCurve, DistanceThrottlePitchCurve, DistanceVolumeCurve, BankingThrottleVolumeCurve, BankingThrottlePitchCurve, BankingAngleVolCurve, AfterburnerThrottleVolCurve, PeelingPitchCurve,
                DamageEngineSpeedVolumeCurve, DamageEngineSpeedPitchCurve, DamageHealthVolumeCurve, AfterburnerThrottlePitchCurve, IdleHullSlapSpeedToVol };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { EngineLoop, ExhaustLoop, IdleLoop, DistanceLoop, PropellorLoop, BankingLoop, StallWarning, DoorOpen, DoorClose, DoorLimit, LandingGearDeploy, LandingGearRetract,
                Ignition, TyreSqueal, AfterburnerLoop, EngineSubmixVoice, ExhaustSubmixVoice, PropellorBreakOneShot, WindNoise, Rudder, Aileron, Elevator, DoorStartOpen, DoorStartClose, FireAudio, EngineMissFire,
                SuspensionUp, SuspensionDown, TurbineWindDown, JetDamageLoop, FlybySound, DivingSound, SimpleSoundForLoading, FlyAwaySound, VehicleRainSound, VehicleRainSoundInterior, WaveHitSound, WaveHitBigAirSound, IdleHullSlapLoop, WaterTurbulenceSound };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { VehicleCollisions };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151HeliAudioSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash RotorLoop { get; set; }
        public MetaHash RearRotorLoop { get; set; }
        public MetaHash ExhaustLoop { get; set; }
        public MetaHash BankingLoop { get; set; }
        public MetaHash CabinToneLoop { get; set; }
        public float ThrottleSmoothRate { get; set; }
        public MetaHash BankAngleVolumeCurve { get; set; }
        public MetaHash BankThrottleVolumeCurve { get; set; }
        public MetaHash BankThrottlePitchCurve { get; set; }
        public MetaHash RotorThrottleVolumeCurve { get; set; }
        public MetaHash RotorThrottlePitchCurve { get; set; }
        public MetaHash RotorThrottleGapCurve { get; set; }
        public MetaHash RearRotorThrottleVolumeCurve { get; set; }
        public MetaHash ExhaustThrottleVolumeCurve { get; set; }
        public MetaHash ExhaustThrottlePitchCurve { get; set; }
        public ushort RotorConeFrontAngle { get; set; }
        public ushort RotorConeRearAngle { get; set; }
        public short RotorConeAtten { get; set; }
        public ushort RearRotorConeFrontAngle { get; set; }
        public ushort RearRotorConeRearAngle { get; set; }
        public short RearRotorConeAtten { get; set; }
        public ushort ExhaustConeFrontAngle { get; set; }
        public ushort ExhaustConeRearAngle { get; set; }
        public short ExhaustConeAtten { get; set; }
        public short padding00 { get; set; }
        public MetaHash Filter1ThrottleResonanceCurve { get; set; }
        public MetaHash Filter2ThrottleResonanceCurve { get; set; }
        public MetaHash BankingResonanceCurve { get; set; }
        public MetaHash RotorVolumeStartupCurve { get; set; }
        public MetaHash BladeVolumeStartupCurve { get; set; }
        public MetaHash RotorPitchStartupCurve { get; set; }
        public MetaHash RearRotorVolumeStartupCurve { get; set; }
        public MetaHash ExhaustStartupVolume { get; set; }
        public MetaHash RotorGapStartupCurve { get; set; }
        public MetaHash StartUpOneShot { get; set; }
        public ushort BladeConeUpAngle { get; set; }
        public ushort BladeConeDownAngle { get; set; }
        public short BladeConeAtten { get; set; }
        public ushort ThumpConeUpAngle { get; set; }
        public ushort ThumpConeDownAngle { get; set; }
        public short ThumpConeAtten { get; set; }
        public MetaHash ScannerMake { get; set; }
        public MetaHash ScannerModel { get; set; }
        public MetaHash ScannerCategory { get; set; }
        public MetaHash ScannerVehicleSettings { get; set; }
        public byte RadioType { get; set; }
        public byte RadioGenre { get; set; }
        public short padding0 { get; set; }
        public MetaHash DoorOpen { get; set; }
        public MetaHash DoorClose { get; set; }
        public MetaHash DoorLimit { get; set; }
        public MetaHash DamageLoop { get; set; }
        public MetaHash RotorSpeedToTriggerSpeedCurve { get; set; }
        public short RotorVolumePostSubmix { get; set; }
        public short padding01 { get; set; }
        public MetaHash EngineSynthDef { get; set; }
        public MetaHash EngineSynthPreset { get; set; }
        public MetaHash ExhaustSynthDef { get; set; }
        public MetaHash ExhaustSynthPreset { get; set; }
        public MetaHash EngineSubmixVoice { get; set; }
        public MetaHash ExhaustSubmixVoice { get; set; }
        public MetaHash RotorLowFreqLoop { get; set; }
        public MetaHash ExhaustPitchStartupCurve { get; set; }
        public MetaHash VehicleCollisions { get; set; }
        public MetaHash FireAudio { get; set; }
        public MetaHash DistantLoop { get; set; }
        public MetaHash SecondaryDoorStartOpen { get; set; }
        public MetaHash SecondaryDoorStartClose { get; set; }
        public MetaHash SecondaryDoorClose { get; set; }
        public MetaHash SecondaryDoorLimit { get; set; }
        public MetaHash SuspensionUp { get; set; }
        public MetaHash SuspensionDown { get; set; }
        public float MinSuspCompThresh { get; set; }
        public float MaxSuspCompThresh { get; set; }
        public MetaHash DamageOneShots { get; set; }
        public MetaHash DamageWarning { get; set; }
        public MetaHash TailBreak { get; set; }
        public MetaHash RotorBreak { get; set; }
        public MetaHash RearRotorBreak { get; set; }
        public MetaHash CableDeploy { get; set; }
        public MetaHash HardScrape { get; set; }
        public MetaHash EngineCooling { get; set; }
        public MetaHash AltitudeWarning { get; set; }
        public MetaHash HealthToDamageVolumeCurve { get; set; }
        public MetaHash HealthBelow600ToDamageVolumeCurve { get; set; }
        public MetaHash DamageBelow600Loop { get; set; }
        public float AircraftWarningSeriousDamageThresh { get; set; }
        public float AircraftWarningCriticalDamageThresh { get; set; }
        public float AircraftWarningMaxSpeed { get; set; }
        public MetaHash SimpleSoundForLoading { get; set; }
        public MetaHash SlowMoRotorLoop { get; set; }
        public MetaHash SlowMoRotorLowFreqLoop { get; set; }
        public MetaHash VehicleRainSound { get; set; }
        public MetaHash VehicleRainSoundInterior { get; set; }
        public MetaHash StartUpFailOneShot { get; set; }

        public int Version { get; set; }


        public Dat151HeliAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.HeliAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151HeliAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            RotorLoop = br.ReadUInt32();
            RearRotorLoop = br.ReadUInt32();
            ExhaustLoop = br.ReadUInt32();
            BankingLoop = br.ReadUInt32();
            CabinToneLoop = br.ReadUInt32();
            ThrottleSmoothRate = br.ReadSingle();
            BankAngleVolumeCurve = br.ReadUInt32();
            BankThrottleVolumeCurve = br.ReadUInt32();
            BankThrottlePitchCurve = br.ReadUInt32();
            RotorThrottleVolumeCurve = br.ReadUInt32();
            RotorThrottlePitchCurve = br.ReadUInt32();
            RotorThrottleGapCurve = br.ReadUInt32();
            RearRotorThrottleVolumeCurve = br.ReadUInt32();
            ExhaustThrottleVolumeCurve = br.ReadUInt32();
            ExhaustThrottlePitchCurve = br.ReadUInt32();
            RotorConeFrontAngle = br.ReadUInt16();
            RotorConeRearAngle = br.ReadUInt16();
            RotorConeAtten = br.ReadInt16();
            RearRotorConeFrontAngle = br.ReadUInt16();
            RearRotorConeRearAngle = br.ReadUInt16();
            RearRotorConeAtten = br.ReadInt16();
            ExhaustConeFrontAngle = br.ReadUInt16();
            ExhaustConeRearAngle = br.ReadUInt16();
            ExhaustConeAtten = br.ReadInt16();
            padding00 = br.ReadInt16();
            Filter1ThrottleResonanceCurve = br.ReadUInt32();
            Filter2ThrottleResonanceCurve = br.ReadUInt32();
            BankingResonanceCurve = br.ReadUInt32();
            RotorVolumeStartupCurve = br.ReadUInt32();
            BladeVolumeStartupCurve = br.ReadUInt32();
            RotorPitchStartupCurve = br.ReadUInt32();
            RearRotorVolumeStartupCurve = br.ReadUInt32();
            ExhaustStartupVolume = br.ReadUInt32();
            RotorGapStartupCurve = br.ReadUInt32();
            StartUpOneShot = br.ReadUInt32();
            BladeConeUpAngle = br.ReadUInt16();
            BladeConeDownAngle = br.ReadUInt16();
            BladeConeAtten = br.ReadInt16();
            ThumpConeUpAngle = br.ReadUInt16();
            ThumpConeDownAngle = br.ReadUInt16();
            ThumpConeAtten = br.ReadInt16();
            ScannerMake = br.ReadUInt32();
            ScannerModel = br.ReadUInt32();
            ScannerCategory = br.ReadUInt32();
            ScannerVehicleSettings = br.ReadUInt32();
            RadioType = br.ReadByte();
            RadioGenre = br.ReadByte();
            padding0 = br.ReadInt16();
            DoorOpen = br.ReadUInt32();
            DoorClose = br.ReadUInt32();
            DoorLimit = br.ReadUInt32();
            DamageLoop = br.ReadUInt32();
            RotorSpeedToTriggerSpeedCurve = br.ReadUInt32();
            RotorVolumePostSubmix = br.ReadInt16();
            padding01 = br.ReadInt16();
            EngineSynthDef = br.ReadUInt32();
            EngineSynthPreset = br.ReadUInt32();
            ExhaustSynthDef = br.ReadUInt32();
            ExhaustSynthPreset = br.ReadUInt32();
            EngineSubmixVoice = br.ReadUInt32();
            ExhaustSubmixVoice = br.ReadUInt32();
            RotorLowFreqLoop = br.ReadUInt32();
            ExhaustPitchStartupCurve = br.ReadUInt32();
            VehicleCollisions = br.ReadUInt32();
            FireAudio = br.ReadUInt32();
            DistantLoop = br.ReadUInt32();
            SecondaryDoorStartOpen = br.ReadUInt32();
            SecondaryDoorStartClose = br.ReadUInt32();
            SecondaryDoorClose = br.ReadUInt32();
            SecondaryDoorLimit = br.ReadUInt32();
            SuspensionUp = br.ReadUInt32();
            SuspensionDown = br.ReadUInt32();
            MinSuspCompThresh = br.ReadSingle();
            MaxSuspCompThresh = br.ReadSingle();
            DamageOneShots = br.ReadUInt32();
            DamageWarning = br.ReadUInt32();
            TailBreak = br.ReadUInt32();
            RotorBreak = br.ReadUInt32();
            RearRotorBreak = br.ReadUInt32();
            CableDeploy = br.ReadUInt32();
            HardScrape = br.ReadUInt32();
            EngineCooling = br.ReadUInt32();
            AltitudeWarning = br.ReadUInt32();
            HealthToDamageVolumeCurve = br.ReadUInt32();
            HealthBelow600ToDamageVolumeCurve = br.ReadUInt32();
            DamageBelow600Loop = br.ReadUInt32();
            AircraftWarningSeriousDamageThresh = br.ReadSingle();
            AircraftWarningCriticalDamageThresh = br.ReadSingle();
            AircraftWarningMaxSpeed = br.ReadSingle();
            SimpleSoundForLoading = br.ReadUInt32();
            SlowMoRotorLoop = br.ReadUInt32();
            SlowMoRotorLowFreqLoop = br.ReadUInt32();

            Version = 0;

            var bytesleft = br.BaseStream.Length - br.BaseStream.Position;
            if (bytesleft >= 12) // If remaining bytes is greater or equal to 12, write values
            {
                Version = 1;

                VehicleRainSound = br.ReadUInt32();
                VehicleRainSoundInterior = br.ReadUInt32();
                StartUpFailOneShot = br.ReadUInt32();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(RotorLoop);
            bw.Write(RearRotorLoop);
            bw.Write(ExhaustLoop);
            bw.Write(BankingLoop);
            bw.Write(CabinToneLoop);
            bw.Write(ThrottleSmoothRate);
            bw.Write(BankAngleVolumeCurve);
            bw.Write(BankThrottleVolumeCurve);
            bw.Write(BankThrottlePitchCurve);
            bw.Write(RotorThrottleVolumeCurve);
            bw.Write(RotorThrottlePitchCurve);
            bw.Write(RotorThrottleGapCurve);
            bw.Write(RearRotorThrottleVolumeCurve);
            bw.Write(ExhaustThrottleVolumeCurve);
            bw.Write(ExhaustThrottlePitchCurve);
            bw.Write(RotorConeFrontAngle);
            bw.Write(RotorConeRearAngle);
            bw.Write(RotorConeAtten);
            bw.Write(RearRotorConeFrontAngle);
            bw.Write(RearRotorConeRearAngle);
            bw.Write(RearRotorConeAtten);
            bw.Write(ExhaustConeFrontAngle);
            bw.Write(ExhaustConeRearAngle);
            bw.Write(ExhaustConeAtten);
            bw.Write(padding00);
            bw.Write(Filter1ThrottleResonanceCurve);
            bw.Write(Filter2ThrottleResonanceCurve);
            bw.Write(BankingResonanceCurve);
            bw.Write(RotorVolumeStartupCurve);
            bw.Write(BladeVolumeStartupCurve);
            bw.Write(RotorPitchStartupCurve);
            bw.Write(RearRotorVolumeStartupCurve);
            bw.Write(ExhaustStartupVolume);
            bw.Write(RotorGapStartupCurve);
            bw.Write(StartUpOneShot);
            bw.Write(BladeConeUpAngle);
            bw.Write(BladeConeDownAngle);
            bw.Write(BladeConeAtten);
            bw.Write(ThumpConeUpAngle);
            bw.Write(ThumpConeDownAngle);
            bw.Write(ThumpConeAtten);
            bw.Write(ScannerMake);
            bw.Write(ScannerModel);
            bw.Write(ScannerCategory);
            bw.Write(ScannerVehicleSettings);
            bw.Write(RadioType);
            bw.Write(RadioGenre);
            bw.Write(padding0);
            bw.Write(DoorOpen);
            bw.Write(DoorClose);
            bw.Write(DoorLimit);
            bw.Write(DamageLoop);
            bw.Write(RotorSpeedToTriggerSpeedCurve);
            bw.Write(RotorVolumePostSubmix);
            bw.Write(padding01);
            bw.Write(EngineSynthDef);
            bw.Write(EngineSynthPreset);
            bw.Write(ExhaustSynthDef);
            bw.Write(ExhaustSynthPreset);
            bw.Write(EngineSubmixVoice);
            bw.Write(ExhaustSubmixVoice);
            bw.Write(RotorLowFreqLoop);
            bw.Write(ExhaustPitchStartupCurve);
            bw.Write(VehicleCollisions);
            bw.Write(FireAudio);
            bw.Write(DistantLoop);
            bw.Write(SecondaryDoorStartOpen);
            bw.Write(SecondaryDoorStartClose);
            bw.Write(SecondaryDoorClose);
            bw.Write(SecondaryDoorLimit);
            bw.Write(SuspensionUp);
            bw.Write(SuspensionDown);
            bw.Write(MinSuspCompThresh);
            bw.Write(MaxSuspCompThresh);
            bw.Write(DamageOneShots);
            bw.Write(DamageWarning);
            bw.Write(TailBreak);
            bw.Write(RotorBreak);
            bw.Write(RearRotorBreak);
            bw.Write(CableDeploy);
            bw.Write(HardScrape);
            bw.Write(EngineCooling);
            bw.Write(AltitudeWarning);
            bw.Write(HealthToDamageVolumeCurve);
            bw.Write(HealthBelow600ToDamageVolumeCurve);
            bw.Write(DamageBelow600Loop);
            bw.Write(AircraftWarningSeriousDamageThresh);
            bw.Write(AircraftWarningCriticalDamageThresh);
            bw.Write(AircraftWarningMaxSpeed);
            bw.Write(SimpleSoundForLoading);
            bw.Write(SlowMoRotorLoop);
            bw.Write(SlowMoRotorLowFreqLoop);

            if (Version >= 1)
            {
                bw.Write(VehicleRainSound);
                bw.Write(VehicleRainSoundInterior);
                bw.Write(StartUpFailOneShot);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Version", Version.ToString());
            RelXml.StringTag(sb, indent, "RotorLoop", RelXml.HashString(RotorLoop));
            RelXml.StringTag(sb, indent, "RearRotorLoop", RelXml.HashString(RearRotorLoop));
            RelXml.StringTag(sb, indent, "ExhaustLoop", RelXml.HashString(ExhaustLoop));
            RelXml.StringTag(sb, indent, "BankingLoop", RelXml.HashString(BankingLoop));
            RelXml.StringTag(sb, indent, "CabinToneLoop", RelXml.HashString(CabinToneLoop));
            RelXml.ValueTag(sb, indent, "ThrottleSmoothRate", FloatUtil.ToString(ThrottleSmoothRate));
            RelXml.StringTag(sb, indent, "BankAngleVolumeCurve", RelXml.HashString(BankAngleVolumeCurve));
            RelXml.StringTag(sb, indent, "BankThrottleVolumeCurve", RelXml.HashString(BankThrottleVolumeCurve));
            RelXml.StringTag(sb, indent, "BankThrottlePitchCurve", RelXml.HashString(BankThrottlePitchCurve));
            RelXml.StringTag(sb, indent, "RotorThrottleVolumeCurve", RelXml.HashString(RotorThrottleVolumeCurve));
            RelXml.StringTag(sb, indent, "RotorThrottlePitchCurve", RelXml.HashString(RotorThrottlePitchCurve));
            RelXml.StringTag(sb, indent, "RotorThrottleGapCurve", RelXml.HashString(RotorThrottleGapCurve));
            RelXml.StringTag(sb, indent, "RearRotorThrottleVolumeCurve", RelXml.HashString(RearRotorThrottleVolumeCurve));
            RelXml.StringTag(sb, indent, "ExhaustThrottleVolumeCurve", RelXml.HashString(ExhaustThrottleVolumeCurve));
            RelXml.StringTag(sb, indent, "ExhaustThrottlePitchCurve", RelXml.HashString(ExhaustThrottlePitchCurve));
            RelXml.ValueTag(sb, indent, "RotorConeFrontAngle", RotorConeFrontAngle.ToString());
            RelXml.ValueTag(sb, indent, "RotorConeRearAngle", RotorConeRearAngle.ToString());
            RelXml.ValueTag(sb, indent, "RotorConeAtten", RotorConeAtten.ToString());
            RelXml.ValueTag(sb, indent, "RearRotorConeFrontAngle", RearRotorConeFrontAngle.ToString());
            RelXml.ValueTag(sb, indent, "RearRotorConeRearAngle", RearRotorConeRearAngle.ToString());
            RelXml.ValueTag(sb, indent, "RearRotorConeAtten", RearRotorConeAtten.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustConeFrontAngle", ExhaustConeFrontAngle.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustConeRearAngle", ExhaustConeRearAngle.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustConeAtten", ExhaustConeAtten.ToString());
            RelXml.StringTag(sb, indent, "Filter1ThrottleResonanceCurve", RelXml.HashString(Filter1ThrottleResonanceCurve));
            RelXml.StringTag(sb, indent, "Filter2ThrottleResonanceCurve", RelXml.HashString(Filter2ThrottleResonanceCurve));
            RelXml.StringTag(sb, indent, "BankingResonanceCurve", RelXml.HashString(BankingResonanceCurve));
            RelXml.StringTag(sb, indent, "RotorVolumeStartupCurve", RelXml.HashString(RotorVolumeStartupCurve));
            RelXml.StringTag(sb, indent, "BladeVolumeStartupCurve", RelXml.HashString(BladeVolumeStartupCurve));
            RelXml.StringTag(sb, indent, "RotorPitchStartupCurve", RelXml.HashString(RotorPitchStartupCurve));
            RelXml.StringTag(sb, indent, "RearRotorVolumeStartupCurve", RelXml.HashString(RearRotorVolumeStartupCurve));
            RelXml.StringTag(sb, indent, "ExhaustStartupVolume", RelXml.HashString(ExhaustStartupVolume));
            RelXml.StringTag(sb, indent, "RotorGapStartupCurve", RelXml.HashString(RotorGapStartupCurve));
            RelXml.StringTag(sb, indent, "StartUpOneShot", RelXml.HashString(StartUpOneShot));
            RelXml.ValueTag(sb, indent, "BladeConeUpAngle", BladeConeUpAngle.ToString());
            RelXml.ValueTag(sb, indent, "BladeConeDownAngle", BladeConeDownAngle.ToString());
            RelXml.ValueTag(sb, indent, "BladeConeAtten", BladeConeAtten.ToString());
            RelXml.ValueTag(sb, indent, "ThumpConeUpAngle", ThumpConeUpAngle.ToString());
            RelXml.ValueTag(sb, indent, "ThumpConeDownAngle", ThumpConeDownAngle.ToString());
            RelXml.ValueTag(sb, indent, "ThumpConeAtten", ThumpConeAtten.ToString());
            RelXml.StringTag(sb, indent, "ScannerMake", RelXml.HashString(ScannerMake));
            RelXml.StringTag(sb, indent, "ScannerModel", RelXml.HashString(ScannerModel));
            RelXml.StringTag(sb, indent, "ScannerCategory", RelXml.HashString(ScannerCategory));
            RelXml.StringTag(sb, indent, "ScannerVehicleSettings", RelXml.HashString(ScannerVehicleSettings));
            RelXml.ValueTag(sb, indent, "RadioType", RadioType.ToString());
            RelXml.ValueTag(sb, indent, "RadioGenre", RadioGenre.ToString());
            RelXml.StringTag(sb, indent, "DoorOpen", RelXml.HashString(DoorOpen));
            RelXml.StringTag(sb, indent, "DoorClose", RelXml.HashString(DoorClose));
            RelXml.StringTag(sb, indent, "DoorLimit", RelXml.HashString(DoorLimit));
            RelXml.StringTag(sb, indent, "DamageLoop", RelXml.HashString(DamageLoop));
            RelXml.StringTag(sb, indent, "RotorSpeedToTriggerSpeedCurve", RelXml.HashString(RotorSpeedToTriggerSpeedCurve));
            RelXml.ValueTag(sb, indent, "RotorVolumePostSubmix", RotorVolumePostSubmix.ToString());
            RelXml.StringTag(sb, indent, "EngineSynthDef", RelXml.HashString(EngineSynthDef));
            RelXml.StringTag(sb, indent, "EngineSynthPreset", RelXml.HashString(EngineSynthPreset));
            RelXml.StringTag(sb, indent, "ExhaustSynthDef", RelXml.HashString(ExhaustSynthDef));
            RelXml.StringTag(sb, indent, "ExhaustSynthPreset", RelXml.HashString(ExhaustSynthPreset));
            RelXml.StringTag(sb, indent, "EngineSubmixVoice", RelXml.HashString(EngineSubmixVoice));
            RelXml.StringTag(sb, indent, "ExhaustSubmixVoice", RelXml.HashString(ExhaustSubmixVoice));
            RelXml.StringTag(sb, indent, "RotorLowFreqLoop", RelXml.HashString(RotorLowFreqLoop));
            RelXml.StringTag(sb, indent, "ExhaustPitchStartupCurve", RelXml.HashString(ExhaustPitchStartupCurve));
            RelXml.StringTag(sb, indent, "VehicleCollisions", RelXml.HashString(VehicleCollisions));
            RelXml.StringTag(sb, indent, "FireAudio", RelXml.HashString(FireAudio));
            RelXml.StringTag(sb, indent, "DistantLoop", RelXml.HashString(DistantLoop));
            RelXml.StringTag(sb, indent, "SecondaryDoorStartOpen", RelXml.HashString(SecondaryDoorStartOpen));
            RelXml.StringTag(sb, indent, "SecondaryDoorStartClose", RelXml.HashString(SecondaryDoorStartClose));
            RelXml.StringTag(sb, indent, "SecondaryDoorClose", RelXml.HashString(SecondaryDoorClose));
            RelXml.StringTag(sb, indent, "SecondaryDoorLimit", RelXml.HashString(SecondaryDoorLimit));
            RelXml.StringTag(sb, indent, "SuspensionUp", RelXml.HashString(SuspensionUp));
            RelXml.StringTag(sb, indent, "SuspensionDown", RelXml.HashString(SuspensionDown));
            RelXml.ValueTag(sb, indent, "MinSuspCompThresh", FloatUtil.ToString(MinSuspCompThresh));
            RelXml.ValueTag(sb, indent, "MaxSuspCompThresh", FloatUtil.ToString(MaxSuspCompThresh));
            RelXml.StringTag(sb, indent, "DamageOneShots", RelXml.HashString(DamageOneShots));
            RelXml.StringTag(sb, indent, "DamageWarning", RelXml.HashString(DamageWarning));
            RelXml.StringTag(sb, indent, "TailBreak", RelXml.HashString(TailBreak));
            RelXml.StringTag(sb, indent, "RotorBreak", RelXml.HashString(RotorBreak));
            RelXml.StringTag(sb, indent, "RearRotorBreak", RelXml.HashString(RearRotorBreak));
            RelXml.StringTag(sb, indent, "CableDeploy", RelXml.HashString(CableDeploy));
            RelXml.StringTag(sb, indent, "HardScrape", RelXml.HashString(HardScrape));
            RelXml.StringTag(sb, indent, "EngineCooling", RelXml.HashString(EngineCooling));
            RelXml.StringTag(sb, indent, "AltitudeWarning", RelXml.HashString(AltitudeWarning));
            RelXml.StringTag(sb, indent, "HealthToDamageVolumeCurve", RelXml.HashString(HealthToDamageVolumeCurve));
            RelXml.StringTag(sb, indent, "HealthBelow600ToDamageVolumeCurve", RelXml.HashString(HealthBelow600ToDamageVolumeCurve));
            RelXml.StringTag(sb, indent, "DamageBelow600Loop", RelXml.HashString(DamageBelow600Loop));
            RelXml.ValueTag(sb, indent, "AircraftWarningSeriousDamageThresh", FloatUtil.ToString(AircraftWarningSeriousDamageThresh));
            RelXml.ValueTag(sb, indent, "AircraftWarningCriticalDamageThresh", FloatUtil.ToString(AircraftWarningCriticalDamageThresh));
            RelXml.ValueTag(sb, indent, "AircraftWarningMaxSpeed", FloatUtil.ToString(AircraftWarningMaxSpeed));
            RelXml.StringTag(sb, indent, "SimpleSoundForLoading", RelXml.HashString(SimpleSoundForLoading));
            RelXml.StringTag(sb, indent, "SlowMoRotorLoop", RelXml.HashString(SlowMoRotorLoop));
            RelXml.StringTag(sb, indent, "SlowMoRotorLowFreqLoop", RelXml.HashString(SlowMoRotorLowFreqLoop));

            if (Version >= 1)
            {
                RelXml.StringTag(sb, indent, "VehicleRainSound", RelXml.HashString(VehicleRainSound));
                RelXml.StringTag(sb, indent, "VehicleRainSoundInterior", RelXml.HashString(VehicleRainSoundInterior));
                RelXml.StringTag(sb, indent, "StartUpFailOneShot", RelXml.HashString(StartUpFailOneShot));
            }

        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Version = Xml.GetChildIntAttribute(node, "Version", "value");
            RotorLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "RotorLoop"));
            RearRotorLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "RearRotorLoop"));
            ExhaustLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustLoop"));
            BankingLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankingLoop"));
            CabinToneLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "CabinToneLoop"));
            ThrottleSmoothRate = Xml.GetChildFloatAttribute(node, "ThrottleSmoothRate", "value");
            BankAngleVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankAngleVolumeCurve"));
            BankThrottleVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankThrottleVolumeCurve"));
            BankThrottlePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankThrottlePitchCurve"));
            RotorThrottleVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "RotorThrottleVolumeCurve"));
            RotorThrottlePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "RotorThrottlePitchCurve"));
            RotorThrottleGapCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "RotorThrottleGapCurve"));
            RearRotorThrottleVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "RearRotorThrottleVolumeCurve"));
            ExhaustThrottleVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustThrottleVolumeCurve"));
            ExhaustThrottlePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustThrottlePitchCurve"));
            RotorConeFrontAngle = (ushort)Xml.GetChildIntAttribute(node, "RotorConeFrontAngle", "value");
            RotorConeRearAngle = (ushort)Xml.GetChildIntAttribute(node, "RotorConeRearAngle", "value");
            RotorConeAtten = (short)Xml.GetChildIntAttribute(node, "RotorConeAtten", "value");
            RearRotorConeFrontAngle = (ushort)Xml.GetChildIntAttribute(node, "RearRotorConeFrontAngle", "value");
            RearRotorConeRearAngle = (ushort)Xml.GetChildIntAttribute(node, "RearRotorConeRearAngle", "value");
            RearRotorConeAtten = (short)Xml.GetChildIntAttribute(node, "RearRotorConeAtten", "value");
            ExhaustConeFrontAngle = (ushort)Xml.GetChildIntAttribute(node, "ExhaustConeFrontAngle", "value");
            ExhaustConeRearAngle = (ushort)Xml.GetChildIntAttribute(node, "ExhaustConeRearAngle", "value");
            ExhaustConeAtten = (short)Xml.GetChildIntAttribute(node, "ExhaustConeAtten", "value");
            Filter1ThrottleResonanceCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "Filter1ThrottleResonanceCurve"));
            Filter2ThrottleResonanceCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "Filter2ThrottleResonanceCurve"));
            BankingResonanceCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankingResonanceCurve"));
            RotorVolumeStartupCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "RotorVolumeStartupCurve"));
            BladeVolumeStartupCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "BladeVolumeStartupCurve"));
            RotorPitchStartupCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "RotorPitchStartupCurve"));
            RearRotorVolumeStartupCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "RearRotorVolumeStartupCurve"));
            ExhaustStartupVolume = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustStartupVolume"));
            RotorGapStartupCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "RotorGapStartupCurve"));
            StartUpOneShot = XmlRel.GetHash(Xml.GetChildInnerText(node, "StartUpOneShot"));
            BladeConeUpAngle = (ushort)Xml.GetChildIntAttribute(node, "BladeConeUpAngle", "value");
            BladeConeDownAngle = (ushort)Xml.GetChildIntAttribute(node, "BladeConeDownAngle", "value");
            BladeConeAtten = (short)Xml.GetChildIntAttribute(node, "BladeConeAtten", "value");
            ThumpConeUpAngle = (ushort)Xml.GetChildIntAttribute(node, "ThumpConeUpAngle", "value");
            ThumpConeDownAngle = (ushort)Xml.GetChildIntAttribute(node, "ThumpConeDownAngle", "value");
            ThumpConeAtten = (short)Xml.GetChildIntAttribute(node, "ThumpConeAtten", "value");
            ScannerMake = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScannerMake"));
            ScannerModel = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScannerModel"));
            ScannerCategory = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScannerCategory"));
            ScannerVehicleSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScannerVehicleSettings"));
            RadioType = (byte)Xml.GetChildIntAttribute(node, "RadioType", "value");
            RadioGenre = (byte)Xml.GetChildIntAttribute(node, "RadioGenre", "value");
            DoorOpen = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorOpen"));
            DoorClose = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorClose"));
            DoorLimit = XmlRel.GetHash(Xml.GetChildInnerText(node, "DoorLimit"));
            DamageLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "DamageLoop"));
            RotorSpeedToTriggerSpeedCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "RotorSpeedToTriggerSpeedCurve"));
            RotorVolumePostSubmix = (short)Xml.GetChildIntAttribute(node, "RotorVolumePostSubmix", "value");
            EngineSynthDef = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSynthDef"));
            EngineSynthPreset = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSynthPreset"));
            ExhaustSynthDef = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSynthDef"));
            ExhaustSynthPreset = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSynthPreset"));
            EngineSubmixVoice = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineSubmixVoice"));
            ExhaustSubmixVoice = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustSubmixVoice"));
            RotorLowFreqLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "RotorLowFreqLoop"));
            ExhaustPitchStartupCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExhaustPitchStartupCurve"));
            VehicleCollisions = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleCollisions"));
            FireAudio = XmlRel.GetHash(Xml.GetChildInnerText(node, "FireAudio"));
            DistantLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "DistantLoop"));
            SecondaryDoorStartOpen = XmlRel.GetHash(Xml.GetChildInnerText(node, "SecondaryDoorStartOpen"));
            SecondaryDoorStartClose = XmlRel.GetHash(Xml.GetChildInnerText(node, "SecondaryDoorStartClose"));
            SecondaryDoorClose = XmlRel.GetHash(Xml.GetChildInnerText(node, "SecondaryDoorClose"));
            SecondaryDoorLimit = XmlRel.GetHash(Xml.GetChildInnerText(node, "SecondaryDoorLimit"));
            SuspensionUp = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuspensionUp"));
            SuspensionDown = XmlRel.GetHash(Xml.GetChildInnerText(node, "SuspensionDown"));
            MinSuspCompThresh = Xml.GetChildFloatAttribute(node, "MinSuspCompThresh", "value");
            MaxSuspCompThresh = Xml.GetChildFloatAttribute(node, "MaxSuspCompThresh", "value");
            DamageOneShots = XmlRel.GetHash(Xml.GetChildInnerText(node, "DamageOneShots"));
            DamageWarning = XmlRel.GetHash(Xml.GetChildInnerText(node, "DamageWarning"));
            TailBreak = XmlRel.GetHash(Xml.GetChildInnerText(node, "TailBreak"));
            RotorBreak = XmlRel.GetHash(Xml.GetChildInnerText(node, "RotorBreak"));
            RearRotorBreak = XmlRel.GetHash(Xml.GetChildInnerText(node, "RearRotorBreak"));
            CableDeploy = XmlRel.GetHash(Xml.GetChildInnerText(node, "CableDeploy"));
            HardScrape = XmlRel.GetHash(Xml.GetChildInnerText(node, "HardScrape"));
            EngineCooling = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineCooling"));
            AltitudeWarning = XmlRel.GetHash(Xml.GetChildInnerText(node, "AltitudeWarning"));
            HealthToDamageVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "HealthToDamageVolumeCurve"));
            HealthBelow600ToDamageVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "HealthBelow600ToDamageVolumeCurve"));
            DamageBelow600Loop = XmlRel.GetHash(Xml.GetChildInnerText(node, "DamageBelow600Loop"));
            AircraftWarningSeriousDamageThresh = Xml.GetChildFloatAttribute(node, "AircraftWarningSeriousDamageThresh", "value");
            AircraftWarningCriticalDamageThresh = Xml.GetChildFloatAttribute(node, "AircraftWarningCriticalDamageThresh", "value");
            AircraftWarningMaxSpeed = Xml.GetChildFloatAttribute(node, "AircraftWarningMaxSpeed", "value");
            SimpleSoundForLoading = XmlRel.GetHash(Xml.GetChildInnerText(node, "SimpleSoundForLoading"));
            SlowMoRotorLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoRotorLoop"));
            SlowMoRotorLowFreqLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoRotorLowFreqLoop"));

            if (Version >= 1)
            {
                VehicleRainSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleRainSound"));
                VehicleRainSoundInterior = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleRainSoundInterior"));
                StartUpFailOneShot = XmlRel.GetHash(Xml.GetChildInnerText(node, "StartUpFailOneShot"));
            }
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { BankAngleVolumeCurve, BankThrottleVolumeCurve, BankThrottlePitchCurve, RotorThrottleVolumeCurve, RotorThrottlePitchCurve, RotorThrottleGapCurve,
                RearRotorThrottleVolumeCurve, ExhaustThrottleVolumeCurve, ExhaustThrottlePitchCurve, Filter1ThrottleResonanceCurve, Filter2ThrottleResonanceCurve, BankingResonanceCurve,
                RotorVolumeStartupCurve, BladeVolumeStartupCurve, RotorPitchStartupCurve, RearRotorVolumeStartupCurve, ExhaustStartupVolume, RotorGapStartupCurve,
                RotorSpeedToTriggerSpeedCurve, ExhaustPitchStartupCurve, HealthToDamageVolumeCurve, HealthBelow600ToDamageVolumeCurve };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { RotorLoop, RearRotorLoop, ExhaustLoop, BankingLoop, CabinToneLoop, StartUpOneShot, ScannerMake, ScannerModel, ScannerCategory,
                DoorOpen, DoorClose, DoorLimit, DamageLoop, EngineSubmixVoice, ExhaustSubmixVoice, RotorLowFreqLoop, FireAudio, DistantLoop, SecondaryDoorStartOpen, SecondaryDoorStartClose, SecondaryDoorClose, SecondaryDoorLimit, 
                SuspensionUp, SuspensionDown, DamageOneShots, DamageWarning, TailBreak, RotorBreak, RearRotorBreak, CableDeploy,
                HardScrape, EngineCooling, AltitudeWarning, DamageBelow600Loop, SimpleSoundForLoading, SlowMoRotorLoop, SlowMoRotorLowFreqLoop, VehicleRainSound, VehicleRainSoundInterior, StartUpFailOneShot };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { ScannerVehicleSettings, VehicleCollisions };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151TrailerAudioSettings : Dat151RelData
    {
        public MetaHash BumpSound { get; set; }
        public byte ClatterType { get; set; }
        public byte padding00 { get; set; }
        public short padding01 { get; set; }
        public MetaHash LinkStressSound { get; set; }
        public MetaHash ModelCollisionSettings { get; set; }
        public MetaHash FireAudio { get; set; }
        public int TrailerBumpVolumeBoost { get; set; }
        public float ClatterSensitivityScalar { get; set; }
        public int ClatterVolumeBoost { get; set; }
        public float ChassisStressSensitivityScalar { get; set; }
        public int ChassisStressVolumeBoost { get; set; }
        public int LinkStressVolumeBoost { get; set; }
        public float LinkStressSensitivityScalar { get; set; }

        public Dat151TrailerAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.TrailerAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151TrailerAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            BumpSound = br.ReadUInt32();
            ClatterType = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadInt16();
            LinkStressSound = br.ReadUInt32();
            ModelCollisionSettings = br.ReadUInt32();
            FireAudio = br.ReadUInt32();
            TrailerBumpVolumeBoost = br.ReadInt32();
            ClatterSensitivityScalar = br.ReadSingle();
            ClatterVolumeBoost = br.ReadInt32();
            ChassisStressSensitivityScalar = br.ReadSingle();
            ChassisStressVolumeBoost = br.ReadInt32();
            LinkStressVolumeBoost = br.ReadInt32();
            LinkStressSensitivityScalar = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(BumpSound);
            bw.Write(ClatterType);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(LinkStressSound);
            bw.Write(ModelCollisionSettings);
            bw.Write(FireAudio);
            bw.Write(TrailerBumpVolumeBoost);
            bw.Write(ClatterSensitivityScalar);
            bw.Write(ClatterVolumeBoost);
            bw.Write(ChassisStressSensitivityScalar);
            bw.Write(ChassisStressVolumeBoost);
            bw.Write(LinkStressVolumeBoost);
            bw.Write(LinkStressSensitivityScalar);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "BumpSound", RelXml.HashString(BumpSound));
            RelXml.ValueTag(sb, indent, "ClatterType", ClatterType.ToString());
            RelXml.StringTag(sb, indent, "LinkStressSound", RelXml.HashString(LinkStressSound));
            RelXml.StringTag(sb, indent, "ModelCollisionSettings", RelXml.HashString(ModelCollisionSettings));
            RelXml.StringTag(sb, indent, "FireAudio", RelXml.HashString(FireAudio));
            RelXml.ValueTag(sb, indent, "TrailerBumpVolumeBoost", TrailerBumpVolumeBoost.ToString());
            RelXml.ValueTag(sb, indent, "ClatterSensitivityScalar", FloatUtil.ToString(ClatterSensitivityScalar));
            RelXml.ValueTag(sb, indent, "ClatterVolumeBoost", ClatterVolumeBoost.ToString());
            RelXml.ValueTag(sb, indent, "ChassisStressSensitivityScalar", FloatUtil.ToString(ChassisStressSensitivityScalar));
            RelXml.ValueTag(sb, indent, "ChassisStressVolumeBoost", ChassisStressVolumeBoost.ToString());
            RelXml.ValueTag(sb, indent, "LinkStressVolumeBoost", LinkStressVolumeBoost.ToString());
            RelXml.ValueTag(sb, indent, "LinkStressSensitivityScalar", FloatUtil.ToString(LinkStressSensitivityScalar));
        }
        public override void ReadXml(XmlNode node)
        {
            BumpSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BumpSound"));
            ClatterType = (byte)Xml.GetChildIntAttribute(node, "ClatterType", "value");
            LinkStressSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "LinkStressSound"));
            ModelCollisionSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "ModelCollisionSettings"));
            FireAudio = XmlRel.GetHash(Xml.GetChildInnerText(node, "FireAudio"));
            TrailerBumpVolumeBoost = Xml.GetChildIntAttribute(node, "TrailerBumpVolumeBoost", "value");
            ClatterSensitivityScalar = Xml.GetChildFloatAttribute(node, "ClatterSensitivityScalar", "value");
            ClatterVolumeBoost = Xml.GetChildIntAttribute(node, "ClatterVolumeBoost", "value");
            ChassisStressSensitivityScalar = Xml.GetChildFloatAttribute(node, "ChassisStressSensitivityScalar", "value");
            ChassisStressVolumeBoost = Xml.GetChildIntAttribute(node, "ChassisStressVolumeBoost", "value");
            LinkStressVolumeBoost = Xml.GetChildIntAttribute(node, "LinkStressVolumeBoost", "value");
            LinkStressSensitivityScalar = Xml.GetChildFloatAttribute(node, "LinkStressSensitivityScalar", "value");
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { BumpSound, LinkStressSound, FireAudio  };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { ModelCollisionSettings };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151TrainAudioSettings : Dat151RelData
    {
        public MetaHash DriveTone { get; set; }
        public MetaHash DriveToneSynth { get; set; }
        public MetaHash IdleLoop { get; set; }
        public MetaHash Brakes { get; set; }
        public MetaHash BigBrakeRelease { get; set; }
        public MetaHash BrakeRelease { get; set; }
        public MetaHash WheelDry { get; set; }
        public MetaHash AirHornOneShot { get; set; }
        public MetaHash BellLoopCrossing { get; set; }
        public MetaHash BellLoopEngine { get; set; }
        public MetaHash AmbientCarriage { get; set; }
        public MetaHash AmbientRumble { get; set; }
        public MetaHash AmbientGrind { get; set; }
        public MetaHash AmbientSqueal { get; set; }
        public MetaHash CarriagePitchCurve { get; set; }
        public MetaHash CarriageVolumeCurve { get; set; }
        public MetaHash DriveTonePitchCurve { get; set; }
        public MetaHash DriveToneVolumeCurve { get; set; }
        public MetaHash DriveToneSynthPitchCurve { get; set; }
        public MetaHash DriveToneSynthVolumeCurve { get; set; }
        public MetaHash GrindPitchCurve { get; set; }
        public MetaHash GrindVolumeCurve { get; set; }
        public MetaHash TrainIdlePitchCurve { get; set; }
        public MetaHash TrainIdleVolumeCurve { get; set; }
        public MetaHash SquealPitchCurve { get; set; }
        public MetaHash SquealVolumeCurve { get; set; }
        public MetaHash ScrapeSpeedVolumeCurve { get; set; }
        public MetaHash WheelVolumeCurve { get; set; }
        public MetaHash WheelDelayCurve { get; set; }
        public MetaHash RumbleVolumeCurve { get; set; }
        public MetaHash BrakeVelocityPitchCurve { get; set; }
        public MetaHash BrakeVelocityVolumeCurve { get; set; }
        public MetaHash BrakeAccelerationPitchCurve { get; set; }
        public MetaHash BrakeAccelerationVolumeCurve { get; set; }
        public MetaHash TrainApproachTrackRumble { get; set; }
        public MetaHash TrackRumbleDistanceToIntensity { get; set; }
        public MetaHash TrainDistanceToRollOffScale { get; set; }
        public MetaHash VehicleCollisions { get; set; }
        public float ShockwaveIntensityScale { get; set; }
        public float ShockwaveRadiusScale { get; set; }
        public int Version { get; set; }

        public Dat151TrainAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.TrainAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151TrainAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            DriveTone = br.ReadUInt32();
            DriveToneSynth = br.ReadUInt32();
            IdleLoop = br.ReadUInt32();
            Brakes = br.ReadUInt32();
            BigBrakeRelease = br.ReadUInt32();
            BrakeRelease = br.ReadUInt32();
            WheelDry = br.ReadUInt32();
            AirHornOneShot = br.ReadUInt32();
            BellLoopCrossing = br.ReadUInt32();
            BellLoopEngine = br.ReadUInt32();
            AmbientCarriage = br.ReadUInt32();
            AmbientRumble = br.ReadUInt32();
            AmbientGrind = br.ReadUInt32();
            AmbientSqueal = br.ReadUInt32();
            CarriagePitchCurve = br.ReadUInt32();
            CarriageVolumeCurve = br.ReadUInt32();
            DriveTonePitchCurve = br.ReadUInt32();
            DriveToneVolumeCurve = br.ReadUInt32();
            DriveToneSynthPitchCurve = br.ReadUInt32();
            DriveToneSynthVolumeCurve = br.ReadUInt32();
            GrindPitchCurve = br.ReadUInt32();
            GrindVolumeCurve = br.ReadUInt32();
            TrainIdlePitchCurve = br.ReadUInt32();
            TrainIdleVolumeCurve = br.ReadUInt32();
            SquealPitchCurve = br.ReadUInt32();
            SquealVolumeCurve = br.ReadUInt32();
            ScrapeSpeedVolumeCurve = br.ReadUInt32();
            WheelVolumeCurve = br.ReadUInt32();
            WheelDelayCurve = br.ReadUInt32();
            RumbleVolumeCurve = br.ReadUInt32();
            BrakeVelocityPitchCurve = br.ReadUInt32();
            BrakeVelocityVolumeCurve = br.ReadUInt32();
            BrakeAccelerationPitchCurve = br.ReadUInt32();
            BrakeAccelerationVolumeCurve = br.ReadUInt32();
            TrainApproachTrackRumble = br.ReadUInt32();
            TrackRumbleDistanceToIntensity = br.ReadUInt32();
            TrainDistanceToRollOffScale = br.ReadUInt32();
            VehicleCollisions = br.ReadUInt32();
            Version = 0;

            var bytesleft = br.BaseStream.Length - br.BaseStream.Position;
            switch(bytesleft)
            {
                case 8:
                    Version = 1;
                    ShockwaveIntensityScale = br.ReadSingle();
                    if (bytesleft >= 4)
                    {
                        Version = 2;
                        ShockwaveRadiusScale = br.ReadSingle();
                    }
                    break;
                default:
                    break;
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(DriveTone);
            bw.Write(DriveToneSynth);
            bw.Write(IdleLoop);
            bw.Write(Brakes);
            bw.Write(BigBrakeRelease);
            bw.Write(BrakeRelease);
            bw.Write(WheelDry);
            bw.Write(AirHornOneShot);
            bw.Write(BellLoopCrossing);
            bw.Write(BellLoopEngine);
            bw.Write(AmbientCarriage);
            bw.Write(AmbientRumble);
            bw.Write(AmbientGrind);
            bw.Write(AmbientSqueal);
            bw.Write(CarriagePitchCurve);
            bw.Write(CarriageVolumeCurve);
            bw.Write(DriveTonePitchCurve);
            bw.Write(DriveToneVolumeCurve);
            bw.Write(DriveToneSynthPitchCurve);
            bw.Write(DriveToneSynthVolumeCurve);
            bw.Write(GrindPitchCurve);
            bw.Write(GrindVolumeCurve);
            bw.Write(TrainIdlePitchCurve);
            bw.Write(TrainIdleVolumeCurve);
            bw.Write(SquealPitchCurve);
            bw.Write(SquealVolumeCurve);
            bw.Write(ScrapeSpeedVolumeCurve);
            bw.Write(WheelVolumeCurve);
            bw.Write(WheelDelayCurve);
            bw.Write(RumbleVolumeCurve);
            bw.Write(BrakeVelocityPitchCurve);
            bw.Write(BrakeVelocityVolumeCurve);
            bw.Write(BrakeAccelerationPitchCurve);
            bw.Write(BrakeAccelerationVolumeCurve);
            bw.Write(TrainApproachTrackRumble);
            bw.Write(TrackRumbleDistanceToIntensity);
            bw.Write(TrainDistanceToRollOffScale);
            bw.Write(VehicleCollisions);

            if (Version >= 1)
            {
                bw.Write(ShockwaveIntensityScale);
            }
            if (Version >= 2)
            {
                bw.Write(ShockwaveRadiusScale);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Version", Version.ToString());
            RelXml.StringTag(sb, indent, "DriveTone", RelXml.HashString(DriveTone));
            RelXml.StringTag(sb, indent, "DriveToneSynth", RelXml.HashString(DriveToneSynth));
            RelXml.StringTag(sb, indent, "IdleLoop", RelXml.HashString(IdleLoop));
            RelXml.StringTag(sb, indent, "Brakes", RelXml.HashString(Brakes));
            RelXml.StringTag(sb, indent, "BigBrakeRelease", RelXml.HashString(BigBrakeRelease));
            RelXml.StringTag(sb, indent, "BrakeRelease", RelXml.HashString(BrakeRelease));
            RelXml.StringTag(sb, indent, "WheelDry", RelXml.HashString(WheelDry));
            RelXml.StringTag(sb, indent, "AirHornOneShot", RelXml.HashString(AirHornOneShot));
            RelXml.StringTag(sb, indent, "BellLoopCrossing", RelXml.HashString(BellLoopCrossing));
            RelXml.StringTag(sb, indent, "BellLoopEngine", RelXml.HashString(BellLoopEngine));
            RelXml.StringTag(sb, indent, "AmbientCarriage", RelXml.HashString(AmbientCarriage));
            RelXml.StringTag(sb, indent, "AmbientRumble", RelXml.HashString(AmbientRumble));
            RelXml.StringTag(sb, indent, "AmbientGrind", RelXml.HashString(AmbientGrind));
            RelXml.StringTag(sb, indent, "AmbientSqueal", RelXml.HashString(AmbientSqueal));
            RelXml.StringTag(sb, indent, "CarriagePitchCurve", RelXml.HashString(CarriagePitchCurve));
            RelXml.StringTag(sb, indent, "CarriageVolumeCurve", RelXml.HashString(CarriageVolumeCurve));
            RelXml.StringTag(sb, indent, "DriveTonePitchCurve", RelXml.HashString(DriveTonePitchCurve));
            RelXml.StringTag(sb, indent, "DriveToneVolumeCurve", RelXml.HashString(DriveToneVolumeCurve));
            RelXml.StringTag(sb, indent, "DriveToneSynthPitchCurve", RelXml.HashString(DriveToneSynthPitchCurve));
            RelXml.StringTag(sb, indent, "DriveToneSynthVolumeCurve", RelXml.HashString(DriveToneSynthVolumeCurve));
            RelXml.StringTag(sb, indent, "GrindPitchCurve", RelXml.HashString(GrindPitchCurve));
            RelXml.StringTag(sb, indent, "GrindVolumeCurve", RelXml.HashString(GrindVolumeCurve));
            RelXml.StringTag(sb, indent, "TrainIdlePitchCurve", RelXml.HashString(TrainIdlePitchCurve));
            RelXml.StringTag(sb, indent, "TrainIdleVolumeCurve", RelXml.HashString(TrainIdleVolumeCurve));
            RelXml.StringTag(sb, indent, "SquealPitchCurve", RelXml.HashString(SquealPitchCurve));
            RelXml.StringTag(sb, indent, "SquealVolumeCurve", RelXml.HashString(SquealVolumeCurve));
            RelXml.StringTag(sb, indent, "ScrapeSpeedVolumeCurve", RelXml.HashString(ScrapeSpeedVolumeCurve));
            RelXml.StringTag(sb, indent, "WheelVolumeCurve", RelXml.HashString(WheelVolumeCurve));
            RelXml.StringTag(sb, indent, "WheelDelayCurve", RelXml.HashString(WheelDelayCurve));
            RelXml.StringTag(sb, indent, "RumbleVolumeCurve", RelXml.HashString(RumbleVolumeCurve));
            RelXml.StringTag(sb, indent, "BrakeVelocityPitchCurve", RelXml.HashString(BrakeVelocityPitchCurve));
            RelXml.StringTag(sb, indent, "BrakeVelocityVolumeCurve", RelXml.HashString(BrakeVelocityVolumeCurve));
            RelXml.StringTag(sb, indent, "BrakeAccelerationPitchCurve", RelXml.HashString(BrakeAccelerationPitchCurve));
            RelXml.StringTag(sb, indent, "BrakeAccelerationVolumeCurve", RelXml.HashString(BrakeAccelerationVolumeCurve));
            RelXml.StringTag(sb, indent, "TrainApproachTrackRumble", RelXml.HashString(TrainApproachTrackRumble));
            RelXml.StringTag(sb, indent, "TrackRumbleDistanceToIntensity", RelXml.HashString(TrackRumbleDistanceToIntensity));
            RelXml.StringTag(sb, indent, "TrainDistanceToRollOffScale", RelXml.HashString(TrainDistanceToRollOffScale));
            RelXml.StringTag(sb, indent, "VehicleCollisions", RelXml.HashString(VehicleCollisions));

            if (Version >= 1)
            {
                RelXml.ValueTag(sb, indent, "ShockwaveIntensityScale", FloatUtil.ToString(ShockwaveIntensityScale));
            }
            if (Version >= 2)
            {
                RelXml.ValueTag(sb, indent, "ShockwaveRadiusScale", FloatUtil.ToString(ShockwaveRadiusScale));
            }
        }
        public override void ReadXml(XmlNode node)
        {
            Version = Xml.GetChildIntAttribute(node, "Version", "value");
            DriveTone = XmlRel.GetHash(Xml.GetChildInnerText(node, "DriveTone"));
            DriveToneSynth = XmlRel.GetHash(Xml.GetChildInnerText(node, "DriveToneSynth"));
            IdleLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "IdleLoop"));
            Brakes = XmlRel.GetHash(Xml.GetChildInnerText(node, "Brakes"));
            BigBrakeRelease = XmlRel.GetHash(Xml.GetChildInnerText(node, "BigBrakeRelease"));
            BrakeRelease = XmlRel.GetHash(Xml.GetChildInnerText(node, "BrakeRelease"));
            WheelDry = XmlRel.GetHash(Xml.GetChildInnerText(node, "WheelDry"));
            AirHornOneShot = XmlRel.GetHash(Xml.GetChildInnerText(node, "AirHornOneShot"));
            BellLoopCrossing = XmlRel.GetHash(Xml.GetChildInnerText(node, "BellLoopCrossing"));
            BellLoopEngine = XmlRel.GetHash(Xml.GetChildInnerText(node, "BellLoopEngine"));
            AmbientCarriage = XmlRel.GetHash(Xml.GetChildInnerText(node, "AmbientCarriage"));
            AmbientRumble = XmlRel.GetHash(Xml.GetChildInnerText(node, "AmbientRumble"));
            AmbientGrind = XmlRel.GetHash(Xml.GetChildInnerText(node, "AmbientGrind"));
            AmbientSqueal = XmlRel.GetHash(Xml.GetChildInnerText(node, "AmbientSqueal"));
            CarriagePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "CarriagePitchCurve"));
            CarriageVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "CarriageVolumeCurve"));
            DriveTonePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DriveTonePitchCurve"));
            DriveToneVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DriveToneVolumeCurve"));
            DriveToneSynthPitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DriveToneSynthPitchCurve"));
            DriveToneSynthVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DriveToneSynthVolumeCurve"));
            GrindPitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "GrindPitchCurve"));
            GrindVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "GrindVolumeCurve"));
            TrainIdlePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "TrainIdlePitchCurve"));
            TrainIdleVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "TrainIdleVolumeCurve"));
            SquealPitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "SquealPitchCurve"));
            SquealVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "SquealVolumeCurve"));
            ScrapeSpeedVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScrapeSpeedVolumeCurve"));
            WheelVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "WheelVolumeCurve"));
            WheelDelayCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "WheelDelayCurve"));
            RumbleVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "RumbleVolumeCurve"));
            BrakeVelocityPitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "BrakeVelocityPitchCurve"));
            BrakeVelocityVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "BrakeVelocityVolumeCurve"));
            BrakeAccelerationPitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "BrakeAccelerationPitchCurve"));
            BrakeAccelerationVolumeCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "BrakeAccelerationVolumeCurve"));
            TrainApproachTrackRumble = XmlRel.GetHash(Xml.GetChildInnerText(node, "TrainApproachTrackRumble"));
            TrackRumbleDistanceToIntensity = XmlRel.GetHash(Xml.GetChildInnerText(node, "TrackRumbleDistanceToIntensity"));
            TrainDistanceToRollOffScale = XmlRel.GetHash(Xml.GetChildInnerText(node, "TrainDistanceToRollOffScale"));
            VehicleCollisions = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleCollisions"));

            if (Version >= 1)
            {
                ShockwaveIntensityScale = Xml.GetChildFloatAttribute(node, "ShockwaveIntensityScale", "value");
            }

            if (Version >= 2)
            {
                ShockwaveRadiusScale = Xml.GetChildFloatAttribute(node, "ShockwaveRadiusScale", "value");
            }
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { CarriagePitchCurve, CarriageVolumeCurve, DriveTonePitchCurve, DriveToneVolumeCurve, DriveToneSynthPitchCurve, DriveToneSynthVolumeCurve,
                GrindPitchCurve, GrindVolumeCurve, TrainIdlePitchCurve, TrainIdleVolumeCurve, SquealPitchCurve, SquealVolumeCurve, ScrapeSpeedVolumeCurve, WheelVolumeCurve, WheelDelayCurve,
                RumbleVolumeCurve, BrakeVelocityPitchCurve, BrakeVelocityVolumeCurve, BrakeAccelerationPitchCurve, BrakeAccelerationVolumeCurve, TrackRumbleDistanceToIntensity, TrainDistanceToRollOffScale };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { DriveTone, IdleLoop, Brakes, BigBrakeRelease, BrakeRelease, WheelDry, AirHornOneShot, BellLoopCrossing, BellLoopEngine, AmbientCarriage, AmbientRumble, AmbientGrind, AmbientSqueal, TrainApproachTrackRumble };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { VehicleCollisions };
        }
    }

    [TC(typeof(EXP))]
    public class Dat151AnimalParamsItem : IMetaXmlItem
    {
        public string ContextName { get; set; }
        public float VolumeOffset { get; set; }
        public float RollOff { get; set; }
        public int Priority { get; set; }
        public float Probability { get; set; }
        public int MinTimeBetween { get; set; }
        public int MaxTimeBetween { get; set; }
        public float MaxDistance { get; set; }
        public byte ContextBits { get; set; }

        public override string ToString()
        {
            return ContextName;
        }

        public Dat151AnimalParamsItem()
        { }
        public Dat151AnimalParamsItem(BinaryReader br)
        {
            var data = br.ReadBytes(32);
            ContextName = Encoding.ASCII.GetString(data).Replace("\0", "");
            VolumeOffset = br.ReadSingle();
            RollOff = br.ReadSingle();
            Priority = br.ReadInt32();
            Probability = br.ReadSingle();
            MinTimeBetween = br.ReadInt32();
            MaxTimeBetween = br.ReadInt32();
            MaxDistance = br.ReadSingle();
            ContextBits = br.ReadByte();
        }
        public void Write(BinaryWriter bw)
        {
            var data = new byte[32];
            int len = Math.Min(ContextName?.Length ?? 0, 32);
            if (len > 0)
            {
                Encoding.ASCII.GetBytes(ContextName, 0, len, data, 0);
            }
            bw.Write(data);
            bw.Write(VolumeOffset);
            bw.Write(RollOff);
            bw.Write(Priority);
            bw.Write(Probability);
            bw.Write(MinTimeBetween);
            bw.Write(MaxTimeBetween);
            bw.Write(MaxDistance);
            bw.Write(ContextBits);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "ContextName", ContextName);
            RelXml.ValueTag(sb, indent, "VolumeOffset", FloatUtil.ToString(VolumeOffset));
            RelXml.ValueTag(sb, indent, "RollOff", FloatUtil.ToString(RollOff));
            RelXml.ValueTag(sb, indent, "Priority", Priority.ToString());
            RelXml.ValueTag(sb, indent, "Probability", FloatUtil.ToString(Probability));
            RelXml.ValueTag(sb, indent, "MinTimeBetween", MinTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "MaxTimeBetween", MaxTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "MaxDistance", FloatUtil.ToString(MaxDistance));
            RelXml.ValueTag(sb, indent, "ContextBits", ContextBits.ToString());
        }
        public void ReadXml(XmlNode node)
        {
            ContextName = Xml.GetChildInnerText(node, "ContextName");
            VolumeOffset = Xml.GetChildFloatAttribute(node, "VolumeOffset", "value");
            RollOff = Xml.GetChildFloatAttribute(node, "RollOff", "value");
            Priority = Xml.GetChildIntAttribute(node, "Priority", "value");
            Probability = Xml.GetChildFloatAttribute(node, "Probability", "value");
            MinTimeBetween = Xml.GetChildIntAttribute(node, "MinTimeBetween", "value");
            MaxTimeBetween = Xml.GetChildIntAttribute(node, "MaxTimeBetween", "value");
            MaxDistance = Xml.GetChildFloatAttribute(node, "MaxDistance", "value");
            ContextBits = (byte)Xml.GetChildUIntAttribute(node, "ContextBits", "value");
        }
    }

    [TC(typeof(EXP))]
    public class Dat151AnimalParams : Dat151RelData
    {
        public int BasePriority { get; set; }
        public float MinFarDistance { get; set; }
        public float MaxDistanceToBankLoad { get; set; }
        public int MaxSoundInstances { get; set; }
        public byte AnimalType { get; set; }
        public MetaHash ScrapeVolCurve { get; set; }
        public MetaHash ScrapePitchCurve { get; set; }
        public MetaHash BigVehicleImpact { get; set; }
        public float VehicleSpeedForBigImpact { get; set; }
        public MetaHash RunOverSound { get; set; }
        public byte ContextsCount { get; set; }
        public Dat151AnimalParamsItem[] Contexts { get; set; }

        public Dat151AnimalParams(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.AnimalParams;
            TypeID = (byte)Type;
        }
        public Dat151AnimalParams(RelData d, BinaryReader br) : base(d, br)
        {

            BasePriority = br.ReadInt32();
            MinFarDistance = br.ReadSingle();
            MaxDistanceToBankLoad = br.ReadSingle();
            MaxSoundInstances = br.ReadInt32();
            AnimalType = br.ReadByte();
            ScrapeVolCurve = br.ReadUInt32();
            ScrapePitchCurve = br.ReadUInt32();
            BigVehicleImpact = br.ReadUInt32();
            VehicleSpeedForBigImpact = br.ReadSingle();
            RunOverSound = br.ReadUInt32();

            ContextsCount = br.ReadByte();
            var items = new Dat151AnimalParamsItem[ContextsCount];
            for (int i = 0; i < ContextsCount; i++)
            {
                items[i] = new Dat151AnimalParamsItem(br);
            }
            Contexts = items;
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(BasePriority);
            bw.Write(MinFarDistance);
            bw.Write(MaxDistanceToBankLoad);
            bw.Write(MaxSoundInstances);
            bw.Write(AnimalType);
            bw.Write(ScrapeVolCurve);
            bw.Write(ScrapePitchCurve);
            bw.Write(BigVehicleImpact);
            bw.Write(VehicleSpeedForBigImpact);
            bw.Write(RunOverSound);

            bw.Write(ContextsCount);
            for (int i = 0; i < ContextsCount; i++)
            {
                Contexts[i].Write(bw);
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "BasePriority", BasePriority.ToString());
            RelXml.ValueTag(sb, indent, "MinFarDistance", FloatUtil.ToString(MinFarDistance));
            RelXml.ValueTag(sb, indent, "MaxDistanceToBankLoad", FloatUtil.ToString(MaxDistanceToBankLoad));
            RelXml.ValueTag(sb, indent, "MaxSoundInstances", MaxSoundInstances.ToString());
            RelXml.ValueTag(sb, indent, "AnimalType", AnimalType.ToString());
            RelXml.StringTag(sb, indent, "ScrapeVolCurve", RelXml.HashString(ScrapeVolCurve));
            RelXml.StringTag(sb, indent, "ScrapePitchCurve", RelXml.HashString(ScrapePitchCurve));
            RelXml.StringTag(sb, indent, "BigVehicleImpact", RelXml.HashString(BigVehicleImpact));
            RelXml.ValueTag(sb, indent, "VehicleSpeedForBigImpact", FloatUtil.ToString(VehicleSpeedForBigImpact));
            RelXml.StringTag(sb, indent, "RunOverSound", RelXml.HashString(RunOverSound));
            RelXml.WriteItemArray(sb, Contexts, indent, "Contexts");
        }
        public override void ReadXml(XmlNode node)
        {
            BasePriority = Xml.GetChildIntAttribute(node, "BasePriority", "value");
            MinFarDistance = Xml.GetChildFloatAttribute(node, "MinFarDistance", "value");
            MaxDistanceToBankLoad = Xml.GetChildFloatAttribute(node, "MaxDistanceToBankLoad", "value");
            MaxSoundInstances = Xml.GetChildIntAttribute(node, "MaxSoundInstances", "value");
            AnimalType = (byte)Xml.GetChildUIntAttribute(node, "AnimalType", "value");
            ScrapeVolCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScrapeVolCurve"));
            ScrapePitchCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScrapePitchCurve"));
            BigVehicleImpact = XmlRel.GetHash(Xml.GetChildInnerText(node, "BigVehicleImpact"));
            VehicleSpeedForBigImpact = Xml.GetChildFloatAttribute(node, "VehicleSpeedForBigImpact", "value");
            RunOverSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RunOverSound"));
            Contexts = XmlRel.ReadItemArray<Dat151AnimalParamsItem>(node, "Contexts");
            ContextsCount = (byte)(Contexts?.Length ?? 0);
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { ScrapeVolCurve, ScrapePitchCurve };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { BigVehicleImpact, RunOverSound };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151SpeechParams : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public int OverrideContextSettings { get; set; }
        public uint PreloadTimeoutInMs { get; set; }
        public byte RequestedVolume { get; set; }
        public byte Audibility { get; set; }
        public short padding01 { get; set; }
        public int RepeatTime { get; set; }
        public int RepeatTimeOnSameVoice { get; set; }


        public Dat151SpeechParams(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.SpeechParams;
            TypeID = (byte)Type;
        }
        public Dat151SpeechParams(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            OverrideContextSettings = br.ReadInt32();
            PreloadTimeoutInMs = br.ReadUInt32();
            RequestedVolume = br.ReadByte();
            Audibility = br.ReadByte();
            padding01 = br.ReadInt16();
            RepeatTime = br.ReadInt32();
            RepeatTimeOnSameVoice = br.ReadInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(OverrideContextSettings);
            bw.Write(PreloadTimeoutInMs);
            bw.Write(RequestedVolume);
            bw.Write(Audibility);
            bw.Write(padding01);
            bw.Write(RepeatTime);
            bw.Write(RepeatTimeOnSameVoice);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "OverrideContextSettings", OverrideContextSettings.ToString());
            RelXml.ValueTag(sb, indent, "PreloadTimeoutInMs", PreloadTimeoutInMs.ToString());
            RelXml.ValueTag(sb, indent, "RequestedVolume", RequestedVolume.ToString());
            RelXml.ValueTag(sb, indent, "Audibility", Audibility.ToString());
            RelXml.ValueTag(sb, indent, "RepeatTime", RepeatTime.ToString());
            RelXml.ValueTag(sb, indent, "RepeatTimeOnSameVoice", RepeatTimeOnSameVoice.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            OverrideContextSettings = Xml.GetChildIntAttribute(node, "OverrideContextSettings", "value");
            PreloadTimeoutInMs = Xml.GetChildUIntAttribute(node, "PreloadTimeoutInMs", "value");
            RequestedVolume = (byte)Xml.GetChildUIntAttribute(node, "RequestedVolume", "value");
            Audibility = (byte)Xml.GetChildUIntAttribute(node, "Audibility", "value");
            RepeatTime = Xml.GetChildIntAttribute(node, "RepeatTime", "value");
            RepeatTimeOnSameVoice = Xml.GetChildIntAttribute(node, "RepeatTimeOnSameVoice", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151MeleeCombatSettings : Dat151RelData
    {
        public MetaHash SwipeSound { get; set; }
        public MetaHash GeneralHitSound { get; set; }
        public MetaHash PedHitSound { get; set; }
        public MetaHash PedResponseSound { get; set; }
        public MetaHash HeadTakeDown { get; set; }
        public MetaHash BodyTakeDown { get; set; }
        public MetaHash SmallAnimalHitSound { get; set; }
        public MetaHash SmallAnimalResponseSound { get; set; }
        public MetaHash BigAnimalHitSound { get; set; }
        public MetaHash BigAnimalResponseSound { get; set; }
        public MetaHash SlowMoPedHitSound { get; set; }
        public MetaHash SlowMoPedResponseSound { get; set; }
        public MetaHash SlowMoHeadTakeDown { get; set; }
        public MetaHash SlowMoBodyTakeDown { get; set; }
        public MetaHash SlowMoSmallAnimalHitSound { get; set; }
        public MetaHash SlowMoSmallAnimalResponseSound { get; set; }
        public MetaHash SlowMoBigAnimalHitSound { get; set; }
        public MetaHash SlowMoBigAnimalResponseSound { get; set; }

        public Dat151MeleeCombatSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.MeleeCombatSettings;
            TypeID = (byte)Type;
        }
        public Dat151MeleeCombatSettings(RelData d, BinaryReader br) : base(d, br)
        {
            SwipeSound = br.ReadUInt32();
            GeneralHitSound = br.ReadUInt32();
            PedHitSound = br.ReadUInt32();
            PedResponseSound = br.ReadUInt32();
            HeadTakeDown = br.ReadUInt32();
            BodyTakeDown = br.ReadUInt32();
            SmallAnimalHitSound = br.ReadUInt32();
            SmallAnimalResponseSound = br.ReadUInt32();
            BigAnimalHitSound = br.ReadUInt32();
            BigAnimalResponseSound = br.ReadUInt32();
            SlowMoPedHitSound = br.ReadUInt32();
            SlowMoPedResponseSound = br.ReadUInt32();
            SlowMoHeadTakeDown = br.ReadUInt32();
            SlowMoBodyTakeDown = br.ReadUInt32();
            SlowMoSmallAnimalHitSound = br.ReadUInt32();
            SlowMoSmallAnimalResponseSound = br.ReadUInt32();
            SlowMoBigAnimalHitSound = br.ReadUInt32();
            SlowMoBigAnimalResponseSound = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(SwipeSound);
            bw.Write(GeneralHitSound);
            bw.Write(PedHitSound);
            bw.Write(PedResponseSound);
            bw.Write(HeadTakeDown);
            bw.Write(BodyTakeDown);
            bw.Write(SmallAnimalHitSound);
            bw.Write(SmallAnimalResponseSound);
            bw.Write(BigAnimalHitSound);
            bw.Write(BigAnimalResponseSound);
            bw.Write(SlowMoPedHitSound);
            bw.Write(SlowMoPedResponseSound);
            bw.Write(SlowMoHeadTakeDown);
            bw.Write(SlowMoBodyTakeDown);
            bw.Write(SlowMoSmallAnimalHitSound);
            bw.Write(SlowMoSmallAnimalResponseSound);
            bw.Write(SlowMoBigAnimalHitSound);
            bw.Write(SlowMoBigAnimalResponseSound);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "SwipeSound", RelXml.HashString(SwipeSound));
            RelXml.StringTag(sb, indent, "GeneralHitSound", RelXml.HashString(GeneralHitSound));
            RelXml.StringTag(sb, indent, "PedHitSound", RelXml.HashString(PedHitSound));
            RelXml.StringTag(sb, indent, "PedResponseSound", RelXml.HashString(PedResponseSound));
            RelXml.StringTag(sb, indent, "HeadTakeDown", RelXml.HashString(HeadTakeDown));
            RelXml.StringTag(sb, indent, "BodyTakeDown", RelXml.HashString(BodyTakeDown));
            RelXml.StringTag(sb, indent, "SmallAnimalHitSound", RelXml.HashString(SmallAnimalHitSound));
            RelXml.StringTag(sb, indent, "SmallAnimalResponseSound", RelXml.HashString(SmallAnimalResponseSound));
            RelXml.StringTag(sb, indent, "BigAnimalHitSound", RelXml.HashString(BigAnimalHitSound));
            RelXml.StringTag(sb, indent, "BigAnimalResponseSound", RelXml.HashString(BigAnimalResponseSound));
            RelXml.StringTag(sb, indent, "SlowMoPedHitSound", RelXml.HashString(SlowMoPedHitSound));
            RelXml.StringTag(sb, indent, "SlowMoPedResponseSound", RelXml.HashString(SlowMoPedResponseSound));
            RelXml.StringTag(sb, indent, "SlowMoHeadTakeDown", RelXml.HashString(SlowMoHeadTakeDown));
            RelXml.StringTag(sb, indent, "SlowMoBodyTakeDown", RelXml.HashString(SlowMoBodyTakeDown));
            RelXml.StringTag(sb, indent, "SlowMoSmallAnimalHitSound", RelXml.HashString(SlowMoSmallAnimalHitSound));
            RelXml.StringTag(sb, indent, "SlowMoSmallAnimalResponseSound", RelXml.HashString(SlowMoSmallAnimalResponseSound));
            RelXml.StringTag(sb, indent, "SlowMoBigAnimalHitSound", RelXml.HashString(SlowMoBigAnimalHitSound));
            RelXml.StringTag(sb, indent, "SlowMoBigAnimalResponseSound", RelXml.HashString(SlowMoBigAnimalResponseSound));
        }
        public override void ReadXml(XmlNode node)
        {
            SwipeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SwipeSound"));
            GeneralHitSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "GeneralHitSound"));
            PedHitSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "PedHitSound"));
            PedResponseSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "PedResponseSound"));
            HeadTakeDown = XmlRel.GetHash(Xml.GetChildInnerText(node, "HeadTakeDown"));
            BodyTakeDown = XmlRel.GetHash(Xml.GetChildInnerText(node, "BodyTakeDown"));
            SmallAnimalHitSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SmallAnimalHitSound"));
            SmallAnimalResponseSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SmallAnimalResponseSound"));
            BigAnimalHitSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BigAnimalHitSound"));
            BigAnimalResponseSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BigAnimalResponseSound"));
            SlowMoPedHitSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoPedHitSound"));
            SlowMoPedResponseSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoPedResponseSound"));
            SlowMoHeadTakeDown = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoHeadTakeDown"));
            SlowMoBodyTakeDown = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoBodyTakeDown"));
            SlowMoSmallAnimalHitSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoSmallAnimalHitSound"));
            SlowMoSmallAnimalResponseSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoSmallAnimalResponseSound"));
            SlowMoBigAnimalHitSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoBigAnimalHitSound"));
            SlowMoBigAnimalResponseSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoBigAnimalResponseSound"));
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { SwipeSound, GeneralHitSound, PedHitSound, PedResponseSound, HeadTakeDown, BodyTakeDown, SmallAnimalHitSound, SmallAnimalResponseSound, BigAnimalHitSound, BigAnimalResponseSound, SlowMoPedHitSound, SlowMoPedResponseSound, SlowMoHeadTakeDown, SlowMoBodyTakeDown, SlowMoSmallAnimalHitSound, SlowMoSmallAnimalResponseSound, SlowMoBigAnimalHitSound, SlowMoBigAnimalResponseSound };
        }
    }

    [TC(typeof(EXP))]
    public class Dat151TriggeredSpeechContextBackupSpeechContext : IMetaXmlItem
    {
        public MetaHash SpeechContext { get; set; }
        public float Weight { get; set; }


        public Dat151TriggeredSpeechContextBackupSpeechContext()
        { }

        public Dat151TriggeredSpeechContextBackupSpeechContext(BinaryReader br)
        {
            SpeechContext = br.ReadUInt32();
            Weight = br.ReadSingle();
        }

        public void Write(BinaryWriter bw)
        {
            bw.Write(SpeechContext);
            bw.Write(Weight);
        }

        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "SpeechContext", RelXml.HashString(SpeechContext));
            RelXml.ValueTag(sb, indent, "Weight", FloatUtil.ToString(Weight));
        }

        public void ReadXml(XmlNode node)
        {
            SpeechContext = XmlRel.GetHash(Xml.GetChildInnerText(node, "SpeechContext"));
            Weight = Xml.GetChildFloatAttribute(node, "Weight", "value");
        }
        public override string ToString()
        {
            return SpeechContext.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151TriggeredSpeechContext : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public int TriggeredContextRepeatTime { get; set; }
        public int PrimaryRepeatTime { get; set; }
        public int PrimaryRepeatTimeOnSameVoice { get; set; }
        public int BackupRepeatTime { get; set; }
        public int BackupRepeatTimeOnSameVoice { get; set; }
        public MetaHash TimeCanNextUseTriggeredContext { get; set; }
        public MetaHash TimeCanNextPlayPrimary { get; set; }
        public MetaHash TimeCanNextPlayBackup { get; set; }
        public MetaHash PrimarySpeechContext { get; set; }
        public int BackupSpeechContextCount { get; set; }
        public Dat151TriggeredSpeechContextBackupSpeechContext[] BackupSpeechContexts { get; set; }


        public Dat151TriggeredSpeechContext(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.TriggeredSpeechContext;
            TypeID = (byte)Type;
        }
        public Dat151TriggeredSpeechContext(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            TriggeredContextRepeatTime = br.ReadInt32();
            PrimaryRepeatTime = br.ReadInt32();
            PrimaryRepeatTimeOnSameVoice = br.ReadInt32();
            BackupRepeatTime = br.ReadInt32();
            BackupRepeatTimeOnSameVoice = br.ReadInt32();
            TimeCanNextUseTriggeredContext = br.ReadUInt32();
            TimeCanNextPlayPrimary = br.ReadUInt32();
            TimeCanNextPlayBackup = br.ReadUInt32();
            PrimarySpeechContext = br.ReadUInt32();

            BackupSpeechContextCount = br.ReadInt32();
            BackupSpeechContexts = new Dat151TriggeredSpeechContextBackupSpeechContext[BackupSpeechContextCount];
            for (int i = 0; i < BackupSpeechContextCount; i++)
            {
                BackupSpeechContexts[i] = new Dat151TriggeredSpeechContextBackupSpeechContext(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(TriggeredContextRepeatTime);
            bw.Write(PrimaryRepeatTime);
            bw.Write(PrimaryRepeatTimeOnSameVoice);
            bw.Write(BackupRepeatTime);
            bw.Write(BackupRepeatTimeOnSameVoice);
            bw.Write(TimeCanNextUseTriggeredContext);
            bw.Write(TimeCanNextPlayPrimary);
            bw.Write(TimeCanNextPlayBackup);
            bw.Write(PrimarySpeechContext);

            bw.Write(BackupSpeechContextCount);
            for (int i = 0; i < BackupSpeechContextCount; i++)
            {
                BackupSpeechContexts[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "TriggeredContextRepeatTime", TriggeredContextRepeatTime.ToString());
            RelXml.ValueTag(sb, indent, "PrimaryRepeatTime", PrimaryRepeatTime.ToString());
            RelXml.ValueTag(sb, indent, "PrimaryRepeatTimeOnSameVoice", PrimaryRepeatTimeOnSameVoice.ToString());
            RelXml.ValueTag(sb, indent, "BackupRepeatTime", BackupRepeatTime.ToString());
            RelXml.ValueTag(sb, indent, "BackupRepeatTimeOnSameVoice", BackupRepeatTimeOnSameVoice.ToString());
            RelXml.StringTag(sb, indent, "TimeCanNextUseTriggeredContext", RelXml.HashString(TimeCanNextUseTriggeredContext));
            RelXml.StringTag(sb, indent, "TimeCanNextPlayPrimary", RelXml.HashString(TimeCanNextPlayPrimary));
            RelXml.StringTag(sb, indent, "TimeCanNextPlayBackup", RelXml.HashString(TimeCanNextPlayBackup));
            RelXml.StringTag(sb, indent, "PrimarySpeechContext", RelXml.HashString(PrimarySpeechContext));
            RelXml.WriteItemArray(sb, BackupSpeechContexts, indent, "BackupSpeechContexts");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            TriggeredContextRepeatTime = Xml.GetChildIntAttribute(node, "TriggeredContextRepeatTime", "value");
            PrimaryRepeatTime = Xml.GetChildIntAttribute(node, "PrimaryRepeatTime", "value");
            PrimaryRepeatTimeOnSameVoice = Xml.GetChildIntAttribute(node, "PrimaryRepeatTimeOnSameVoice", "value");
            BackupRepeatTime = Xml.GetChildIntAttribute(node, "BackupRepeatTime", "value");
            BackupRepeatTimeOnSameVoice = Xml.GetChildIntAttribute(node, "BackupRepeatTimeOnSameVoice", "value");
            TimeCanNextUseTriggeredContext = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimeCanNextUseTriggeredContext"));
            TimeCanNextPlayPrimary = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimeCanNextPlayPrimary"));
            TimeCanNextPlayBackup = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimeCanNextPlayBackup"));
            PrimarySpeechContext = XmlRel.GetHash(Xml.GetChildInnerText(node, "PrimarySpeechContext"));
            BackupSpeechContexts = XmlRel.ReadItemArray<Dat151TriggeredSpeechContextBackupSpeechContext>(node, "BackupSpeechContexts");
            BackupSpeechContextCount = (BackupSpeechContexts?.Length ?? 0);
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            list.Add(PrimarySpeechContext);
            foreach (var item in BackupSpeechContexts)
            {
                list.Add(item.SpeechContext);
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public class Dat151SpeechContext : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash ContextName { get; set; }
        public int RepeatTime { get; set; }
        public int RepeatTimeOnSameVoice { get; set; }
        public byte VolumeType { get; set; }
        public byte Audibility { get; set; }
        public byte padding00 { get; set; }
        public byte padding01 { get; set; }
        public MetaHash GenderNonSpecificVersion { get; set; }
        public uint TimeCanNextPlay { get; set; }
        public byte Priority { get; set; }
        public byte numFakeGestures { get; set; }
        public byte FakeGesture1 { get; set; }
        public byte FakeGesture2 { get; set; }
        public byte FakeGesture3 { get; set; }
        public byte FakeGesture4 { get; set; }
        public byte padding02 { get; set; }
        public byte padding03 { get; set; }


        public Dat151SpeechContext(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.SpeechContext;
            TypeID = (byte)Type;
        }
        public Dat151SpeechContext(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            ContextName = br.ReadUInt32();
            RepeatTime = br.ReadInt32();
            RepeatTimeOnSameVoice = br.ReadInt32();
            VolumeType = br.ReadByte();
            Audibility = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadByte();
            GenderNonSpecificVersion = br.ReadUInt32();
            TimeCanNextPlay = br.ReadUInt32();
            Priority = br.ReadByte();
            numFakeGestures = br.ReadByte();
            FakeGesture1 = br.ReadByte();
            FakeGesture2 = br.ReadByte();

            if (numFakeGestures > 2)
            {
                FakeGesture3 = br.ReadByte();
                FakeGesture4 = br.ReadByte();
                padding02 = br.ReadByte();
                padding03 = br.ReadByte();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(ContextName);
            bw.Write(RepeatTime);
            bw.Write(RepeatTimeOnSameVoice);
            bw.Write(VolumeType);
            bw.Write(Audibility);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(GenderNonSpecificVersion);
            bw.Write(TimeCanNextPlay);
            bw.Write(Priority);
            bw.Write(numFakeGestures);
            bw.Write(FakeGesture1);
            bw.Write(FakeGesture2);

            if (numFakeGestures > 2)
            {
                bw.Write(FakeGesture3);
                bw.Write(FakeGesture4);
                bw.Write(padding02);
                bw.Write(padding03);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "ContextName", RelXml.HashString(ContextName));
            RelXml.ValueTag(sb, indent, "RepeatTime", RepeatTime.ToString());
            RelXml.ValueTag(sb, indent, "RepeatTimeOnSameVoice", RepeatTimeOnSameVoice.ToString());
            RelXml.ValueTag(sb, indent, "VolumeType", VolumeType.ToString());
            RelXml.ValueTag(sb, indent, "Audibility", Audibility.ToString());
            RelXml.StringTag(sb, indent, "GenderNonSpecificVersion", RelXml.HashString(GenderNonSpecificVersion));
            RelXml.ValueTag(sb, indent, "TimeCanNextPlay", TimeCanNextPlay.ToString());
            RelXml.ValueTag(sb, indent, "Priority", Priority.ToString());
            RelXml.ValueTag(sb, indent, "numFakeGestures", numFakeGestures.ToString());
            RelXml.ValueTag(sb, indent, "FakeGesture1", FakeGesture1.ToString());
            RelXml.ValueTag(sb, indent, "FakeGesture2", FakeGesture2.ToString());
            if (numFakeGestures > 2)
            {
                RelXml.ValueTag(sb, indent, "FakeGesture3", FakeGesture3.ToString());
                RelXml.ValueTag(sb, indent, "FakeGesture4", FakeGesture4.ToString());
            }
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            ContextName = XmlRel.GetHash(Xml.GetChildInnerText(node, "ContextName"));
            RepeatTime = Xml.GetChildIntAttribute(node, "RepeatTime", "value");
            RepeatTimeOnSameVoice = Xml.GetChildIntAttribute(node, "RepeatTimeOnSameVoice", "value");
            VolumeType = (byte)Xml.GetChildUIntAttribute(node, "VolumeType", "value");
            Audibility = (byte)Xml.GetChildUIntAttribute(node, "Audibility", "value");
            GenderNonSpecificVersion = XmlRel.GetHash(Xml.GetChildInnerText(node, "GenderNonSpecificVersion"));
            TimeCanNextPlay = Xml.GetChildUIntAttribute(node, "TimeCanNextPlay", "value");
            Priority = (byte)Xml.GetChildUIntAttribute(node, "Priority", "value");
            numFakeGestures = (byte)Xml.GetChildUIntAttribute(node, "numFakeGestures", "value");
            FakeGesture1 = (byte)Xml.GetChildUIntAttribute(node, "FakeGesture1", "value");
            FakeGesture2 = (byte)Xml.GetChildUIntAttribute(node, "FakeGesture2", "value");
            if (numFakeGestures > 2)
            {
                FakeGesture3 = (byte)Xml.GetChildUIntAttribute(node, "FakeGesture3", "value");
                FakeGesture4 = (byte)Xml.GetChildUIntAttribute(node, "FakeGesture4", "value");
            }
        }
    }

    [TC(typeof(EXP))]
    public class Dat151SpeechContextVirtual : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash ContextNameHash { get; set; }
        public int RepeatTime { get; set; }
        public int RepeatTimeOnSameVoice { get; set; }
        public byte VolumeType { get; set; }
        public byte Audibility { get; set; }
        public short padding00 { get; set; }
        public MetaHash GenderNonSpecificVersion { get; set; }
        public uint TimeCanNextPlay { get; set; }
        public byte Priority { get; set; }
        public byte numFakeGestures { get; set; }
        public byte FakeGesture1 { get; set; }
        public byte FakeGesture2 { get; set; }
        public byte FakeGesture3 { get; set; }
        public byte FakeGesture4 { get; set; }
        public byte ResolvingFunction { get; set; }
        public byte ItemCount { get; set; }
        public MetaHash[] Items { get; set; }

        public Dat151SpeechContextVirtual(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.SpeechContextVirtual;
            TypeID = (byte)Type;
        }
        public Dat151SpeechContextVirtual(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            ContextNameHash = br.ReadUInt32();
            RepeatTime = br.ReadInt32();
            RepeatTimeOnSameVoice = br.ReadInt32();
            VolumeType = br.ReadByte();
            Audibility = br.ReadByte();
            padding00 = br.ReadInt16();
            GenderNonSpecificVersion = br.ReadUInt32();
            TimeCanNextPlay = br.ReadUInt32();
            Priority = br.ReadByte();
            numFakeGestures = br.ReadByte();

            if (numFakeGestures > 0)
            {
                FakeGesture1 = br.ReadByte();
                FakeGesture2 = br.ReadByte();
                FakeGesture3 = br.ReadByte();
                FakeGesture4 = br.ReadByte();
            }

            ResolvingFunction = br.ReadByte();

            ItemCount = br.ReadByte();
            Items = new MetaHash[ItemCount];
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i] = br.ReadUInt32();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(ContextNameHash);
            bw.Write(RepeatTime);
            bw.Write(RepeatTimeOnSameVoice);
            bw.Write(VolumeType);
            bw.Write(Audibility);
            bw.Write(padding00);
            bw.Write(GenderNonSpecificVersion);
            bw.Write(TimeCanNextPlay);
            bw.Write(Priority);
            bw.Write(numFakeGestures);

            if (numFakeGestures > 0)
            {
                bw.Write(FakeGesture1);
                bw.Write(FakeGesture2);
                bw.Write(FakeGesture3);
                bw.Write(FakeGesture4);
            }

            bw.Write(ResolvingFunction);

            bw.Write(ItemCount);
            for (int i = 0; i < ItemCount; i++)
            {
                bw.Write(Items[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "ContextNameHash", RelXml.HashString(ContextNameHash));
            RelXml.ValueTag(sb, indent, "RepeatTime", RepeatTime.ToString());
            RelXml.ValueTag(sb, indent, "RepeatTimeOnSameVoice", RepeatTimeOnSameVoice.ToString());
            RelXml.ValueTag(sb, indent, "VolumeType", VolumeType.ToString());
            RelXml.ValueTag(sb, indent, "Audibility", Audibility.ToString());
            RelXml.StringTag(sb, indent, "GenderNonSpecificVersion", RelXml.HashString(GenderNonSpecificVersion));
            RelXml.ValueTag(sb, indent, "TimeCanNextPlay", TimeCanNextPlay.ToString());
            RelXml.ValueTag(sb, indent, "Priority", Priority.ToString());
            RelXml.ValueTag(sb, indent, "numFakeGestures", numFakeGestures.ToString());

            if (numFakeGestures > 0)
            {
                RelXml.ValueTag(sb, indent, "FakeGesture1", FakeGesture1.ToString());
                RelXml.ValueTag(sb, indent, "FakeGesture2", FakeGesture2.ToString());
                RelXml.ValueTag(sb, indent, "FakeGesture3", FakeGesture3.ToString());
                RelXml.ValueTag(sb, indent, "FakeGesture4", FakeGesture4.ToString());
            }

            RelXml.ValueTag(sb, indent, "ResolvingFunction", ResolvingFunction.ToString());
            RelXml.WriteHashItemArray(sb, Items, indent, "Items");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            ContextNameHash = XmlRel.GetHash(Xml.GetChildInnerText(node, "ContextNameHash"));
            RepeatTime = Xml.GetChildIntAttribute(node, "RepeatTime", "value");
            RepeatTimeOnSameVoice = Xml.GetChildIntAttribute(node, "RepeatTimeOnSameVoice", "value");
            VolumeType = (byte)Xml.GetChildIntAttribute(node, "VolumeType", "value");
            Audibility = (byte)Xml.GetChildIntAttribute(node, "Audibility", "value");
            GenderNonSpecificVersion = XmlRel.GetHash(Xml.GetChildInnerText(node, "GenderNonSpecificVersion"));
            TimeCanNextPlay = Xml.GetChildUIntAttribute(node, "TimeCanNextPlay", "value");
            Priority = (byte)Xml.GetChildUIntAttribute(node, "Priority", "value");
            numFakeGestures = (byte)Xml.GetChildUIntAttribute(node, "numFakeGestures", "value");

            if (numFakeGestures > 0)
            {
                FakeGesture1 = (byte)Xml.GetChildUIntAttribute(node, "FakeGesture1", "value");
                FakeGesture2 = (byte)Xml.GetChildUIntAttribute(node, "FakeGesture2", "value");
                FakeGesture3 = (byte)Xml.GetChildUIntAttribute(node, "FakeGesture3", "value");
                FakeGesture4 = (byte)Xml.GetChildUIntAttribute(node, "FakeGesture4", "value");
            }

            ResolvingFunction = (byte)Xml.GetChildUIntAttribute(node, "ResolvingFunction", "value");
            Items = XmlRel.ReadHashItemArray(node, "Items");
            ItemCount = (byte)(Items?.Length ?? 0);
        }

        public override MetaHash[] GetSoundHashes()
        {
            return new[] { GenderNonSpecificVersion };
        }
        public override MetaHash[] GetGameHashes()
        {
            return Items;
        }
    }


    [TC(typeof(EXP))] 
    public class Dat151SpeechContextList : Dat151RelData
    {
        public int TriggeredSpeechContextsCount { get; set; }
        public MetaHash[] TriggeredSpeechContexts { get; set; }

        public Dat151SpeechContextList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.SpeechContextList;
            TypeID = (byte)Type;
        }
        public Dat151SpeechContextList(RelData d, BinaryReader br) : base(d, br)
        {
            TriggeredSpeechContextsCount = br.ReadInt32();
            TriggeredSpeechContexts = new MetaHash[TriggeredSpeechContextsCount];
            for (int i = 0; i < TriggeredSpeechContextsCount; i++)
            {
                TriggeredSpeechContexts[i] = br.ReadUInt32();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(TriggeredSpeechContextsCount);
            for (int i = 0; i < TriggeredSpeechContextsCount; i++)
            {
                bw.Write(TriggeredSpeechContexts[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteHashItemArray(sb, TriggeredSpeechContexts, indent, "TriggeredSpeechContexts");
        }
        public override void ReadXml(XmlNode node)
        {
            TriggeredSpeechContexts = XmlRel.ReadHashItemArray(node, "TriggeredSpeechContexts");
            TriggeredSpeechContextsCount = (TriggeredSpeechContexts?.Length ?? 0);
        }
        public override MetaHash[] GetGameHashes()
        {
            return TriggeredSpeechContexts;
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ShoeAudioSettings : Dat151RelData
    {
        public MetaHash Walk { get; set; }
        public MetaHash DirtyWalk { get; set; }
        public MetaHash CreakyWalk { get; set; }
        public MetaHash GlassyWalk { get; set; }
        public MetaHash Run { get; set; }
        public MetaHash DirtyRun { get; set; }
        public MetaHash CreakyRun { get; set; }
        public MetaHash GlassyRun { get; set; }
        public MetaHash WetWalk { get; set; }
        public MetaHash WetRun { get; set; }
        public MetaHash SoftWalk { get; set; }
        public MetaHash Scuff { get; set; }
        public MetaHash Land { get; set; }
        public float ShoeHardness { get; set; }
        public float ShoeCreakiness { get; set; }
        public int ShoeType { get; set; }
        public float ShoeFitness { get; set; }
        public MetaHash LadderShoeDown { get; set; }
        public MetaHash LadderShoeUp { get; set; }
        public MetaHash Kick { get; set; }


        public Dat151ShoeAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ShoeAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151ShoeAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Walk = br.ReadUInt32();
            DirtyWalk = br.ReadUInt32();
            CreakyWalk = br.ReadUInt32();
            GlassyWalk = br.ReadUInt32();
            Run = br.ReadUInt32();
            DirtyRun = br.ReadUInt32();
            CreakyRun = br.ReadUInt32();
            GlassyRun = br.ReadUInt32();
            WetWalk = br.ReadUInt32();
            WetRun = br.ReadUInt32();
            SoftWalk = br.ReadUInt32();
            Scuff = br.ReadUInt32();
            Land = br.ReadUInt32();
            ShoeHardness = br.ReadSingle();
            ShoeCreakiness = br.ReadSingle();
            ShoeType = br.ReadInt32();
            ShoeFitness = br.ReadSingle();
            LadderShoeDown = br.ReadUInt32();
            LadderShoeUp = br.ReadUInt32();
            Kick = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Walk);
            bw.Write(DirtyWalk);
            bw.Write(CreakyWalk);
            bw.Write(GlassyWalk);
            bw.Write(Run);
            bw.Write(DirtyRun);
            bw.Write(CreakyRun);
            bw.Write(GlassyRun);
            bw.Write(WetWalk);
            bw.Write(WetRun);
            bw.Write(SoftWalk);
            bw.Write(Scuff);
            bw.Write(Land);
            bw.Write(ShoeHardness);
            bw.Write(ShoeCreakiness);
            bw.Write(ShoeType);
            bw.Write(ShoeFitness);
            bw.Write(LadderShoeDown);
            bw.Write(LadderShoeUp);
            bw.Write(Kick);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Walk", RelXml.HashString(Walk));
            RelXml.StringTag(sb, indent, "DirtyWalk", RelXml.HashString(DirtyWalk));
            RelXml.StringTag(sb, indent, "CreakyWalk", RelXml.HashString(CreakyWalk));
            RelXml.StringTag(sb, indent, "GlassyWalk", RelXml.HashString(GlassyWalk));
            RelXml.StringTag(sb, indent, "Run", RelXml.HashString(Run));
            RelXml.StringTag(sb, indent, "DirtyRun", RelXml.HashString(DirtyRun));
            RelXml.StringTag(sb, indent, "CreakyRun", RelXml.HashString(CreakyRun));
            RelXml.StringTag(sb, indent, "GlassyRun", RelXml.HashString(GlassyRun));
            RelXml.StringTag(sb, indent, "WetWalk", RelXml.HashString(WetWalk));
            RelXml.StringTag(sb, indent, "WetRun", RelXml.HashString(WetRun));
            RelXml.StringTag(sb, indent, "SoftWalk", RelXml.HashString(SoftWalk));
            RelXml.StringTag(sb, indent, "Scuff", RelXml.HashString(Scuff));
            RelXml.StringTag(sb, indent, "Land", RelXml.HashString(Land));
            RelXml.ValueTag(sb, indent, "ShoeHardness", FloatUtil.ToString(ShoeHardness));
            RelXml.ValueTag(sb, indent, "ShoeCreakiness", FloatUtil.ToString(ShoeCreakiness));
            RelXml.ValueTag(sb, indent, "ShoeType", ShoeType.ToString());
            RelXml.ValueTag(sb, indent, "ShoeFitness", FloatUtil.ToString(ShoeFitness));
            RelXml.StringTag(sb, indent, "LadderShoeDown", RelXml.HashString(LadderShoeDown));
            RelXml.StringTag(sb, indent, "LadderShoeUp", RelXml.HashString(LadderShoeUp));
            RelXml.StringTag(sb, indent, "Kick", RelXml.HashString(Kick));
        }
        public override void ReadXml(XmlNode node)
        {
            Walk = XmlRel.GetHash(Xml.GetChildInnerText(node, "Walk"));
            DirtyWalk = XmlRel.GetHash(Xml.GetChildInnerText(node, "DirtyWalk"));
            CreakyWalk = XmlRel.GetHash(Xml.GetChildInnerText(node, "CreakyWalk"));
            GlassyWalk = XmlRel.GetHash(Xml.GetChildInnerText(node, "GlassyWalk"));
            Run = XmlRel.GetHash(Xml.GetChildInnerText(node, "Run"));
            DirtyRun = XmlRel.GetHash(Xml.GetChildInnerText(node, "DirtyRun"));
            CreakyRun = XmlRel.GetHash(Xml.GetChildInnerText(node, "CreakyRun"));
            GlassyRun = XmlRel.GetHash(Xml.GetChildInnerText(node, "GlassyRun"));
            WetWalk = XmlRel.GetHash(Xml.GetChildInnerText(node, "WetWalk"));
            WetRun = XmlRel.GetHash(Xml.GetChildInnerText(node, "WetRun"));
            SoftWalk = XmlRel.GetHash(Xml.GetChildInnerText(node, "SoftWalk"));
            Scuff = XmlRel.GetHash(Xml.GetChildInnerText(node, "Scuff"));
            Land = XmlRel.GetHash(Xml.GetChildInnerText(node, "Land"));
            ShoeHardness = Xml.GetChildFloatAttribute(node, "ShoeHardness", "value");
            ShoeCreakiness = Xml.GetChildFloatAttribute(node, "ShoeCreakiness", "value");
            ShoeType = Xml.GetChildIntAttribute(node, "ShoeType", "value");
            ShoeFitness = Xml.GetChildFloatAttribute(node, "ShoeFitness", "value");
            LadderShoeDown = XmlRel.GetHash(Xml.GetChildInnerText(node, "LadderShoeDown"));
            LadderShoeUp = XmlRel.GetHash(Xml.GetChildInnerText(node, "LadderShoeUp"));
            Kick = XmlRel.GetHash(Xml.GetChildInnerText(node, "Kick"));
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { Walk, DirtyWalk, CreakyWalk, GlassyWalk, Run, DirtyRun, CreakyRun, GlassyRun, WetWalk, WetRun, SoftWalk, Scuff, Land, LadderShoeDown, LadderShoeUp, Kick };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ModelPhysicsParamsItem : IMetaXmlItem
    {
        public MetaHash ModeName { get; set; }
        public float GroundDistanceDownEpsilon { get; set; }
        public float GroundDistanceUpEpsilon { get; set; }
        public float DownSpeedEpsilon { get; set; }
        public float HindGroundDistanceDownEpsilon { get; set; }
        public float HindGroundDistanceUpEpsilon { get; set; }
        public float SpeedSmootherIncreaseRate { get; set; }
        public float SpeedSmootherDecreaseRate { get; set; }
        public uint TimeToRetrigger { get; set; }

        public Dat151ModelPhysicsParamsItem()
        { }
        public Dat151ModelPhysicsParamsItem(BinaryReader br)
        {
            ModeName = br.ReadUInt32();
            GroundDistanceDownEpsilon = br.ReadSingle();
            GroundDistanceUpEpsilon = br.ReadSingle();
            DownSpeedEpsilon = br.ReadSingle();
            HindGroundDistanceDownEpsilon = br.ReadSingle();
            HindGroundDistanceUpEpsilon = br.ReadSingle();
            SpeedSmootherIncreaseRate = br.ReadSingle();
            SpeedSmootherDecreaseRate = br.ReadSingle();
            TimeToRetrigger = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(ModeName);
            bw.Write(GroundDistanceDownEpsilon);
            bw.Write(GroundDistanceUpEpsilon);
            bw.Write(DownSpeedEpsilon);
            bw.Write(HindGroundDistanceDownEpsilon);
            bw.Write(HindGroundDistanceUpEpsilon);
            bw.Write(SpeedSmootherIncreaseRate);
            bw.Write(SpeedSmootherDecreaseRate);
            bw.Write(TimeToRetrigger);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "ModeName", RelXml.HashString(ModeName));
            RelXml.ValueTag(sb, indent, "GroundDistanceDownEpsilon", FloatUtil.ToString(GroundDistanceDownEpsilon));
            RelXml.ValueTag(sb, indent, "GroundDistanceUpEpsilon", FloatUtil.ToString(GroundDistanceUpEpsilon));
            RelXml.ValueTag(sb, indent, "DownSpeedEpsilon", FloatUtil.ToString(DownSpeedEpsilon));
            RelXml.ValueTag(sb, indent, "HindGroundDistanceDownEpsilon", FloatUtil.ToString(HindGroundDistanceDownEpsilon));
            RelXml.ValueTag(sb, indent, "HindGroundDistanceUpEpsilon", FloatUtil.ToString(HindGroundDistanceUpEpsilon));
            RelXml.ValueTag(sb, indent, "SpeedSmootherIncreaseRate", FloatUtil.ToString(SpeedSmootherIncreaseRate));
            RelXml.ValueTag(sb, indent, "SpeedSmootherDecreaseRate", FloatUtil.ToString(SpeedSmootherDecreaseRate));
            RelXml.ValueTag(sb, indent, "TimeToRetrigger", TimeToRetrigger.ToString());
        }
        public void ReadXml(XmlNode node)
        {
            ModeName = XmlRel.GetHash(Xml.GetChildInnerText(node, "ModeName"));
            GroundDistanceDownEpsilon = Xml.GetChildFloatAttribute(node, "GroundDistanceDownEpsilon", "value");
            GroundDistanceUpEpsilon = Xml.GetChildFloatAttribute(node, "GroundDistanceUpEpsilon", "value");
            DownSpeedEpsilon = Xml.GetChildFloatAttribute(node, "DownSpeedEpsilon", "value");
            HindGroundDistanceDownEpsilon = Xml.GetChildFloatAttribute(node, "HindGroundDistanceDownEpsilon", "value");
            HindGroundDistanceUpEpsilon = Xml.GetChildFloatAttribute(node, "HindGroundDistanceUpEpsilon", "value");
            SpeedSmootherIncreaseRate = Xml.GetChildFloatAttribute(node, "SpeedSmootherIncreaseRate", "value");
            SpeedSmootherDecreaseRate = Xml.GetChildFloatAttribute(node, "SpeedSmootherDecreaseRate", "value");
            TimeToRetrigger = Xml.GetChildUIntAttribute(node, "TimeToRetrigger", "value");
        }
        public override string ToString()
        {
            return ModeName.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ModelPhysicsParams : Dat151RelData
    {
        public uint NumFeet { get; set; }
        public int PedType { get; set; }
        public MetaHash FootstepTuningValues { get; set; }
        public float StopSpeedThreshold { get; set; }
        public float WalkSpeedThreshold { get; set; }
        public float RunSpeedThreshold { get; set; }
        public int ItemCount { get; set; }
        public Dat151ModelPhysicsParamsItem[] Items { get; set; }


        public Dat151ModelPhysicsParams(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ModelPhysicsParams;
            TypeID = (byte)Type;
        }
        public Dat151ModelPhysicsParams(RelData d, BinaryReader br) : base(d, br)
        {
            NumFeet = br.ReadUInt32();
            PedType = br.ReadInt32();
            FootstepTuningValues = br.ReadUInt32();
            StopSpeedThreshold = br.ReadSingle();
            WalkSpeedThreshold = br.ReadSingle();
            RunSpeedThreshold = br.ReadSingle();

            ItemCount = br.ReadInt32();
            Items = new Dat151ModelPhysicsParamsItem[ItemCount];
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i] = new Dat151ModelPhysicsParamsItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(NumFeet);
            bw.Write(PedType);
            bw.Write(FootstepTuningValues);
            bw.Write(StopSpeedThreshold);
            bw.Write(WalkSpeedThreshold);
            bw.Write(RunSpeedThreshold);

            bw.Write(ItemCount);
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i].Write(bw);
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "NumFeet", NumFeet.ToString());
            RelXml.ValueTag(sb, indent, "PedType", PedType.ToString());
            RelXml.StringTag(sb, indent, "FootstepTuningValues", RelXml.HashString(FootstepTuningValues));
            RelXml.ValueTag(sb, indent, "StopSpeedThreshold", FloatUtil.ToString(StopSpeedThreshold));
            RelXml.ValueTag(sb, indent, "WalkSpeedThreshold", FloatUtil.ToString(WalkSpeedThreshold));
            RelXml.ValueTag(sb, indent, "RunSpeedThreshold", FloatUtil.ToString(RunSpeedThreshold));
            RelXml.WriteItemArray(sb, Items, indent, "Items");
        }
        public override void ReadXml(XmlNode node)
        {
            NumFeet = Xml.GetChildUIntAttribute(node, "NumFeet", "value");
            PedType = Xml.GetChildIntAttribute(node, "PedType", "value");
            FootstepTuningValues = XmlRel.GetHash(Xml.GetChildInnerText(node, "FootstepTuningValues"));
            StopSpeedThreshold = Xml.GetChildFloatAttribute(node, "StopSpeedThreshold", "value");
            WalkSpeedThreshold = Xml.GetChildFloatAttribute(node, "WalkSpeedThreshold", "value");
            RunSpeedThreshold = Xml.GetChildFloatAttribute(node, "RunSpeedThreshold", "value");
            Items = XmlRel.ReadItemArray<Dat151ModelPhysicsParamsItem>(node, "Items");
            ItemCount = (Items?.Length ?? 0);
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { FootstepTuningValues };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151SkiAudioSettings : Dat151RelData
    {
        public MetaHash StraightSound { get; set; }
        public float MinSpeed { get; set; }
        public float MaxSpeed { get; set; }
        public MetaHash TurnSound { get; set; }
        public float MinTurn { get; set; }
        public float MaxTurn { get; set; }
        public MetaHash TurnEdgeSound { get; set; }
        public float MinSlopeEdge { get; set; }
        public float MaxSlopeEdge { get; set; }


        public Dat151SkiAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.SkiAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151SkiAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            StraightSound = br.ReadUInt32();
            MinSpeed = br.ReadSingle();
            MaxSpeed = br.ReadSingle();
            TurnSound = br.ReadUInt32();
            MinTurn = br.ReadSingle();
            MaxTurn = br.ReadSingle();
            TurnEdgeSound = br.ReadUInt32();
            MinSlopeEdge = br.ReadSingle();
            MaxSlopeEdge = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(StraightSound);
            bw.Write(MinSpeed);
            bw.Write(MaxSpeed);
            bw.Write(TurnSound);
            bw.Write(MinTurn);
            bw.Write(MaxTurn);
            bw.Write(TurnEdgeSound);
            bw.Write(MinSlopeEdge);
            bw.Write(MaxSlopeEdge);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "StraightSound", RelXml.HashString(StraightSound));
            RelXml.ValueTag(sb, indent, "MinSpeed", FloatUtil.ToString(MinSpeed));
            RelXml.ValueTag(sb, indent, "MaxSpeed", FloatUtil.ToString(MaxSpeed));
            RelXml.StringTag(sb, indent, "TurnSound", RelXml.HashString(TurnSound));
            RelXml.ValueTag(sb, indent, "MinTurn", FloatUtil.ToString(MinTurn));
            RelXml.ValueTag(sb, indent, "MaxTurn", FloatUtil.ToString(MaxTurn));
            RelXml.StringTag(sb, indent, "TurnEdgeSound", RelXml.HashString(TurnEdgeSound));
            RelXml.ValueTag(sb, indent, "MinSlopeEdge", FloatUtil.ToString(MinSlopeEdge));
            RelXml.ValueTag(sb, indent, "MaxSlopeEdge", FloatUtil.ToString(MaxSlopeEdge));
        }
        public override void ReadXml(XmlNode node)
        {
            StraightSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "StraightSound"));
            MinSpeed = Xml.GetChildFloatAttribute(node, "MinSpeed", "value");
            MaxSpeed = Xml.GetChildFloatAttribute(node, "MaxSpeed", "value");
            TurnSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "TurnSound"));
            MinTurn = Xml.GetChildFloatAttribute(node, "MinTurn", "value");
            MaxTurn = Xml.GetChildFloatAttribute(node, "MaxTurn", "value");
            TurnEdgeSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "TurnEdgeSound"));
            MinSlopeEdge = Xml.GetChildFloatAttribute(node, "MinSlopeEdge", "value");
            MaxSlopeEdge = Xml.GetChildFloatAttribute(node, "MaxSlopeEdge", "value");
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { StraightSound, TurnSound, TurnEdgeSound };
        }
    }

    [TC(typeof(EXP))] 
    class Dat151RadioTrackCategoryData : Dat151RelData
    {
        public int ItemCount { get; set; }
        public Dat151RadioTrackCategoryDataItem[] Items { get; set; }

        public Dat151RadioTrackCategoryData(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.RadioTrackCategoryData;
            TypeID = (byte)Type;
        }
        public Dat151RadioTrackCategoryData(RelData d, BinaryReader br) : base(d, br)
        {
            ItemCount = br.ReadInt32();
            Items = new Dat151RadioTrackCategoryDataItem[ItemCount];
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i] = new Dat151RadioTrackCategoryDataItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(ItemCount);
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, Items, indent, "Items");
        }
        public override void ReadXml(XmlNode node)
        {
            Items = XmlRel.ReadItemArray<Dat151RadioTrackCategoryDataItem>(node, "Items");
            ItemCount = (Items?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))]
    public class Dat151RadioTrackCategoryDataItem : IMetaXmlItem
    {
        public int Track { get; set; }
        public int PreDelay { get; set; }

        public Dat151RadioTrackCategoryDataItem()
        { }
        public Dat151RadioTrackCategoryDataItem(BinaryReader br)
        {
            Track = br.ReadInt32();
            PreDelay = br.ReadInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Track);
            bw.Write(PreDelay);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Track", Track.ToString());
            RelXml.ValueTag(sb, indent, "PreDelay", PreDelay.ToString());
        }
        public void ReadXml(XmlNode node)
        {
            Track = Xml.GetChildIntAttribute(node, "Track", "value");
            PreDelay = Xml.GetChildIntAttribute(node, "PreDelay", "value");
        }
        public override string ToString()
        {
            return Track.ToString() + ": " + PreDelay.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ScannerCrimeReportCrimeSet : IMetaXmlItem
    {
        public MetaHash SoundRef { get; set; }
        public float Weight { get; set; }


        public Dat151ScannerCrimeReportCrimeSet()
        { }

        public Dat151ScannerCrimeReportCrimeSet(BinaryReader br)
        {
            SoundRef = br.ReadUInt32();
            Weight = br.ReadSingle();
        }

        public void Write(BinaryWriter bw)
        {
            bw.Write(SoundRef);
            bw.Write(Weight);
        }

        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "SoundRef", RelXml.HashString(SoundRef));
            RelXml.ValueTag(sb, indent, "Weight", FloatUtil.ToString(Weight));
        }

        public void ReadXml(XmlNode node)
        {
            SoundRef = XmlRel.GetHash(Xml.GetChildInnerText(node, "SoundRef"));
            Weight = Xml.GetChildFloatAttribute(node, "Weight", "value");
        }
        public override string ToString()
        {
            return SoundRef.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ScannerCrimeReport : Dat151RelData
    {
        public MetaHash GenericReportedBySoundRef { get; set; }
        public MetaHash ReportedByPedSoundRef { get; set; }
        public MetaHash ReportedByCopSoundRef { get; set; }
        public float AcknowledgeSituationProbability { get; set; }
        public MetaHash SmallCrimeSoundRef { get; set; }
        public int CrimeSetCount { get; set; }
        public Dat151ScannerCrimeReportCrimeSet[] CrimeSets { get; set; }

        public Dat151ScannerCrimeReport(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ScannerCrimeReport;
            TypeID = (byte)Type;
        }
        public Dat151ScannerCrimeReport(RelData d, BinaryReader br) : base(d, br)
        {
            GenericReportedBySoundRef = br.ReadUInt32();
            ReportedByPedSoundRef = br.ReadUInt32();
            ReportedByCopSoundRef = br.ReadUInt32();
            AcknowledgeSituationProbability = br.ReadSingle();
            SmallCrimeSoundRef = br.ReadUInt32();

            CrimeSetCount = br.ReadInt32();
            CrimeSets = new Dat151ScannerCrimeReportCrimeSet[CrimeSetCount];
            for (int i = 0; i < CrimeSetCount; i++)
            {
                CrimeSets[i] = new Dat151ScannerCrimeReportCrimeSet(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(GenericReportedBySoundRef);
            bw.Write(ReportedByPedSoundRef);
            bw.Write(ReportedByCopSoundRef);
            bw.Write(AcknowledgeSituationProbability);
            bw.Write(SmallCrimeSoundRef);

            bw.Write(CrimeSetCount);
            for (int i = 0; i < CrimeSetCount; i++)
            {
                CrimeSets[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "GenericReportedBySoundRef", RelXml.HashString(GenericReportedBySoundRef));
            RelXml.StringTag(sb, indent, "ReportedByPedSoundRef", RelXml.HashString(ReportedByPedSoundRef));
            RelXml.StringTag(sb, indent, "ReportedByCopSoundRef", RelXml.HashString(ReportedByCopSoundRef));
            RelXml.ValueTag(sb, indent, "AcknowledgeSituationProbability", FloatUtil.ToString(AcknowledgeSituationProbability));
            RelXml.StringTag(sb, indent, "SmallCrimeSoundRef", RelXml.HashString(SmallCrimeSoundRef));
            RelXml.WriteItemArray(sb, CrimeSets, indent, "CrimeSets");

        }
        public override void ReadXml(XmlNode node)
        {
            GenericReportedBySoundRef = XmlRel.GetHash(Xml.GetChildInnerText(node, "GenericReportedBySoundRef"));
            ReportedByPedSoundRef = XmlRel.GetHash(Xml.GetChildInnerText(node, "ReportedByPedSoundRef"));
            ReportedByCopSoundRef = XmlRel.GetHash(Xml.GetChildInnerText(node, "ReportedByCopSoundRef"));
            AcknowledgeSituationProbability = Xml.GetChildFloatAttribute(node, "AcknowledgeSituationProbability", "value");
            SmallCrimeSoundRef = XmlRel.GetHash(Xml.GetChildInnerText(node, "SmallCrimeSoundRef"));
            CrimeSets = XmlRel.ReadItemArray<Dat151ScannerCrimeReportCrimeSet>(node, "CrimeSets");
            CrimeSetCount = (CrimeSets?.Length ?? 0);

        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { GenericReportedBySoundRef, ReportedByPedSoundRef, ReportedByCopSoundRef, SmallCrimeSoundRef };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151PedRaceToPedVoiceGroup : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash Universal { get; set; }  // uni
        public MetaHash White { get; set; }      // whi
        public MetaHash Black { get; set; }      // bla
        public MetaHash Chinese { get; set; }    // chi
        public MetaHash Latino { get; set; }     // lat
        public MetaHash Arabic { get; set; }     // ara
        public MetaHash Baltic { get; set; }     // bal
        public MetaHash Jamaican { get; set; }   // jam
        public MetaHash Korean { get; set; }     // kor
        public MetaHash Italian { get; set; }    // ita
        public MetaHash Pakistani { get; set; }  // pak
        public int FriendGroupsCount { get; set; }
        public MetaHash[] FriendGroups { get; set; }  // FriendGroup

        public Dat151PedRaceToPedVoiceGroup(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.PedRaceToPedVoiceGroup;
            TypeID = (byte)Type;
        }
        public Dat151PedRaceToPedVoiceGroup(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            Universal = br.ReadUInt32();
            White = br.ReadUInt32();
            Black = br.ReadUInt32();
            Chinese = br.ReadUInt32();
            Latino = br.ReadUInt32();
            Arabic = br.ReadUInt32();
            Baltic = br.ReadUInt32();
            Jamaican = br.ReadUInt32();
            Korean = br.ReadUInt32();
            Italian = br.ReadUInt32();
            Pakistani = br.ReadUInt32();

            FriendGroupsCount = br.ReadInt32();
            FriendGroups = new MetaHash[FriendGroupsCount];
            for (int i = 0; i < FriendGroupsCount; i++)
            {
                FriendGroups[i] = br.ReadUInt32();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(Universal);
            bw.Write(White);
            bw.Write(Black);
            bw.Write(Chinese);
            bw.Write(Latino);
            bw.Write(Arabic);
            bw.Write(Baltic);
            bw.Write(Jamaican);
            bw.Write(Korean);
            bw.Write(Italian);
            bw.Write(Pakistani);

            bw.Write(FriendGroupsCount);
            for (int i = 0; i < FriendGroupsCount; i++)
            {
                bw.Write(FriendGroups[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "Universal", RelXml.HashString(Universal));
            RelXml.StringTag(sb, indent, "White", RelXml.HashString(White));
            RelXml.StringTag(sb, indent, "Black", RelXml.HashString(Black));
            RelXml.StringTag(sb, indent, "Chinese", RelXml.HashString(Chinese));
            RelXml.StringTag(sb, indent, "Latino", RelXml.HashString(Latino));
            RelXml.StringTag(sb, indent, "Arabic", RelXml.HashString(Arabic));
            RelXml.StringTag(sb, indent, "Baltic", RelXml.HashString(Baltic));
            RelXml.StringTag(sb, indent, "Jamaican", RelXml.HashString(Jamaican));
            RelXml.StringTag(sb, indent, "Korean", RelXml.HashString(Korean));
            RelXml.StringTag(sb, indent, "Italian", RelXml.HashString(Italian));
            RelXml.StringTag(sb, indent, "Pakistani", RelXml.HashString(Pakistani));
            RelXml.WriteHashItemArray(sb, FriendGroups, indent, "FriendGroups");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Universal = XmlRel.GetHash(Xml.GetChildInnerText(node, "Universal"));
            White = XmlRel.GetHash(Xml.GetChildInnerText(node, "White"));
            Black = XmlRel.GetHash(Xml.GetChildInnerText(node, "Black"));
            Chinese = XmlRel.GetHash(Xml.GetChildInnerText(node, "Chinese"));
            Latino = XmlRel.GetHash(Xml.GetChildInnerText(node, "Latino"));
            Arabic = XmlRel.GetHash(Xml.GetChildInnerText(node, "Arabic"));
            Baltic = XmlRel.GetHash(Xml.GetChildInnerText(node, "Baltic"));
            Jamaican = XmlRel.GetHash(Xml.GetChildInnerText(node, "Jamaican"));
            Korean = XmlRel.GetHash(Xml.GetChildInnerText(node, "Korean"));
            Italian = XmlRel.GetHash(Xml.GetChildInnerText(node, "Italian"));
            Pakistani = XmlRel.GetHash(Xml.GetChildInnerText(node, "Pakistani"));
            FriendGroups = XmlRel.ReadHashItemArray(node, "FriendGroups");
            FriendGroupsCount = (FriendGroups?.Length ?? 0);
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            list.AddRange(new[] { Universal, White, Black, Chinese, Latino, Arabic, Baltic, Jamaican, Korean, Italian, Pakistani });
            if (FriendGroups != null) list.AddRange(FriendGroups);
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151FriendGroup : Dat151RelData
    {
        public FlagsUint Flags { get; set; }

        public Dat151FriendGroup(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.FriendGroup;
            TypeID = (byte)Type;
        }
        public Dat151FriendGroup(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ScriptedScannerLine : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public int PhrasesCount { get; set; }
        public Dat151ScriptedScannerLineItem[] Phrase { get; set; }

        public Dat151ScriptedScannerLine(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ScriptedScannerLine;
            TypeID = (byte)Type;
        }
        public Dat151ScriptedScannerLine(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            PhrasesCount = br.ReadInt32();
            Phrase = new Dat151ScriptedScannerLineItem[PhrasesCount];
            for (int i = 0; i < PhrasesCount; i++)
            {
                Phrase[i] = new Dat151ScriptedScannerLineItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(PhrasesCount);
            for (int i = 0; i < PhrasesCount; i++)
            {
                Phrase[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.WriteItemArray(sb, Phrase, indent, "Phrase");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Phrase = XmlRel.ReadItemArray<Dat151ScriptedScannerLineItem>(node, "Phrase");
            PhrasesCount = (Phrase?.Length ?? 0);
        }
        public override MetaHash[] GetSoundHashes()
        {
            var list = new List<MetaHash>();
            if (Phrase != null)
            {
                foreach (var item in Phrase)
                {
                    list.Add(item.SoundRef);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public class Dat151ScriptedScannerLineItem : IMetaXmlItem
    {
        public MetaHash SoundRef { get; set; }
        public short Slot { get; set; }
        public short PostDelay { get; set; }

        public Dat151ScriptedScannerLineItem()
        { }
        public Dat151ScriptedScannerLineItem(BinaryReader br)
        {
            SoundRef = br.ReadUInt32();
            Slot = br.ReadInt16();
            PostDelay = br.ReadInt16();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(SoundRef);
            bw.Write(Slot);
            bw.Write(PostDelay);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "SoundRef", RelXml.HashString(SoundRef));
            RelXml.ValueTag(sb, indent, "Slot", Slot.ToString());
            RelXml.ValueTag(sb, indent, "PostDelay", PostDelay.ToString());
        }
        public void ReadXml(XmlNode node)
        {
            SoundRef = XmlRel.GetHash(Xml.GetChildInnerText(node, "SoundRef"));
            Slot = (short)Xml.GetChildIntAttribute(node, "Slot", "value");
            PostDelay = (short)Xml.GetChildIntAttribute(node, "PostDelay", "value");
        }
        public override string ToString()
        {
            return SoundRef.ToString() + ": " + Slot.ToString() + ", " + PostDelay.ToString();
        }
    }
    [TC(typeof(EXP))]
    public class Dat151ScannerSpecificLocationSounds : IMetaXmlItem
    {
        public MetaHash Sound { get; set; }

        public Dat151ScannerSpecificLocationSounds()
        { }

        public Dat151ScannerSpecificLocationSounds(BinaryReader br)
        {
            Sound = br.ReadUInt32();
        }

        public void Write(BinaryWriter bw)
        {
            bw.Write(Sound);
        }

        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Sound", RelXml.HashString(Sound));
        }

        public void ReadXml(XmlNode node)
        {
            Sound = XmlRel.GetHash(Xml.GetChildInnerText(node, "Sound"));
        }
        public override string ToString()
        {
            return Sound.ToString();
        }

    }

    [TC(typeof(EXP))] 
    public class Dat151ScannerSpecificLocation : Dat151RelData
    {
        public uint padding00 { get; set; }
        public uint padding01 { get; set; }
        public uint padding02 { get; set; }
        public Vector3 Position { get; set; }
        public uint padding03 { get; set; }
        public float Radius { get; set; }
        public float ProbOfPlaying { get; set; }
        public int NumSounds { get; set; }
        public MetaHash[] Sound { get; set; }
        public uint padding06 { get; set; }


        public Dat151ScannerSpecificLocation(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ScannerSpecificLocation;
            TypeID = (byte)Type;
        }
        public Dat151ScannerSpecificLocation(RelData d, BinaryReader br) : base(d, br)
        {
            padding00 = br.ReadUInt32();
            padding01 = br.ReadUInt32();
            padding02 = br.ReadUInt32();
            Position = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            padding03 = br.ReadUInt32();
            Radius = br.ReadSingle();
            ProbOfPlaying = br.ReadSingle();

            NumSounds = br.ReadInt32();
            Sound = new MetaHash[NumSounds];
            for (int i = 0; i < NumSounds; i++)
            {
                Sound[i] = br.ReadUInt32();
            }

            padding06 = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(padding02);
            bw.Write(Position.X);
            bw.Write(Position.Y);
            bw.Write(Position.Z);
            bw.Write(padding03);
            bw.Write(Radius);
            bw.Write(ProbOfPlaying);

            bw.Write(NumSounds);
            for (int i = 0; i < NumSounds; i++)
            {
                bw.Write(Sound[i]);
            }
            bw.Write(padding06);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.SelfClosingTag(sb, indent, "Position " + FloatUtil.GetVector3XmlString(Position));
            RelXml.ValueTag(sb, indent, "Radius", FloatUtil.ToString(Radius));
            RelXml.ValueTag(sb, indent, "ProbOfPlaying", FloatUtil.ToString(ProbOfPlaying));
            RelXml.WriteHashItemArray(sb, Sound, indent, "Sound");
        }
        public override void ReadXml(XmlNode node)
        {
            Position = Xml.GetChildVector3Attributes(node, "Position");
            Radius = Xml.GetChildFloatAttribute(node, "Radius", "value");
            ProbOfPlaying = Xml.GetChildFloatAttribute(node, "ProbOfPlaying", "value");

            Sound = XmlRel.ReadHashItemArray(node, "Sound");
            NumSounds = (Sound?.Length ?? 0);
        }
        public override MetaHash[] GetSoundHashes()
        {
            return Sound;
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ScannerSpecificLocationList : Dat151RelData
    {
        public int LocationsCount { get; set; }
        public MetaHash[] Locations { get; set; }

        public Dat151ScannerSpecificLocationList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ScannerSpecificLocationList;
            TypeID = (byte)Type;
        }
        public Dat151ScannerSpecificLocationList(RelData d, BinaryReader br) : base(d, br)
        {
            LocationsCount = br.ReadInt32();
            Locations = new MetaHash[LocationsCount];
            for (int i = 0; i < LocationsCount; i++)
            {
                Locations[i] = br.ReadUInt32();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(LocationsCount);
            for (int i = 0; i < LocationsCount; i++)
            {
                bw.Write(Locations[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteHashItemArray(sb, Locations, indent, "Locations");
        }
        public override void ReadXml(XmlNode node)
        {
            Locations = XmlRel.ReadHashItemArray(node, "Locations");
            LocationsCount = (Locations?.Length ?? 0);
        }
        public override MetaHash[] GetGameHashes()
        {
            return Locations;
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151AmbientSlotMapItem : IMetaXmlItem
    {
        public MetaHash WaveSlot { get; set; }  // eg. amb_stream_bird_01  (from audioconfig)
        public MetaHash BankName { get; set; }  // eg. streamed_birds  (also in AmbientBankMap)
        public int Priority { get; set; }

        public Dat151AmbientSlotMapItem()
        { }
        public Dat151AmbientSlotMapItem(BinaryReader br)
        {
            WaveSlot = br.ReadUInt32();
            BankName = br.ReadUInt32();
            Priority = br.ReadInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(WaveSlot);
            bw.Write(BankName);
            bw.Write(Priority);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "WaveSlot", RelXml.HashString(WaveSlot));
            RelXml.StringTag(sb, indent, "BankName", RelXml.HashString(BankName));
            RelXml.ValueTag(sb, indent, "Priority", Priority.ToString());
        }
        public void ReadXml(XmlNode node)
        {
            WaveSlot = XmlRel.GetHash(Xml.GetChildInnerText(node, "WaveSlot"));
            BankName = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankName"));
            Priority = Xml.GetChildIntAttribute(node, "Priority", "value");
        }
        public override string ToString()
        {
            return WaveSlot.ToString() + ", " + BankName.ToString() + ", " + Priority.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151AmbientSlotMap : Dat151RelData
    {
        public int AmbienceSlotsCount { get; set; }
        public Dat151AmbientSlotMapItem[] AmbienceSlots { get; set; }

        public Dat151AmbientSlotMap(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.AmbientSlotMap;
            TypeID = (byte)Type;
        }
        public Dat151AmbientSlotMap(RelData d, BinaryReader br) : base(d, br)
        {
            AmbienceSlotsCount = br.ReadInt32();
            AmbienceSlots = new Dat151AmbientSlotMapItem[AmbienceSlotsCount];
            for (int i = 0; i < AmbienceSlotsCount; i++)
            {
                AmbienceSlots[i] = new Dat151AmbientSlotMapItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(AmbienceSlotsCount);
            for (int i = 0; i < AmbienceSlotsCount; i++)
            {
                AmbienceSlots[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, AmbienceSlots, indent, "AmbienceSlots");
        }
        public override void ReadXml(XmlNode node)
        {
            AmbienceSlots = XmlRel.ReadItemArray<Dat151AmbientSlotMapItem>(node, "AmbienceSlots");
            AmbienceSlotsCount = (AmbienceSlots?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151AmbientBankMap : Dat151RelData
    {
        public int AmbienceBanksCount { get; set; }
        public Dat151AmbientBankMapItem[] AmbienceBanks { get; set; }

        public Dat151AmbientBankMap(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.AmbientBankMap;
            TypeID = (byte)Type;
        }
        public Dat151AmbientBankMap(RelData d, BinaryReader br) : base(d, br)
        {
            AmbienceBanksCount = br.ReadInt32();
            AmbienceBanks = new Dat151AmbientBankMapItem[AmbienceBanksCount];
            for (int i = 0; i < AmbienceBanksCount; i++)
            {
                AmbienceBanks[i] = new Dat151AmbientBankMapItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(AmbienceBanksCount);
            for (int i = 0; i < AmbienceBanksCount; i++)
            {
                AmbienceBanks[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, AmbienceBanks, indent, "AmbienceBanks");
        }
        public override void ReadXml(XmlNode node)
        {
            AmbienceBanks = XmlRel.ReadItemArray<Dat151AmbientBankMapItem>(node, "AmbienceBanks");
            AmbienceBanksCount = (AmbienceBanks?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))] 
    public struct Dat151AmbientBankMapItem : IMetaXmlItem
    {
        public MetaHash AudioBank { get; set; }
        public MetaHash BankName { get; set; }

        public Dat151AmbientBankMapItem(BinaryReader br)
        {
            AudioBank = br.ReadUInt32();
            BankName = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(AudioBank);
            bw.Write(BankName);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "AudioBank", RelXml.HashString(AudioBank));
            RelXml.StringTag(sb, indent, "BankName", RelXml.HashString(BankName));
        }
        public void ReadXml(XmlNode node)
        {
            AudioBank = XmlRel.GetHash(Xml.GetChildInnerText(node, "AudioBank"));
            BankName = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankName"));
        }
        public override string ToString()
        {
            return AudioBank.ToString() + ": " + BankName.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151EnvironmentRule : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public float ReverbSmall { get; set; }
        public float ReverbMedium { get; set; }
        public float ReverbLarge { get; set; }
        public float ReverbDamp { get; set; }
        public float EchoDelay { get; set; }
        public float EchoDelayVariance { get; set; }
        public float EchoAttenuation { get; set; }
        public int EchoNumber { get; set; }
        public uint EchoSoundList { get; set; }
        public float BaseEchoVolumeModifier { get; set; }

        public Dat151EnvironmentRule(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.EnvironmentRule;
            TypeID = (byte)Type;
        }
        public Dat151EnvironmentRule(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            ReverbSmall = br.ReadSingle();
            ReverbMedium = br.ReadSingle();
            ReverbLarge = br.ReadSingle();
            ReverbDamp = br.ReadSingle();
            EchoDelay = br.ReadSingle();
            EchoDelayVariance = br.ReadSingle();
            EchoAttenuation = br.ReadSingle();
            EchoNumber = br.ReadInt32();
            EchoSoundList = br.ReadUInt32();
            BaseEchoVolumeModifier = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(ReverbSmall);
            bw.Write(ReverbMedium);
            bw.Write(ReverbLarge);
            bw.Write(ReverbDamp);
            bw.Write(EchoDelay);
            bw.Write(EchoDelayVariance);
            bw.Write(EchoAttenuation);
            bw.Write(EchoNumber);
            bw.Write(EchoSoundList);
            bw.Write(BaseEchoVolumeModifier);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "ReverbSmall", FloatUtil.ToString(ReverbSmall));
            RelXml.ValueTag(sb, indent, "ReverbMedium", FloatUtil.ToString(ReverbMedium));
            RelXml.ValueTag(sb, indent, "ReverbLarge", FloatUtil.ToString(ReverbLarge));
            RelXml.ValueTag(sb, indent, "ReverbDamp", FloatUtil.ToString(ReverbDamp));
            RelXml.ValueTag(sb, indent, "EchoDelay", FloatUtil.ToString(EchoDelay));
            RelXml.ValueTag(sb, indent, "EchoDelayVariance", FloatUtil.ToString(EchoDelayVariance));
            RelXml.ValueTag(sb, indent, "EchoAttenuation", FloatUtil.ToString(EchoAttenuation));
            RelXml.ValueTag(sb, indent, "EchoNumber", EchoNumber.ToString());
            RelXml.ValueTag(sb, indent, "EchoSoundList", EchoSoundList.ToString());
            RelXml.ValueTag(sb, indent, "BaseEchoVolumeModifier", FloatUtil.ToString(BaseEchoVolumeModifier));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            ReverbSmall = Xml.GetChildFloatAttribute(node, "ReverbSmall", "value");
            ReverbMedium = Xml.GetChildFloatAttribute(node, "ReverbMedium", "value");
            ReverbLarge = Xml.GetChildFloatAttribute(node, "ReverbLarge", "value");
            ReverbDamp = Xml.GetChildFloatAttribute(node, "ReverbDamp", "value");
            EchoDelay = Xml.GetChildFloatAttribute(node, "EchoDelay", "value");
            EchoDelayVariance = Xml.GetChildFloatAttribute(node, "EchoDelayVariance", "value");
            EchoAttenuation = Xml.GetChildFloatAttribute(node, "EchoAttenuation", "value");
            EchoNumber = Xml.GetChildIntAttribute(node, "EchoNumber", "value");
            EchoSoundList = Xml.GetChildUIntAttribute(node, "EchoSoundList", "value");
            BaseEchoVolumeModifier = Xml.GetChildFloatAttribute(node, "BaseEchoVolumeModifier", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151InteriorWeaponMetrics : Dat151RelData
    {
        public float Wetness { get; set; }
        public float Visability { get; set; }
        public uint LPFCutoff { get; set; }
        public uint PreDelay { get; set; }
        public float Hold { get; set; }

        public Dat151InteriorWeaponMetrics(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.InteriorWeaponMetrics;
            TypeID = (byte)Type;
        }
        public Dat151InteriorWeaponMetrics(RelData d, BinaryReader br) : base(d, br)
        {
            Wetness = br.ReadSingle();
            Visability = br.ReadSingle();
            LPFCutoff = br.ReadUInt32();
            PreDelay = br.ReadUInt32();
            Hold = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Wetness);
            bw.Write(Visability);
            bw.Write(LPFCutoff);
            bw.Write(PreDelay);
            bw.Write(Hold);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Wetness", FloatUtil.ToString(Wetness));
            RelXml.ValueTag(sb, indent, "Visability", FloatUtil.ToString(Visability));
            RelXml.ValueTag(sb, indent, "LPFCutoff", LPFCutoff.ToString());
            RelXml.ValueTag(sb, indent, "PreDelay", PreDelay.ToString());
            RelXml.ValueTag(sb, indent, "Hold", FloatUtil.ToString(Hold));
        }
        public override void ReadXml(XmlNode node)
        {
            Wetness = Xml.GetChildFloatAttribute(node, "Wetness", "value");
            Visability = Xml.GetChildFloatAttribute(node, "Visability", "value");
            LPFCutoff = Xml.GetChildUIntAttribute(node, "LPFCutoff", "value");
            PreDelay = Xml.GetChildUIntAttribute(node, "PreDelay", "value");
            Hold = Xml.GetChildFloatAttribute(node, "Hold", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151DoorTuningParams : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public float OpenThresh { get; set; }
        public float HeadingThresh { get; set; }
        public float ClosedThresh { get; set; }
        public float SpeedThresh { get; set; }
        public float SpeedScale { get; set; }
        public float HeadingDeltaThreshold { get; set; }
        public float AngularVelocityThreshold { get; set; }
        public int DoorType { get; set; }

        public Dat151DoorTuningParams(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.DoorTuningParams;
            TypeID = (byte)Type;
        }
        public Dat151DoorTuningParams(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            OpenThresh = br.ReadSingle();
            HeadingThresh = br.ReadSingle();
            ClosedThresh = br.ReadSingle();
            SpeedThresh = br.ReadSingle();
            SpeedScale = br.ReadSingle();
            HeadingDeltaThreshold = br.ReadSingle();
            AngularVelocityThreshold = br.ReadSingle();
            DoorType = br.ReadInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(OpenThresh);
            bw.Write(HeadingThresh);
            bw.Write(ClosedThresh);
            bw.Write(SpeedThresh);
            bw.Write(SpeedScale);
            bw.Write(HeadingDeltaThreshold);
            bw.Write(AngularVelocityThreshold);
            bw.Write(DoorType);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "OpenThresh", FloatUtil.ToString(OpenThresh));
            RelXml.ValueTag(sb, indent, "HeadingThresh", FloatUtil.ToString(HeadingThresh));
            RelXml.ValueTag(sb, indent, "ClosedThresh", FloatUtil.ToString(ClosedThresh));
            RelXml.ValueTag(sb, indent, "SpeedThresh", FloatUtil.ToString(SpeedThresh));
            RelXml.ValueTag(sb, indent, "SpeedScale", FloatUtil.ToString(SpeedScale));
            RelXml.ValueTag(sb, indent, "HeadingDeltaThreshold", FloatUtil.ToString(HeadingDeltaThreshold));
            RelXml.ValueTag(sb, indent, "AngularVelocityThreshold", FloatUtil.ToString(AngularVelocityThreshold));
            RelXml.ValueTag(sb, indent, "DoorType", DoorType.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            OpenThresh = Xml.GetChildFloatAttribute(node, "OpenThresh", "value");
            HeadingThresh = Xml.GetChildFloatAttribute(node, "HeadingThresh", "value");
            ClosedThresh = Xml.GetChildFloatAttribute(node, "ClosedThresh", "value");
            SpeedThresh = Xml.GetChildFloatAttribute(node, "SpeedThresh", "value");
            SpeedScale = Xml.GetChildFloatAttribute(node, "SpeedScale", "value");
            HeadingDeltaThreshold = Xml.GetChildFloatAttribute(node, "HeadingDeltaThreshold", "value");
            AngularVelocityThreshold = Xml.GetChildFloatAttribute(node, "AngularVelocityThreshold", "value");
            DoorType = Xml.GetChildIntAttribute(node, "DoorType", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ClimbingAudioSettings : Dat151RelData
    {
        public MetaHash Launch { get; set; }
        public MetaHash Foot { get; set; }
        public MetaHash Knee { get; set; }
        public MetaHash Scrape { get; set; }
        public MetaHash Hand { get; set; }

        public Dat151ClimbingAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ClimbingAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151ClimbingAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Launch = br.ReadUInt32();
            Foot = br.ReadUInt32();
            Knee = br.ReadUInt32();
            Scrape = br.ReadUInt32();
            Hand = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Launch);
            bw.Write(Foot);
            bw.Write(Knee);
            bw.Write(Scrape);
            bw.Write(Hand);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Launch", RelXml.HashString(Launch));
            RelXml.StringTag(sb, indent, "Foot", RelXml.HashString(Foot));
            RelXml.StringTag(sb, indent, "Knee", RelXml.HashString(Knee));
            RelXml.StringTag(sb, indent, "Scrape", RelXml.HashString(Scrape));
            RelXml.StringTag(sb, indent, "Hand", RelXml.HashString(Hand));
        }
        public override void ReadXml(XmlNode node)
        {
            Launch = XmlRel.GetHash(Xml.GetChildInnerText(node, "Launch"));
            Foot = XmlRel.GetHash(Xml.GetChildInnerText(node, "Foot"));
            Knee = XmlRel.GetHash(Xml.GetChildInnerText(node, "Knee"));
            Scrape = XmlRel.GetHash(Xml.GetChildInnerText(node, "Scrape"));
            Hand = XmlRel.GetHash(Xml.GetChildInnerText(node, "Hand"));
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { Launch, Foot, Knee, Scrape, Hand };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151WeatherAudioSettings : Dat151RelData
    {
        public float Strength { get; set; }
        public float Blustery { get; set; }
        public float Temperature { get; set; }
        public float TimeOfDayAffectsTemperature { get; set; }
        public float WhistleVolumeOffset { get; set; }
        public MetaHash WindGust { get; set; }
        public MetaHash AudioScene { get; set; }
        public MetaHash WindGustEnd { get; set; }
        public int WindSoundsCount { get; set; }
        public MetaHash[] WindSounds { get; set; }

        public Dat151WeatherAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.WeatherAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151WeatherAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Strength = br.ReadSingle();
            Blustery = br.ReadSingle();
            Temperature = br.ReadSingle();
            TimeOfDayAffectsTemperature = br.ReadSingle();
            WhistleVolumeOffset = br.ReadSingle();
            WindGust = br.ReadUInt32();
            AudioScene = br.ReadUInt32();
            WindGustEnd = br.ReadUInt32();

            WindSoundsCount = br.ReadInt32();
            WindSounds = new MetaHash[WindSoundsCount];
            for (int i = 0; i < WindSoundsCount; i++)
            {
                WindSounds[i] = br.ReadUInt32();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Strength);
            bw.Write(Blustery);
            bw.Write(Temperature);
            bw.Write(TimeOfDayAffectsTemperature);
            bw.Write(WhistleVolumeOffset);
            bw.Write(WindGust);
            bw.Write(AudioScene);
            bw.Write(WindGustEnd);

            bw.Write(WindSoundsCount);
            for (int i = 0; i < WindSoundsCount; i++)
            {
                bw.Write(WindSounds[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Strength", FloatUtil.ToString(Strength));
            RelXml.ValueTag(sb, indent, "Blustery", FloatUtil.ToString(Blustery));
            RelXml.ValueTag(sb, indent, "Temperature", FloatUtil.ToString(Temperature));
            RelXml.ValueTag(sb, indent, "TimeOfDayAffectsTemperature", FloatUtil.ToString(TimeOfDayAffectsTemperature));
            RelXml.ValueTag(sb, indent, "WhistleVolumeOffset", FloatUtil.ToString(WhistleVolumeOffset));
            RelXml.StringTag(sb, indent, "WindGust", RelXml.HashString(WindGust));
            RelXml.StringTag(sb, indent, "AudioScene", RelXml.HashString(AudioScene));
            RelXml.StringTag(sb, indent, "WindGustEnd", RelXml.HashString(WindGustEnd));
            RelXml.WriteHashItemArray(sb, WindSounds, indent, "WindSounds");
        }
        public override void ReadXml(XmlNode node)
        {
            Strength = Xml.GetChildFloatAttribute(node, "Strength", "value");
            Blustery = Xml.GetChildFloatAttribute(node, "Blustery", "value");
            Temperature = Xml.GetChildFloatAttribute(node, "Temperature", "value");
            TimeOfDayAffectsTemperature = Xml.GetChildFloatAttribute(node, "TimeOfDayAffectsTemperature", "value");
            WhistleVolumeOffset = Xml.GetChildFloatAttribute(node, "WhistleVolumeOffset", "value");
            WindGust = XmlRel.GetHash(Xml.GetChildInnerText(node, "WindGust"));
            AudioScene = XmlRel.GetHash(Xml.GetChildInnerText(node, "AudioScene"));
            WindGustEnd = XmlRel.GetHash(Xml.GetChildInnerText(node, "WindGustEnd"));
            WindSounds = XmlRel.ReadHashItemArray(node, "WindSounds");
            WindSoundsCount = (WindSounds?.Length ?? 0);
        }
        public override MetaHash[] GetMixerHashes()
        {
            return new[] { AudioScene };
        }
        public override MetaHash[] GetSoundHashes()
        {
            var list = new List<MetaHash>();
            list.Add(WindGust);
            list.Add(WindGustEnd);
            if (WindSounds != null)
            {
                list.AddRange(WindSounds);
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151StemMix : Dat151RelData
    {
        public short Stem1Volume { get; set; }
        public short Stem2Volume { get; set; }
        public short Stem3Volume { get; set; }
        public short Stem4Volume { get; set; }
        public short Stem5Volume { get; set; }
        public short Stem6Volume { get; set; }
        public short Stem7Volume { get; set; }
        public short Stem8Volume { get; set; }

        public Dat151StemMix(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.StemMix;
            TypeID = (byte)Type;
        }
        public Dat151StemMix(RelData d, BinaryReader br) : base(d, br)
        {
            Stem1Volume = br.ReadInt16();
            Stem2Volume = br.ReadInt16();
            Stem3Volume = br.ReadInt16();
            Stem4Volume = br.ReadInt16();
            Stem5Volume = br.ReadInt16();
            Stem6Volume = br.ReadInt16();
            Stem7Volume = br.ReadInt16();
            Stem8Volume = br.ReadInt16();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Stem1Volume);
            bw.Write(Stem2Volume);
            bw.Write(Stem3Volume);
            bw.Write(Stem4Volume);
            bw.Write(Stem5Volume);
            bw.Write(Stem6Volume);
            bw.Write(Stem7Volume);
            bw.Write(Stem8Volume);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Stem1Volume", Stem1Volume.ToString());
            RelXml.ValueTag(sb, indent, "Stem2Volume", Stem2Volume.ToString());
            RelXml.ValueTag(sb, indent, "Stem3Volume", Stem3Volume.ToString());
            RelXml.ValueTag(sb, indent, "Stem4Volume", Stem4Volume.ToString());
            RelXml.ValueTag(sb, indent, "Stem5Volume", Stem5Volume.ToString());
            RelXml.ValueTag(sb, indent, "Stem6Volume", Stem6Volume.ToString());
            RelXml.ValueTag(sb, indent, "Stem7Volume", Stem7Volume.ToString());
            RelXml.ValueTag(sb, indent, "Stem8Volume", Stem8Volume.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            Stem1Volume = (short)Xml.GetChildIntAttribute(node, "Stem1Volume", "value");
            Stem2Volume = (short)Xml.GetChildIntAttribute(node, "Stem2Volume", "value");
            Stem3Volume = (short)Xml.GetChildIntAttribute(node, "Stem3Volume", "value");
            Stem4Volume = (short)Xml.GetChildIntAttribute(node, "Stem4Volume", "value");
            Stem5Volume = (short)Xml.GetChildIntAttribute(node, "Stem5Volume", "value");
            Stem6Volume = (short)Xml.GetChildIntAttribute(node, "Stem6Volume", "value");
            Stem7Volume = (short)Xml.GetChildIntAttribute(node, "Stem7Volume", "value");
            Stem8Volume = (short)Xml.GetChildIntAttribute(node, "Stem8Volume", "value");
        }
    }

    [TC(typeof(EXP))]
    public class Dat151BeatConstraint : Dat151RelData
    {
        public ushort ValidSixteenths { get; set; }

        public Dat151BeatConstraint(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.BeatConstraint;
            TypeID = (byte)Type;
        }
        public Dat151BeatConstraint(RelData d, BinaryReader br) : base(d, br)
        {
            ValidSixteenths = br.ReadUInt16();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(ValidSixteenths);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "ValidSixteenths", ValidSixteenths.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            ValidSixteenths = (ushort)Xml.GetChildUIntAttribute(node, "ValidSixteenths", "value");
        }
    }

    [TC(typeof(EXP))]
    public class Dat151BarConstraint : Dat151RelData
    {
        public int PatternLength { get; set; }
        public int ValidBar { get; set; }

        public Dat151BarConstraint(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.BarConstraint;
            TypeID = (byte)Type;
        }
        public Dat151BarConstraint(RelData d, BinaryReader br) : base(d, br)
        {
            PatternLength = br.ReadInt32();
            ValidBar = br.ReadInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(PatternLength);
            bw.Write(ValidBar);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "PatternLength", PatternLength.ToString());
            RelXml.ValueTag(sb, indent, "ValidBar", ValidBar.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            PatternLength = Xml.GetChildIntAttribute(node, "PatternLength", "value");
            ValidBar = Xml.GetChildIntAttribute(node, "ValidBar", "value");
        }
    }

    [TC(typeof(EXP))]
    public class Dat151DirectionalAmbience : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash SoundNorth { get; set; }
        public MetaHash SoundEast { get; set; }
        public MetaHash SoundSouth { get; set; }
        public MetaHash SoundWest { get; set; }
        public float VolumeSmoothing { get; set; }
        public MetaHash TimeToVolume { get; set; }
        public MetaHash OcclusionToVol { get; set; }
        public MetaHash HeightToCutOff { get; set; }
        public MetaHash OcclusionToCutOff { get; set; }
        public MetaHash BuiltUpFactorToVol { get; set; }
        public MetaHash BuildingDensityToVol { get; set; }
        public MetaHash TreeDensityToVol { get; set; }
        public MetaHash WaterFactorToVol { get; set; }
        public float InstanceVolumeScale { get; set; }
        public MetaHash HeightAboveBlanketToVol { get; set; }
        public MetaHash HighwayFactorToVol { get; set; }
        public MetaHash VehicleCountToVol { get; set; }
        public float MaxDistanceOutToSea { get; set; }

        public Dat151DirectionalAmbience(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.DirectionalAmbience;
            TypeID = (byte)Type;
        }
        public Dat151DirectionalAmbience(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            SoundNorth = br.ReadUInt32();
            SoundEast = br.ReadUInt32();
            SoundSouth = br.ReadUInt32();
            SoundWest = br.ReadUInt32();
            VolumeSmoothing = br.ReadSingle();
            TimeToVolume = br.ReadUInt32();
            OcclusionToVol = br.ReadUInt32();
            HeightToCutOff = br.ReadUInt32();
            OcclusionToCutOff = br.ReadUInt32();
            BuiltUpFactorToVol = br.ReadUInt32();
            BuildingDensityToVol = br.ReadUInt32();
            TreeDensityToVol = br.ReadUInt32();
            WaterFactorToVol = br.ReadUInt32();
            InstanceVolumeScale = br.ReadSingle();
            HeightAboveBlanketToVol = br.ReadUInt32();
            HighwayFactorToVol = br.ReadUInt32();
            VehicleCountToVol = br.ReadUInt32();
            MaxDistanceOutToSea = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(SoundNorth);
            bw.Write(SoundEast);
            bw.Write(SoundSouth);
            bw.Write(SoundWest);
            bw.Write(VolumeSmoothing);
            bw.Write(TimeToVolume);
            bw.Write(OcclusionToVol);
            bw.Write(HeightToCutOff);
            bw.Write(OcclusionToCutOff);
            bw.Write(BuiltUpFactorToVol);
            bw.Write(BuildingDensityToVol);
            bw.Write(TreeDensityToVol);
            bw.Write(WaterFactorToVol);
            bw.Write(InstanceVolumeScale);
            bw.Write(HeightAboveBlanketToVol);
            bw.Write(HighwayFactorToVol);
            bw.Write(VehicleCountToVol);
            bw.Write(MaxDistanceOutToSea);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "SoundNorth", RelXml.HashString(SoundNorth));
            RelXml.StringTag(sb, indent, "SoundEast", RelXml.HashString(SoundEast));
            RelXml.StringTag(sb, indent, "SoundSouth", RelXml.HashString(SoundSouth));
            RelXml.StringTag(sb, indent, "SoundWest", RelXml.HashString(SoundWest));
            RelXml.ValueTag(sb, indent, "VolumeSmoothing", FloatUtil.ToString(VolumeSmoothing));
            RelXml.StringTag(sb, indent, "TimeToVolume", RelXml.HashString(TimeToVolume));
            RelXml.StringTag(sb, indent, "OcclusionToVol", RelXml.HashString(OcclusionToVol));
            RelXml.StringTag(sb, indent, "HeightToCutOff", RelXml.HashString(HeightToCutOff));
            RelXml.StringTag(sb, indent, "OcclusionToCutOff", RelXml.HashString(OcclusionToCutOff));
            RelXml.StringTag(sb, indent, "BuiltUpFactorToVol", RelXml.HashString(BuiltUpFactorToVol));
            RelXml.StringTag(sb, indent, "BuildingDensityToVol", RelXml.HashString(BuildingDensityToVol));
            RelXml.StringTag(sb, indent, "TreeDensityToVol", RelXml.HashString(TreeDensityToVol));
            RelXml.StringTag(sb, indent, "WaterFactorToVol", RelXml.HashString(WaterFactorToVol));
            RelXml.ValueTag(sb, indent, "InstanceVolumeScale", FloatUtil.ToString(InstanceVolumeScale));
            RelXml.StringTag(sb, indent, "HeightAboveBlanketToVol", RelXml.HashString(HeightAboveBlanketToVol));
            RelXml.StringTag(sb, indent, "HighwayFactorToVol", RelXml.HashString(HighwayFactorToVol));
            RelXml.StringTag(sb, indent, "VehicleCountToVol", RelXml.HashString(VehicleCountToVol));
            RelXml.ValueTag(sb, indent, "MaxDistanceOutToSea", FloatUtil.ToString(MaxDistanceOutToSea));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            SoundNorth = XmlRel.GetHash(Xml.GetChildInnerText(node, "SoundNorth"));
            SoundEast = XmlRel.GetHash(Xml.GetChildInnerText(node, "SoundEast"));
            SoundSouth = XmlRel.GetHash(Xml.GetChildInnerText(node, "SoundSouth"));
            SoundWest = XmlRel.GetHash(Xml.GetChildInnerText(node, "SoundWest"));
            VolumeSmoothing = Xml.GetChildFloatAttribute(node, "VolumeSmoothing", "value");
            TimeToVolume = XmlRel.GetHash(Xml.GetChildInnerText(node, "TimeToVolume"));
            OcclusionToVol = XmlRel.GetHash(Xml.GetChildInnerText(node, "OcclusionToVol"));
            HeightToCutOff = XmlRel.GetHash(Xml.GetChildInnerText(node, "HeightToCutOff"));
            OcclusionToCutOff = XmlRel.GetHash(Xml.GetChildInnerText(node, "OcclusionToCutOff"));
            BuiltUpFactorToVol = XmlRel.GetHash(Xml.GetChildInnerText(node, "BuiltUpFactorToVol"));
            BuildingDensityToVol = XmlRel.GetHash(Xml.GetChildInnerText(node, "BuildingDensityToVol"));
            TreeDensityToVol = XmlRel.GetHash(Xml.GetChildInnerText(node, "TreeDensityToVol"));
            WaterFactorToVol = XmlRel.GetHash(Xml.GetChildInnerText(node, "WaterFactorToVol"));
            InstanceVolumeScale = Xml.GetChildFloatAttribute(node, "InstanceVolumeScale", "value");
            HeightAboveBlanketToVol = XmlRel.GetHash(Xml.GetChildInnerText(node, "HeightAboveBlanketToVol"));
            HighwayFactorToVol = XmlRel.GetHash(Xml.GetChildInnerText(node, "HighwayFactorToVol"));
            VehicleCountToVol = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleCountToVol"));
            MaxDistanceOutToSea = Xml.GetChildFloatAttribute(node, "MaxDistanceOutToSea", "value");
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { TimeToVolume, OcclusionToVol, HeightToCutOff, OcclusionToCutOff, BuiltUpFactorToVol, BuildingDensityToVol, TreeDensityToVol, WaterFactorToVol, HeightAboveBlanketToVol, HighwayFactorToVol, VehicleCountToVol };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { SoundNorth, SoundEast, SoundSouth, SoundWest };
        }
    }

    [TC(typeof(EXP))]
    public class Dat151GunfightConductorIntensitySettings : Dat151RelData
    {
        public int MaxTimeAfterLastShot { get; set; }
        public float TimeToFakeBulletImpacts { get; set; }
        public float CoverMinTimeToReTriggerFakeBulletImpacts { get; set; }
        public float CoverMaxTimeToReTriggerFakeBulletImpacts { get; set; }
        public float RunningAwayMinTimeToFakeBulletImpacts { get; set; }
        public float RunningAwayMaxTimeToFakeBulletImpacts { get; set; }
        public float VfxProbability { get; set; }
        public float OpenSpaceMinTimeToFakeBulletImpacts { get; set; }
        public float OpenSpaceMaxTimeToFakeBulletImpacts { get; set; }
        public MetaHash ObjectsMediumIntensity { get; set; }
        public MetaHash ObjectsHighIntensity { get; set; }
        public MetaHash VehiclesMediumIntensity { get; set; }
        public MetaHash VehiclesHighIntensity { get; set; }
        public MetaHash GroundMediumIntensity { get; set; }
        public MetaHash GroundHighIntensity { get; set; }

        public Dat151GunfightConductorIntensitySettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.GunfightConductorIntensitySettings;
            TypeID = (byte)Type;
        }
        public Dat151GunfightConductorIntensitySettings(RelData d, BinaryReader br) : base(d, br)
        {
            MaxTimeAfterLastShot = br.ReadInt32();
            TimeToFakeBulletImpacts = br.ReadSingle();
            CoverMinTimeToReTriggerFakeBulletImpacts = br.ReadSingle();
            CoverMaxTimeToReTriggerFakeBulletImpacts = br.ReadSingle();
            RunningAwayMinTimeToFakeBulletImpacts = br.ReadSingle();
            RunningAwayMaxTimeToFakeBulletImpacts = br.ReadSingle();
            VfxProbability = br.ReadSingle();
            OpenSpaceMinTimeToFakeBulletImpacts = br.ReadSingle();
            OpenSpaceMaxTimeToFakeBulletImpacts = br.ReadSingle();
            ObjectsMediumIntensity = br.ReadUInt32();
            ObjectsHighIntensity = br.ReadUInt32();
            VehiclesMediumIntensity = br.ReadUInt32();
            VehiclesHighIntensity = br.ReadUInt32();
            GroundMediumIntensity = br.ReadUInt32();
            GroundHighIntensity = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(MaxTimeAfterLastShot);
            bw.Write(TimeToFakeBulletImpacts);
            bw.Write(CoverMinTimeToReTriggerFakeBulletImpacts);
            bw.Write(CoverMaxTimeToReTriggerFakeBulletImpacts);
            bw.Write(RunningAwayMinTimeToFakeBulletImpacts);
            bw.Write(RunningAwayMaxTimeToFakeBulletImpacts);
            bw.Write(VfxProbability);
            bw.Write(OpenSpaceMinTimeToFakeBulletImpacts);
            bw.Write(OpenSpaceMaxTimeToFakeBulletImpacts);
            bw.Write(ObjectsMediumIntensity);
            bw.Write(ObjectsHighIntensity);
            bw.Write(VehiclesMediumIntensity);
            bw.Write(VehiclesHighIntensity);
            bw.Write(GroundMediumIntensity);
            bw.Write(GroundHighIntensity);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "MaxTimeAfterLastShot", MaxTimeAfterLastShot.ToString());
            RelXml.ValueTag(sb, indent, "TimeToFakeBulletImpacts", FloatUtil.ToString(TimeToFakeBulletImpacts));
            RelXml.ValueTag(sb, indent, "CoverMinTimeToReTriggerFakeBulletImpacts", FloatUtil.ToString(CoverMinTimeToReTriggerFakeBulletImpacts));
            RelXml.ValueTag(sb, indent, "CoverMaxTimeToReTriggerFakeBulletImpacts", FloatUtil.ToString(CoverMaxTimeToReTriggerFakeBulletImpacts));
            RelXml.ValueTag(sb, indent, "RunningAwayMinTimeToFakeBulletImpacts", FloatUtil.ToString(RunningAwayMinTimeToFakeBulletImpacts));
            RelXml.ValueTag(sb, indent, "RunningAwayMaxTimeToFakeBulletImpacts", FloatUtil.ToString(RunningAwayMaxTimeToFakeBulletImpacts));
            RelXml.ValueTag(sb, indent, "VfxProbability", FloatUtil.ToString(VfxProbability));
            RelXml.ValueTag(sb, indent, "OpenSpaceMinTimeToFakeBulletImpacts", FloatUtil.ToString(OpenSpaceMinTimeToFakeBulletImpacts));
            RelXml.ValueTag(sb, indent, "OpenSpaceMaxTimeToFakeBulletImpacts", FloatUtil.ToString(OpenSpaceMaxTimeToFakeBulletImpacts));
            RelXml.StringTag(sb, indent, "ObjectsMediumIntensity", RelXml.HashString(ObjectsMediumIntensity));
            RelXml.StringTag(sb, indent, "ObjectsHighIntensity", RelXml.HashString(ObjectsHighIntensity));
            RelXml.StringTag(sb, indent, "VehiclesMediumIntensity", RelXml.HashString(VehiclesMediumIntensity));
            RelXml.StringTag(sb, indent, "VehiclesHighIntensity", RelXml.HashString(VehiclesHighIntensity));
            RelXml.StringTag(sb, indent, "GroundMediumIntensity", RelXml.HashString(GroundMediumIntensity));
            RelXml.StringTag(sb, indent, "GroundHighIntensity", RelXml.HashString(GroundHighIntensity));
        }
        public override void ReadXml(XmlNode node)
        {
            MaxTimeAfterLastShot = Xml.GetChildIntAttribute(node, "MaxTimeAfterLastShot", "value");
            TimeToFakeBulletImpacts = Xml.GetChildFloatAttribute(node, "TimeToFakeBulletImpacts", "value");
            CoverMinTimeToReTriggerFakeBulletImpacts = Xml.GetChildFloatAttribute(node, "CoverMinTimeToReTriggerFakeBulletImpacts", "value");
            CoverMaxTimeToReTriggerFakeBulletImpacts = Xml.GetChildFloatAttribute(node, "CoverMaxTimeToReTriggerFakeBulletImpacts", "value");
            RunningAwayMinTimeToFakeBulletImpacts = Xml.GetChildFloatAttribute(node, "RunningAwayMinTimeToFakeBulletImpacts", "value");
            RunningAwayMaxTimeToFakeBulletImpacts = Xml.GetChildFloatAttribute(node, "RunningAwayMaxTimeToFakeBulletImpacts", "value");
            VfxProbability = Xml.GetChildFloatAttribute(node, "VfxProbability", "value");
            OpenSpaceMinTimeToFakeBulletImpacts = Xml.GetChildFloatAttribute(node, "OpenSpaceMinTimeToFakeBulletImpacts", "value");
            OpenSpaceMaxTimeToFakeBulletImpacts = Xml.GetChildFloatAttribute(node, "OpenSpaceMaxTimeToFakeBulletImpacts", "value");
            ObjectsMediumIntensity = XmlRel.GetHash(Xml.GetChildInnerText(node, "ObjectsMediumIntensity"));
            ObjectsHighIntensity = XmlRel.GetHash(Xml.GetChildInnerText(node, "ObjectsHighIntensity"));
            VehiclesMediumIntensity = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehiclesMediumIntensity"));
            VehiclesHighIntensity = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehiclesHighIntensity"));
            GroundMediumIntensity = XmlRel.GetHash(Xml.GetChildInnerText(node, "GroundMediumIntensity"));
            GroundHighIntensity = XmlRel.GetHash(Xml.GetChildInnerText(node, "GroundHighIntensity"));
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { VehiclesMediumIntensity, VehiclesHighIntensity, GroundMediumIntensity, GroundHighIntensity };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151AnimalVocalAnimTriggerItem : IMetaXmlItem
    {
        public byte Animal { get; set; }
        public byte AngryContextsCount { get; set; }
        public Contexts[] AngryContexts { get; set; }
        public byte PlayfulContextsCount { get; set; } 
        public Contexts[] PlayfulContexts { get; set; }
        public struct Contexts : IMetaXmlItem
        {
            public MetaHash Context { get; set; }
            public float Weight { get; set; }
            public Contexts(BinaryReader br)
            {
                Context = br.ReadUInt32();
                Weight = br.ReadSingle();
            }
            public void Write(BinaryWriter bw)
            {
                bw.Write(Context);
                bw.Write(Weight);
            }
            public void WriteXml(StringBuilder sb, int indent)
            {
                RelXml.StringTag(sb, indent, "Context", RelXml.HashString(Context));
                RelXml.ValueTag(sb, indent, "Weight", FloatUtil.ToString(Weight));
            }
            public void ReadXml(XmlNode node)
            {
                Context = XmlRel.GetHash(Xml.GetChildInnerText(node, "Context"));
                Weight = Xml.GetChildFloatAttribute(node, "Weight", "value");
            }
            public override string ToString()
            {
                return Context.ToString() + ": " + FloatUtil.ToString(Weight);
            }
        }
        public Dat151AnimalVocalAnimTriggerItem()
        { }
        public Dat151AnimalVocalAnimTriggerItem(BinaryReader br)
        {
            Animal = br.ReadByte();

            AngryContextsCount = br.ReadByte();
            AngryContexts = new Contexts[AngryContextsCount];
            for (int i = 0; i < AngryContextsCount; i++)
            {
                AngryContexts[i] = new Contexts(br);
            }
            if (AngryContextsCount < 8)
            {
                br.BaseStream.Seek((8 - AngryContextsCount) * 8, SeekOrigin.Current);
            }

            PlayfulContextsCount = br.ReadByte();
            PlayfulContexts = new Contexts[PlayfulContextsCount];
            for (int i = 0; i < PlayfulContextsCount; i++)
            {
                PlayfulContexts[i] = new Contexts(br);
            }
            if (PlayfulContextsCount < 8)
            {
                br.BaseStream.Seek((8 - PlayfulContextsCount) * 8, SeekOrigin.Current);
            }
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Animal);

            bw.Write(AngryContextsCount);
            for (int i = 0; i < AngryContextsCount; i++)
            {
                AngryContexts[i].Write(bw);
            }
            if (AngryContextsCount < 8)
            {
                bw.Write(new byte[(8 - AngryContextsCount) * 8]);
            }

            bw.Write(PlayfulContextsCount);
            for (int i = 0; i < PlayfulContextsCount; i++)
            {
                PlayfulContexts[i].Write(bw);
            }
            if (PlayfulContextsCount < 8)
            {
                bw.Write(new byte[(8 - PlayfulContextsCount) * 8]);
            }
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Animal", Animal.ToString());
            RelXml.WriteItemArray(sb, AngryContexts, indent, "AngryContexts");
            RelXml.WriteItemArray(sb, PlayfulContexts, indent, "PlayfulContexts");
        }
        public void ReadXml(XmlNode node)
        {
            Animal = (byte)Xml.GetChildUIntAttribute(node, "Animal", "value");
            AngryContexts = XmlRel.ReadItemArray<Contexts>(node, "AngryContexts");
            AngryContextsCount = (byte)(AngryContexts?.Length ?? 0);
            PlayfulContexts = XmlRel.ReadItemArray<Contexts>(node, "PlayfulContexts");
            PlayfulContextsCount = (byte)(PlayfulContexts?.Length ?? 0);
        }
        public override string ToString()
        {
            return Animal.ToString() + ": " + AngryContextsCount.ToString() + ", " + PlayfulContextsCount.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151AnimalVocalAnimTrigger : Dat151RelData
    {
        public byte ItemCount { get; set; }
        public Dat151AnimalVocalAnimTriggerItem[] Items { get; set; }

        public Dat151AnimalVocalAnimTrigger(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.AnimalVocalAnimTrigger;
            TypeID = (byte)Type;
        }
        public Dat151AnimalVocalAnimTrigger(RelData d, BinaryReader br) : base(d, br)
        {
            ItemCount = br.ReadByte();
            Items = new Dat151AnimalVocalAnimTriggerItem[ItemCount];
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i] = new Dat151AnimalVocalAnimTriggerItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(ItemCount);
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, Items, indent, "Items");
        }
        public override void ReadXml(XmlNode node)
        {
            Items = XmlRel.ReadItemArray<Dat151AnimalVocalAnimTriggerItem>(node, "Items");
            ItemCount = (byte)(Items?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ScannerVoiceParams : Dat151RelData
    {
        public MetaHash Black { get; set; }
        public MetaHash Blue { get; set; }
        public MetaHash Brown { get; set; }
        public MetaHash Beige { get; set; }
        public MetaHash Graphite { get; set; }
        public MetaHash Green { get; set; }
        public MetaHash Grey { get; set; }
        public MetaHash Orange { get; set; }
        public MetaHash Pink { get; set; }
        public MetaHash Red { get; set; }
        public MetaHash Silver { get; set; }
        public MetaHash White { get; set; }
        public MetaHash Yellow { get; set; }
        // NoPrefix
        public MetaHash MetallicBlack { get; set; }
        public MetaHash MetallicBlue { get; set; }
        public MetaHash MetallicBrown { get; set; }
        public MetaHash MetallicBeige { get; set; }
        public MetaHash MetallicGraphite { get; set; }
        public MetaHash MetallicGreen { get; set; }
        public MetaHash MetallicGrey { get; set; }
        public MetaHash MetallicOrange { get; set; }
        public MetaHash MetallicPink { get; set; }
        public MetaHash MetallicRed { get; set; }
        public MetaHash MetallicSilver { get; set; }
        public MetaHash MetallicWhite { get; set; }
        public MetaHash MetallicYellow { get; set; }
        // Bright
        public MetaHash LightBlack { get; set; }
        public MetaHash LightBlue { get; set; }
        public MetaHash LightBrown { get; set; }
        public MetaHash LightBeige { get; set; }
        public MetaHash LightGraphite { get; set; }
        public MetaHash LightGreen { get; set; }
        public MetaHash LightGrey { get; set; }
        public MetaHash LightOrange { get; set; }
        public MetaHash LightPink { get; set; }
        public MetaHash LightRed { get; set; }
        public MetaHash LightSilver { get; set; }
        public MetaHash LightWhite { get; set; }
        public MetaHash LightYellow { get; set; }
        // Light
        public MetaHash DarkBlack { get; set; }
        public MetaHash DarkBlue { get; set; }
        public MetaHash DarkBrown { get; set; }
        public MetaHash DarkBeige { get; set; }
        public MetaHash DarkGraphite { get; set; }
        public MetaHash DarkGreen { get; set; }
        public MetaHash DarkGrey { get; set; }
        public MetaHash DarkOrange { get; set; }
        public MetaHash DarkPink { get; set; }
        public MetaHash DarkRed { get; set; }
        public MetaHash DarkSilver { get; set; }
        public MetaHash DarkWhite { get; set; }
        public MetaHash DarkYellow { get; set; }
        // Dark
        public MetaHash Battered { get; set; }
        public MetaHash BeatUp { get; set; }
        public MetaHash Chopped { get; set; }
        public MetaHash Custom { get; set; }
        public MetaHash Customized { get; set; }
        public MetaHash Damaged { get; set; }
        public MetaHash Dented { get; set; }
        public MetaHash Dirty { get; set; }
        public MetaHash Distressed { get; set; }
        public MetaHash Mint { get; set; }
        public MetaHash Modified { get; set; }
        public MetaHash RunDown1 { get; set; }
        public MetaHash RunDown2 { get; set; }
        public MetaHash Rusty { get; set; }
        // ExtraPrefix

        public Dat151ScannerVoiceParams(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ScannerVoiceParams;
            TypeID = (byte)Type;
        }
        public Dat151ScannerVoiceParams(RelData d, BinaryReader br) : base(d, br)
        {
            Black = br.ReadUInt32();
            Blue = br.ReadUInt32();
            Brown = br.ReadUInt32();
            Beige = br.ReadUInt32();
            Graphite = br.ReadUInt32();
            Green = br.ReadUInt32();
            Grey = br.ReadUInt32();
            Orange = br.ReadUInt32();
            Pink = br.ReadUInt32();
            Red = br.ReadUInt32();
            Silver = br.ReadUInt32();
            White = br.ReadUInt32();
            Yellow = br.ReadUInt32();
            MetallicBlack = br.ReadUInt32();
            MetallicBlue = br.ReadUInt32();
            MetallicBrown = br.ReadUInt32();
            MetallicBeige = br.ReadUInt32();
            MetallicGraphite = br.ReadUInt32();
            MetallicGreen = br.ReadUInt32();
            MetallicGrey = br.ReadUInt32();
            MetallicOrange = br.ReadUInt32();
            MetallicPink = br.ReadUInt32();
            MetallicRed = br.ReadUInt32();
            MetallicSilver = br.ReadUInt32();
            MetallicWhite = br.ReadUInt32();
            MetallicYellow = br.ReadUInt32();
            LightBlack = br.ReadUInt32();
            LightBlue = br.ReadUInt32();
            LightBrown = br.ReadUInt32();
            LightBeige = br.ReadUInt32();
            LightGraphite = br.ReadUInt32();
            LightGreen = br.ReadUInt32();
            LightGrey = br.ReadUInt32();
            LightOrange = br.ReadUInt32();
            LightPink = br.ReadUInt32();
            LightRed = br.ReadUInt32();
            LightSilver = br.ReadUInt32();
            LightWhite = br.ReadUInt32();
            LightYellow = br.ReadUInt32();
            DarkBlack = br.ReadUInt32();
            DarkBlue = br.ReadUInt32();
            DarkBrown = br.ReadUInt32();
            DarkBeige = br.ReadUInt32();
            DarkGraphite = br.ReadUInt32();
            DarkGreen = br.ReadUInt32();
            DarkGrey = br.ReadUInt32();
            DarkOrange = br.ReadUInt32();
            DarkPink = br.ReadUInt32();
            DarkRed = br.ReadUInt32();
            DarkSilver = br.ReadUInt32();
            DarkWhite = br.ReadUInt32();
            DarkYellow = br.ReadUInt32();
            Battered = br.ReadUInt32();
            BeatUp = br.ReadUInt32();
            Chopped = br.ReadUInt32();
            Custom = br.ReadUInt32();
            Customized = br.ReadUInt32();
            Damaged = br.ReadUInt32();
            Dented = br.ReadUInt32();
            Dirty = br.ReadUInt32();
            Distressed = br.ReadUInt32();
            Mint = br.ReadUInt32();
            Modified = br.ReadUInt32();
            RunDown1 = br.ReadUInt32();
            RunDown2 = br.ReadUInt32();
            Rusty = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Black);
            bw.Write(Blue);
            bw.Write(Brown);
            bw.Write(Beige);
            bw.Write(Graphite);
            bw.Write(Green);
            bw.Write(Grey);
            bw.Write(Orange);
            bw.Write(Pink);
            bw.Write(Red);
            bw.Write(Silver);
            bw.Write(White);
            bw.Write(Yellow);
            bw.Write(MetallicBlack);
            bw.Write(MetallicBlue);
            bw.Write(MetallicBrown);
            bw.Write(MetallicBeige);
            bw.Write(MetallicGraphite);
            bw.Write(MetallicGreen);
            bw.Write(MetallicGrey);
            bw.Write(MetallicOrange);
            bw.Write(MetallicPink);
            bw.Write(MetallicRed);
            bw.Write(MetallicSilver);
            bw.Write(MetallicWhite);
            bw.Write(MetallicYellow);
            bw.Write(LightBlack);
            bw.Write(LightBlue);
            bw.Write(LightBrown);
            bw.Write(LightBeige);
            bw.Write(LightGraphite);
            bw.Write(LightGreen);
            bw.Write(LightGrey);
            bw.Write(LightOrange);
            bw.Write(LightPink);
            bw.Write(LightRed);
            bw.Write(LightSilver);
            bw.Write(LightWhite);
            bw.Write(LightYellow);
            bw.Write(DarkBlack);
            bw.Write(DarkBlue);
            bw.Write(DarkBrown);
            bw.Write(DarkBeige);
            bw.Write(DarkGraphite);
            bw.Write(DarkGreen);
            bw.Write(DarkGrey);
            bw.Write(DarkOrange);
            bw.Write(DarkPink);
            bw.Write(DarkRed);
            bw.Write(DarkSilver);
            bw.Write(DarkWhite);
            bw.Write(DarkYellow);
            bw.Write(Battered);
            bw.Write(BeatUp);
            bw.Write(Chopped);
            bw.Write(Custom);
            bw.Write(Customized);
            bw.Write(Damaged);
            bw.Write(Dented);
            bw.Write(Dirty);
            bw.Write(Distressed);
            bw.Write(Mint);
            bw.Write(Modified);
            bw.Write(RunDown1);
            bw.Write(RunDown2);
            bw.Write(Rusty);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Black", RelXml.HashString(Black));
            RelXml.StringTag(sb, indent, "Blue", RelXml.HashString(Blue));
            RelXml.StringTag(sb, indent, "Brown", RelXml.HashString(Brown));
            RelXml.StringTag(sb, indent, "Beige", RelXml.HashString(Beige));
            RelXml.StringTag(sb, indent, "Graphite", RelXml.HashString(Graphite));
            RelXml.StringTag(sb, indent, "Green", RelXml.HashString(Green));
            RelXml.StringTag(sb, indent, "Grey", RelXml.HashString(Grey));
            RelXml.StringTag(sb, indent, "Orange", RelXml.HashString(Orange));
            RelXml.StringTag(sb, indent, "Pink", RelXml.HashString(Pink));
            RelXml.StringTag(sb, indent, "Red", RelXml.HashString(Red));
            RelXml.StringTag(sb, indent, "Silver", RelXml.HashString(Silver));
            RelXml.StringTag(sb, indent, "White", RelXml.HashString(White));
            RelXml.StringTag(sb, indent, "Yellow", RelXml.HashString(Yellow));
            RelXml.StringTag(sb, indent, "MetallicBlack", RelXml.HashString(MetallicBlack));
            RelXml.StringTag(sb, indent, "MetallicBlue", RelXml.HashString(MetallicBlue));
            RelXml.StringTag(sb, indent, "MetallicBrown", RelXml.HashString(MetallicBrown));
            RelXml.StringTag(sb, indent, "MetallicBeige", RelXml.HashString(MetallicBeige));
            RelXml.StringTag(sb, indent, "MetallicGraphite", RelXml.HashString(MetallicGraphite));
            RelXml.StringTag(sb, indent, "MetallicGreen", RelXml.HashString(MetallicGreen));
            RelXml.StringTag(sb, indent, "MetallicGrey", RelXml.HashString(MetallicGrey));
            RelXml.StringTag(sb, indent, "MetallicOrange", RelXml.HashString(MetallicOrange));
            RelXml.StringTag(sb, indent, "MetallicPink", RelXml.HashString(MetallicPink));
            RelXml.StringTag(sb, indent, "MetallicRed", RelXml.HashString(MetallicRed));
            RelXml.StringTag(sb, indent, "MetallicSilver", RelXml.HashString(MetallicSilver));
            RelXml.StringTag(sb, indent, "MetallicWhite", RelXml.HashString(MetallicWhite));
            RelXml.StringTag(sb, indent, "MetallicYellow", RelXml.HashString(MetallicYellow));
            RelXml.StringTag(sb, indent, "LightBlack", RelXml.HashString(LightBlack));
            RelXml.StringTag(sb, indent, "LightBlue", RelXml.HashString(LightBlue));
            RelXml.StringTag(sb, indent, "LightBrown", RelXml.HashString(LightBrown));
            RelXml.StringTag(sb, indent, "LightBeige", RelXml.HashString(LightBeige));
            RelXml.StringTag(sb, indent, "LightGraphite", RelXml.HashString(LightGraphite));
            RelXml.StringTag(sb, indent, "LightGreen", RelXml.HashString(LightGreen));
            RelXml.StringTag(sb, indent, "LightGrey", RelXml.HashString(LightGrey));
            RelXml.StringTag(sb, indent, "LightOrange", RelXml.HashString(LightOrange));
            RelXml.StringTag(sb, indent, "LightPink", RelXml.HashString(LightPink));
            RelXml.StringTag(sb, indent, "LightRed", RelXml.HashString(LightRed));
            RelXml.StringTag(sb, indent, "LightSilver", RelXml.HashString(LightSilver));
            RelXml.StringTag(sb, indent, "LightWhite", RelXml.HashString(LightWhite));
            RelXml.StringTag(sb, indent, "LightYellow", RelXml.HashString(LightYellow));
            RelXml.StringTag(sb, indent, "DarkBlack", RelXml.HashString(DarkBlack));
            RelXml.StringTag(sb, indent, "DarkBlue", RelXml.HashString(DarkBlue));
            RelXml.StringTag(sb, indent, "DarkBrown", RelXml.HashString(DarkBrown));
            RelXml.StringTag(sb, indent, "DarkBeige", RelXml.HashString(DarkBeige));
            RelXml.StringTag(sb, indent, "DarkGraphite", RelXml.HashString(DarkGraphite));
            RelXml.StringTag(sb, indent, "DarkGreen", RelXml.HashString(DarkGreen));
            RelXml.StringTag(sb, indent, "DarkGrey", RelXml.HashString(DarkGrey));
            RelXml.StringTag(sb, indent, "DarkOrange", RelXml.HashString(DarkOrange));
            RelXml.StringTag(sb, indent, "DarkPink", RelXml.HashString(DarkPink));
            RelXml.StringTag(sb, indent, "DarkRed", RelXml.HashString(DarkRed));
            RelXml.StringTag(sb, indent, "DarkSilver", RelXml.HashString(DarkSilver));
            RelXml.StringTag(sb, indent, "DarkWhite", RelXml.HashString(DarkWhite));
            RelXml.StringTag(sb, indent, "DarkYellow", RelXml.HashString(DarkYellow));
            RelXml.StringTag(sb, indent, "Battered", RelXml.HashString(Battered));
            RelXml.StringTag(sb, indent, "BeatUp", RelXml.HashString(BeatUp));
            RelXml.StringTag(sb, indent, "Chopped", RelXml.HashString(Chopped));
            RelXml.StringTag(sb, indent, "Custom", RelXml.HashString(Custom));
            RelXml.StringTag(sb, indent, "Customized", RelXml.HashString(Customized));
            RelXml.StringTag(sb, indent, "Damaged", RelXml.HashString(Damaged));
            RelXml.StringTag(sb, indent, "Dented", RelXml.HashString(Dented));
            RelXml.StringTag(sb, indent, "Dirty", RelXml.HashString(Dirty));
            RelXml.StringTag(sb, indent, "Distressed", RelXml.HashString(Distressed));
            RelXml.StringTag(sb, indent, "Mint", RelXml.HashString(Mint));
            RelXml.StringTag(sb, indent, "Modified", RelXml.HashString(Modified));
            RelXml.StringTag(sb, indent, "RunDown1", RelXml.HashString(RunDown1));
            RelXml.StringTag(sb, indent, "RunDown2", RelXml.HashString(RunDown2));
            RelXml.StringTag(sb, indent, "Rusty", RelXml.HashString(Rusty));
        }
        public override void ReadXml(XmlNode node)
        {
            Black = XmlRel.GetHash(Xml.GetChildInnerText(node, "Black"));
            Blue = XmlRel.GetHash(Xml.GetChildInnerText(node, "Blue"));
            Brown = XmlRel.GetHash(Xml.GetChildInnerText(node, "Brown"));
            Beige = XmlRel.GetHash(Xml.GetChildInnerText(node, "Beige"));
            Graphite = XmlRel.GetHash(Xml.GetChildInnerText(node, "Graphite"));
            Green = XmlRel.GetHash(Xml.GetChildInnerText(node, "Green"));
            Grey = XmlRel.GetHash(Xml.GetChildInnerText(node, "Grey"));
            Orange = XmlRel.GetHash(Xml.GetChildInnerText(node, "Orange"));
            Pink = XmlRel.GetHash(Xml.GetChildInnerText(node, "Pink"));
            Red = XmlRel.GetHash(Xml.GetChildInnerText(node, "Red"));
            Silver = XmlRel.GetHash(Xml.GetChildInnerText(node, "Silver"));
            White = XmlRel.GetHash(Xml.GetChildInnerText(node, "White"));
            Yellow = XmlRel.GetHash(Xml.GetChildInnerText(node, "Yellow"));
            MetallicBlack = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetallicBlack"));
            MetallicBlue = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetallicBlue"));
            MetallicBrown = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetallicBrown"));
            MetallicBeige = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetallicBeige"));
            MetallicGraphite = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetallicGraphite"));
            MetallicGreen = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetallicGreen"));
            MetallicGrey = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetallicGrey"));
            MetallicOrange = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetallicOrange"));
            MetallicPink = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetallicPink"));
            MetallicRed = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetallicRed"));
            MetallicSilver = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetallicSilver"));
            MetallicWhite = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetallicWhite"));
            MetallicYellow = XmlRel.GetHash(Xml.GetChildInnerText(node, "MetallicYellow"));
            LightBlack = XmlRel.GetHash(Xml.GetChildInnerText(node, "LightBlack"));
            LightBlue = XmlRel.GetHash(Xml.GetChildInnerText(node, "LightBlue"));
            LightBrown = XmlRel.GetHash(Xml.GetChildInnerText(node, "LightBrown"));
            LightBeige = XmlRel.GetHash(Xml.GetChildInnerText(node, "LightBeige"));
            LightGraphite = XmlRel.GetHash(Xml.GetChildInnerText(node, "LightGraphite"));
            LightGreen = XmlRel.GetHash(Xml.GetChildInnerText(node, "LightGreen"));
            LightGrey = XmlRel.GetHash(Xml.GetChildInnerText(node, "LightGrey"));
            LightOrange = XmlRel.GetHash(Xml.GetChildInnerText(node, "LightOrange"));
            LightPink = XmlRel.GetHash(Xml.GetChildInnerText(node, "LightPink"));
            LightRed = XmlRel.GetHash(Xml.GetChildInnerText(node, "LightRed"));
            LightSilver = XmlRel.GetHash(Xml.GetChildInnerText(node, "LightSilver"));
            LightWhite = XmlRel.GetHash(Xml.GetChildInnerText(node, "LightWhite"));
            LightYellow = XmlRel.GetHash(Xml.GetChildInnerText(node, "LightYellow"));
            DarkBlack = XmlRel.GetHash(Xml.GetChildInnerText(node, "DarkBlack"));
            DarkBlue = XmlRel.GetHash(Xml.GetChildInnerText(node, "DarkBlue"));
            DarkBrown = XmlRel.GetHash(Xml.GetChildInnerText(node, "DarkBrown"));
            DarkBeige = XmlRel.GetHash(Xml.GetChildInnerText(node, "DarkBeige"));
            DarkGraphite = XmlRel.GetHash(Xml.GetChildInnerText(node, "DarkGraphite"));
            DarkGreen = XmlRel.GetHash(Xml.GetChildInnerText(node, "DarkGreen"));
            DarkGrey = XmlRel.GetHash(Xml.GetChildInnerText(node, "DarkGrey"));
            DarkOrange = XmlRel.GetHash(Xml.GetChildInnerText(node, "DarkOrange"));
            DarkPink = XmlRel.GetHash(Xml.GetChildInnerText(node, "DarkPink"));
            DarkRed = XmlRel.GetHash(Xml.GetChildInnerText(node, "DarkRed"));
            DarkSilver = XmlRel.GetHash(Xml.GetChildInnerText(node, "DarkSilver"));
            DarkWhite = XmlRel.GetHash(Xml.GetChildInnerText(node, "DarkWhite"));
            DarkYellow = XmlRel.GetHash(Xml.GetChildInnerText(node, "DarkYellow"));
            Battered = XmlRel.GetHash(Xml.GetChildInnerText(node, "Battered"));
            BeatUp = XmlRel.GetHash(Xml.GetChildInnerText(node, "BeatUp"));
            Chopped = XmlRel.GetHash(Xml.GetChildInnerText(node, "Chopped"));
            Custom = XmlRel.GetHash(Xml.GetChildInnerText(node, "Custom"));
            Customized = XmlRel.GetHash(Xml.GetChildInnerText(node, "Customized"));
            Damaged = XmlRel.GetHash(Xml.GetChildInnerText(node, "Damaged"));
            Dented = XmlRel.GetHash(Xml.GetChildInnerText(node, "Dented"));
            Dirty = XmlRel.GetHash(Xml.GetChildInnerText(node, "Dirty"));
            Distressed = XmlRel.GetHash(Xml.GetChildInnerText(node, "Distressed"));
            Mint = XmlRel.GetHash(Xml.GetChildInnerText(node, "Mint"));
            Modified = XmlRel.GetHash(Xml.GetChildInnerText(node, "Modified"));
            RunDown1 = XmlRel.GetHash(Xml.GetChildInnerText(node, "RunDown1"));
            RunDown2 = XmlRel.GetHash(Xml.GetChildInnerText(node, "RunDown2"));
            Rusty = XmlRel.GetHash(Xml.GetChildInnerText(node, "Rusty"));
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { Black,Blue,Brown,Beige,Graphite,Green,Grey,Orange,Pink,Red,Silver,White,Yellow,
                MetallicBlack,MetallicBlue,MetallicBrown,MetallicBeige,MetallicGraphite,MetallicGreen,MetallicGrey,MetallicOrange,MetallicPink,MetallicRed,MetallicSilver,MetallicWhite,MetallicYellow,
                LightBlack,LightBlue,LightBrown,LightBeige,LightGraphite,LightGreen,LightGrey,LightOrange,LightPink,LightRed,LightSilver,LightWhite,LightYellow,
                DarkBlack,DarkBlue,DarkBrown,DarkBeige,DarkGraphite,DarkGreen,DarkGrey,DarkOrange,DarkPink,DarkRed,DarkSilver,DarkWhite,DarkYellow,
                Battered,BeatUp,Chopped,Custom,Customized,Damaged,Dented,Dirty,Distressed,Mint,Modified,RunDown1,RunDown2,Rusty };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151AudioRoadInfo : Dat151RelData
    {
        public MetaHash RoadName { get; set; }
        public float TyreBumpDistance { get; set; }

        public Dat151AudioRoadInfo(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.AudioRoadInfo;
            TypeID = (byte)Type;
        }
        public Dat151AudioRoadInfo(RelData d, BinaryReader br) : base(d, br)
        {
            RoadName = br.ReadUInt32();
            TyreBumpDistance = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(RoadName);
            bw.Write(TyreBumpDistance);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "RoadName", RelXml.HashString(RoadName));
            RelXml.ValueTag(sb, indent, "TyreBumpDistance", FloatUtil.ToString(TyreBumpDistance));
        }
        public override void ReadXml(XmlNode node)
        {
            RoadName = XmlRel.GetHash(Xml.GetChildInnerText(node, "RoadName"));
            TyreBumpDistance = Xml.GetChildFloatAttribute(node, "TyreBumpDistance", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151MicrophoneItem : IMetaXmlItem
    {
        public float ListenerContribution { get; set; }
        public float RearAttenuationFrontConeAngle { get; set; }
        public float RearAttenuationRearConeAngle { get; set; }
        public float CloseRearAttenuation { get; set; }
        public float FarRearAttenuation { get; set; }
        public float RollOff { get; set; }
        public int RearAttenuationType { get; set; }
        public float MicLength { get; set; }
        public float MicToPlayerLocalEnvironmentRatio { get; set; }

        public Dat151MicrophoneItem()
        { }
        public Dat151MicrophoneItem(BinaryReader br)
        {
            ListenerContribution = br.ReadSingle();
            RearAttenuationFrontConeAngle = br.ReadSingle();
            RearAttenuationRearConeAngle = br.ReadSingle();
            CloseRearAttenuation = br.ReadSingle();
            FarRearAttenuation = br.ReadSingle();
            RollOff = br.ReadSingle();
            RearAttenuationType = br.ReadInt32();
            MicLength = br.ReadSingle();
            MicToPlayerLocalEnvironmentRatio = br.ReadSingle();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(ListenerContribution);
            bw.Write(RearAttenuationFrontConeAngle);
            bw.Write(RearAttenuationRearConeAngle);
            bw.Write(CloseRearAttenuation);
            bw.Write(FarRearAttenuation);
            bw.Write(RollOff);
            bw.Write(RearAttenuationType);
            bw.Write(MicLength);
            bw.Write(MicToPlayerLocalEnvironmentRatio);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "ListenerContribution", FloatUtil.ToString(ListenerContribution));
            RelXml.ValueTag(sb, indent, "RearAttenuationFrontConeAngle", FloatUtil.ToString(RearAttenuationFrontConeAngle));
            RelXml.ValueTag(sb, indent, "RearAttenuationRearConeAngle", FloatUtil.ToString(RearAttenuationRearConeAngle));
            RelXml.ValueTag(sb, indent, "CloseRearAttenuation", FloatUtil.ToString(CloseRearAttenuation));
            RelXml.ValueTag(sb, indent, "FarRearAttenuation", FloatUtil.ToString(FarRearAttenuation));
            RelXml.ValueTag(sb, indent, "RollOff", FloatUtil.ToString(RollOff));
            RelXml.ValueTag(sb, indent, "RearAttenuationType", RearAttenuationType.ToString());
            RelXml.ValueTag(sb, indent, "MicLength", FloatUtil.ToString(MicLength));
            RelXml.ValueTag(sb, indent, "MicToPlayerLocalEnvironmentRatio", FloatUtil.ToString(MicToPlayerLocalEnvironmentRatio));
        }
        public void ReadXml(XmlNode node)
        {
            ListenerContribution = Xml.GetChildFloatAttribute(node, "ListenerContribution", "value");
            RearAttenuationFrontConeAngle = Xml.GetChildFloatAttribute(node, "RearAttenuationFrontConeAngle", "value");
            RearAttenuationRearConeAngle = Xml.GetChildFloatAttribute(node, "RearAttenuationRearConeAngle", "value");
            CloseRearAttenuation = Xml.GetChildFloatAttribute(node, "CloseRearAttenuation", "value");
            FarRearAttenuation = Xml.GetChildFloatAttribute(node, "FarRearAttenuation", "value");
            RollOff = Xml.GetChildFloatAttribute(node, "RollOff", "value");
            RearAttenuationType = Xml.GetChildIntAttribute(node, "RearAttenuationType", "value");
            MicLength = Xml.GetChildFloatAttribute(node, "MicLength", "value");
            MicToPlayerLocalEnvironmentRatio = Xml.GetChildFloatAttribute(node, "MicToPlayerLocalEnvironmentRatio", "value");
        }
        public override string ToString()
        {
            return string.Format("{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}", ListenerContribution, RearAttenuationFrontConeAngle, RearAttenuationRearConeAngle, CloseRearAttenuation, FarRearAttenuation, RollOff, RearAttenuationType, MicLength, MicToPlayerLocalEnvironmentRatio);
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151MicrophoneSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public byte MicType { get; set; }
        public byte MicrophonesCount { get; set; }
        public byte padding00 { get; set; }
        public byte padding01 { get; set; }
        public Dat151MicrophoneItem[] Microphones { get; set; }

        public Dat151MicrophoneSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.MicrophoneSettings;
            TypeID = (byte)Type;
        }
        public Dat151MicrophoneSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            MicType = br.ReadByte();

            MicrophonesCount = br.ReadByte();
            padding00 = br.ReadByte();
            padding01 = br.ReadByte();
            Microphones = new Dat151MicrophoneItem[MicrophonesCount];
            for (int i = 0; i < MicrophonesCount; i++)
            {
                Microphones[i] = new Dat151MicrophoneItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(MicType);

            bw.Write(MicrophonesCount);
            bw.Write(padding00);
            bw.Write(padding01);
            for (int i = 0; i < MicrophonesCount; i++)
            {
                Microphones[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MicType", MicType.ToString());
            RelXml.WriteItemArray(sb, Microphones, indent, "Microphones");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MicType = (byte)Xml.GetChildIntAttribute(node, "MicType", "value");
            Microphones = XmlRel.ReadItemArray<Dat151MicrophoneItem>(node, "Microphones");
            MicrophonesCount = (byte)(Microphones?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151CarRecordingAudioSettings : Dat151RelData
    {
        public MetaHash Group { get; set; }
        public int VehicleModelId { get; set; }
        public int ItemCount { get; set; }
        public Dat151CarRecordingAudioSettingsItem[] Items { get; set; }
        public int ItemCount2 { get; set; }
        public Dat151CarRecordingAudioSettingsItem2[] Items2 { get; set; }

        public Dat151CarRecordingAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.CarRecordingAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151CarRecordingAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Group = br.ReadUInt32();
            VehicleModelId = br.ReadInt32();
            ItemCount = br.ReadInt32();
            Items = new Dat151CarRecordingAudioSettingsItem[ItemCount];
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i] = new Dat151CarRecordingAudioSettingsItem(br);
            }
            if (ItemCount != 0)
            {
                ItemCount2 = br.ReadInt32();
                Items2 = new Dat151CarRecordingAudioSettingsItem2[ItemCount2];
                for (int i = 0; i < ItemCount2; i++)
                {
                    Items2[i] = new Dat151CarRecordingAudioSettingsItem2(br);
                }
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Group);
            bw.Write(VehicleModelId);
            bw.Write(ItemCount);
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i].Write(bw);
            }
            if (ItemCount > 0)
            {
                bw.Write(ItemCount2);
                for (int i = 0; i < ItemCount2; i++)
                {
                    Items2[i].Write(bw);
                }
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Group", RelXml.HashString(Group));
            RelXml.ValueTag(sb, indent, "VehicleModelId", VehicleModelId.ToString());
            RelXml.WriteItemArray(sb, Items, indent, "Items");
            if (ItemCount > 0)
            {
                RelXml.WriteItemArray(sb, Items2, indent, "Items2");
            }
        }
        public override void ReadXml(XmlNode node)
        {
            Group = XmlRel.GetHash(Xml.GetChildInnerText(node, "Group"));
            VehicleModelId = Xml.GetChildIntAttribute(node, "VehicleModelId", "value");
            Items = XmlRel.ReadItemArray<Dat151CarRecordingAudioSettingsItem>(node, "Items");
            ItemCount = (Items?.Length ?? 0);
            if (ItemCount > 0)
            {
                Items2 = XmlRel.ReadItemArray<Dat151CarRecordingAudioSettingsItem2>(node, "Items2");
                ItemCount2 = (Items2?.Length ?? 0);
            }
            else
            {
                Items2 = null;
                ItemCount2 = 0;
            }
        }
        public override MetaHash[] GetMixerHashes()
        {
            var list = new List<MetaHash>();
            list.Add(Group);
            if (Items != null)
            {
                foreach (var item in Items)
                {
                    list.Add(item.OneShotScene);
                }
            }
            if (Items2 != null)
            {
                foreach (var item in Items2)
                {
                    list.Add(item.Scene);
                }
            }
            return list.ToArray();
        }
        public override MetaHash[] GetSoundHashes()
        {
            var list = new List<MetaHash>();
            if (Items != null)
            {
                foreach (var item in Items)
                {
                    list.Add(item.Sound);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public class Dat151CarRecordingAudioSettingsItem : IMetaXmlItem
    {
        public float Time { get; set; }
        public MetaHash Sound { get; set; }
        public MetaHash OneShotScene { get; set; }

        public Dat151CarRecordingAudioSettingsItem()
        { }
        public Dat151CarRecordingAudioSettingsItem(BinaryReader br)
        {
            Time = br.ReadSingle();
            Sound = br.ReadUInt32();
            OneShotScene = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Time);
            bw.Write(Sound);
            bw.Write(OneShotScene);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Time", FloatUtil.ToString(Time));
            RelXml.StringTag(sb, indent, "Sound", RelXml.HashString(Sound));
            RelXml.StringTag(sb, indent, "OneShotScene", RelXml.HashString(OneShotScene));
        }
        public void ReadXml(XmlNode node)
        {
            Time = Xml.GetChildFloatAttribute(node, "Time", "value");
            Sound = XmlRel.GetHash(Xml.GetChildInnerText(node, "Sound"));
            OneShotScene = XmlRel.GetHash(Xml.GetChildInnerText(node, "OneShotScene"));
        }
        public override string ToString()
        {
            return Time.ToString() + ", " + Sound.ToString() + ", " + OneShotScene.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat151CarRecordingAudioSettingsItem2 : IMetaXmlItem
    {
        public MetaHash Scene { get; set; }
        public float StartTime { get; set; }
        public float EndTime { get; set; }

        public Dat151CarRecordingAudioSettingsItem2()
        { }
        public Dat151CarRecordingAudioSettingsItem2(BinaryReader br)
        {
            Scene = br.ReadUInt32();
            StartTime = br.ReadSingle();
            EndTime = br.ReadSingle();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Scene);
            bw.Write(StartTime);
            bw.Write(EndTime);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Scene", RelXml.HashString(Scene));
            RelXml.ValueTag(sb, indent, "StartTime", FloatUtil.ToString(StartTime));
            RelXml.ValueTag(sb, indent, "EndTime", FloatUtil.ToString(EndTime));
        }
        public void ReadXml(XmlNode node)
        {
            Scene = XmlRel.GetHash(Xml.GetChildInnerText(node, "Scene"));
            StartTime = Xml.GetChildFloatAttribute(node, "StartTime", "value");
            EndTime = Xml.GetChildFloatAttribute(node, "EndTime", "value");
        }
        public override string ToString()
        {
            return Scene.ToString() + ", " + StartTime.ToString() + ", " + EndTime.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151AnimalFootstepSettings : Dat151RelData
    {
        public MetaHash WalkAndTrot { get; set; }
        public MetaHash Gallop1 { get; set; }
        public MetaHash Gallop2 { get; set; }
        public MetaHash Scuff { get; set; }
        public MetaHash Jump { get; set; }
        public MetaHash Land { get; set; }
        public MetaHash LandHard { get; set; }
        public MetaHash Clumsy { get; set; }
        public MetaHash SlideLoop { get; set; }
        public int AudioEventLoudness { get; set; }

        public Dat151AnimalFootstepSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.AnimalFootstepSettings;
            TypeID = (byte)Type;
        }
        public Dat151AnimalFootstepSettings(RelData d, BinaryReader br) : base(d, br)
        {
            WalkAndTrot = br.ReadUInt32();
            Gallop1 = br.ReadUInt32();
            Gallop2 = br.ReadUInt32();
            Scuff = br.ReadUInt32();
            Jump = br.ReadUInt32();
            Land = br.ReadUInt32();
            LandHard = br.ReadUInt32();
            Clumsy = br.ReadUInt32();
            SlideLoop = br.ReadUInt32();
            AudioEventLoudness = br.ReadInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(WalkAndTrot);
            bw.Write(Gallop1);
            bw.Write(Gallop2);
            bw.Write(Scuff);
            bw.Write(Jump);
            bw.Write(Land);
            bw.Write(LandHard);
            bw.Write(Clumsy);
            bw.Write(SlideLoop);
            bw.Write(AudioEventLoudness);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "WalkAndTrot", RelXml.HashString(WalkAndTrot));
            RelXml.StringTag(sb, indent, "Gallop1", RelXml.HashString(Gallop1));
            RelXml.StringTag(sb, indent, "Gallop2", RelXml.HashString(Gallop2));
            RelXml.StringTag(sb, indent, "Scuff", RelXml.HashString(Scuff));
            RelXml.StringTag(sb, indent, "Jump", RelXml.HashString(Jump));
            RelXml.StringTag(sb, indent, "Land", RelXml.HashString(Land));
            RelXml.StringTag(sb, indent, "LandHard", RelXml.HashString(LandHard));
            RelXml.StringTag(sb, indent, "Clumsy", RelXml.HashString(Clumsy));
            RelXml.StringTag(sb, indent, "SlideLoop", RelXml.HashString(SlideLoop));
            RelXml.ValueTag(sb, indent, "AudioEventLoudness", AudioEventLoudness.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            WalkAndTrot = XmlRel.GetHash(Xml.GetChildInnerText(node, "WalkAndTrot"));
            Gallop1 = XmlRel.GetHash(Xml.GetChildInnerText(node, "Gallop1"));
            Gallop2 = XmlRel.GetHash(Xml.GetChildInnerText(node, "Gallop2"));
            Scuff = XmlRel.GetHash(Xml.GetChildInnerText(node, "Scuff"));
            Jump = XmlRel.GetHash(Xml.GetChildInnerText(node, "Jump"));
            Land = XmlRel.GetHash(Xml.GetChildInnerText(node, "Land"));
            LandHard = XmlRel.GetHash(Xml.GetChildInnerText(node, "LandHard"));
            Clumsy = XmlRel.GetHash(Xml.GetChildInnerText(node, "Clumsy"));
            SlideLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlideLoop"));
            AudioEventLoudness = Xml.GetChildIntAttribute(node, "AudioEventLoudness", "value");
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { WalkAndTrot, Gallop1, Gallop2, Scuff, Jump, Land, LandHard, Clumsy, SlideLoop };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ClothAudioSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public MetaHash ImpactSound { get; set; }
        public MetaHash WalkSound { get; set; }
        public MetaHash RunSound { get; set; }
        public MetaHash SprintSound { get; set; }
        public MetaHash IntoCoverSound { get; set; }
        public MetaHash OutOfCoverSound { get; set; }
        public MetaHash WindSound { get; set; }
        public float Intensity { get; set; }
        public MetaHash PlayerVersion { get; set; }
        public MetaHash BulletImpacts { get; set; }
        public MetaHash PedRollSound { get; set; }
        public MetaHash ScrapeMaterialSettings { get; set; }
        public MetaHash JumpLandSound { get; set; }
        public MetaHash MeleeSwingSound { get; set; }

        public Dat151ClothAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ClothAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151ClothAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            ImpactSound = br.ReadUInt32();
            WalkSound = br.ReadUInt32();
            RunSound = br.ReadUInt32();
            SprintSound = br.ReadUInt32();
            IntoCoverSound = br.ReadUInt32();
            OutOfCoverSound = br.ReadUInt32();
            WindSound = br.ReadUInt32();
            Intensity = br.ReadSingle();
            PlayerVersion = br.ReadUInt32();
            BulletImpacts = br.ReadUInt32();
            PedRollSound = br.ReadUInt32();
            ScrapeMaterialSettings = br.ReadUInt32();
            JumpLandSound = br.ReadUInt32();
            MeleeSwingSound = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(ImpactSound);
            bw.Write(WalkSound);
            bw.Write(RunSound);
            bw.Write(SprintSound);
            bw.Write(IntoCoverSound);
            bw.Write(OutOfCoverSound);
            bw.Write(WindSound);
            bw.Write(Intensity);
            bw.Write(PlayerVersion);
            bw.Write(BulletImpacts);
            bw.Write(PedRollSound);
            bw.Write(ScrapeMaterialSettings);
            bw.Write(JumpLandSound);
            bw.Write(MeleeSwingSound);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "ImpactSound", RelXml.HashString(ImpactSound));
            RelXml.StringTag(sb, indent, "WalkSound", RelXml.HashString(WalkSound));
            RelXml.StringTag(sb, indent, "RunSound", RelXml.HashString(RunSound));
            RelXml.StringTag(sb, indent, "SprintSound", RelXml.HashString(SprintSound));
            RelXml.StringTag(sb, indent, "IntoCoverSound", RelXml.HashString(IntoCoverSound));
            RelXml.StringTag(sb, indent, "OutOfCoverSound", RelXml.HashString(OutOfCoverSound));
            RelXml.StringTag(sb, indent, "WindSound", RelXml.HashString(WindSound));
            RelXml.ValueTag(sb, indent, "Intensity", FloatUtil.ToString(Intensity));
            RelXml.StringTag(sb, indent, "PlayerVersion", RelXml.HashString(PlayerVersion));
            RelXml.StringTag(sb, indent, "BulletImpacts", RelXml.HashString(BulletImpacts));
            RelXml.StringTag(sb, indent, "PedRollSound", RelXml.HashString(PedRollSound));
            RelXml.StringTag(sb, indent, "ScrapeMaterialSettings", RelXml.HashString(ScrapeMaterialSettings));
            RelXml.StringTag(sb, indent, "JumpLandSound", RelXml.HashString(JumpLandSound));
            RelXml.StringTag(sb, indent, "MeleeSwingSound", RelXml.HashString(MeleeSwingSound));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            ImpactSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ImpactSound"));
            WalkSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "WalkSound"));
            RunSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "RunSound"));
            SprintSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SprintSound"));
            IntoCoverSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "IntoCoverSound"));
            OutOfCoverSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "OutOfCoverSound"));
            WindSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "WindSound"));
            Intensity = XmlRel.GetHash(Xml.GetChildInnerText(node, "Intensity"));
            PlayerVersion = XmlRel.GetHash(Xml.GetChildInnerText(node, "PlayerVersion"));
            BulletImpacts = XmlRel.GetHash(Xml.GetChildInnerText(node, "BulletImpacts"));
            PedRollSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "PedRollSound"));
            ScrapeMaterialSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "ScrapeMaterialSettings"));
            JumpLandSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "JumpLandSound"));
            MeleeSwingSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "MeleeSwingSound"));
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { ImpactSound, WalkSound, RunSound, SprintSound, IntoCoverSound, OutOfCoverSound, WindSound, BulletImpacts, PedRollSound, JumpLandSound, MeleeSwingSound };
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { PlayerVersion };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151RadioTrackSettings : Dat151RelData // _rts, _radio_settings (plays a specific radio track song)
    {
        public MetaHash Sound { get; set; }
        public int Category { get; set; }
        public MetaHash HistorySound { get; set; }
        public float StartOffset { get; set; }

        public Dat151RadioTrackSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.RadioTrackSettings;
            TypeID = (byte)Type;
        }
        public Dat151RadioTrackSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Sound = br.ReadUInt32();
            Category = br.ReadInt32();
            HistorySound = br.ReadUInt32();
            StartOffset = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Sound);
            bw.Write(Category);
            bw.Write(HistorySound);
            bw.Write(StartOffset);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Sound", RelXml.HashString(Sound));
            RelXml.ValueTag(sb, indent, "Category", Category.ToString());
            RelXml.StringTag(sb, indent, "HistorySound", RelXml.HashString(HistorySound));
            RelXml.ValueTag(sb, indent, "StartOffset", FloatUtil.ToString(StartOffset));
        }
        public override void ReadXml(XmlNode node)
        {
            Sound = XmlRel.GetHash(Xml.GetChildInnerText(node, "Sound"));
            Category = Xml.GetChildIntAttribute(node, "Category", "value");
            HistorySound = XmlRel.GetHash(Xml.GetChildInnerText(node, "HistorySound"));
            StartOffset = Xml.GetChildFloatAttribute(node, "StartOffset", "value");
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { Sound, HistorySound };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ModelFootStepTuningItem : IMetaXmlItem
    {
        public MetaHash ModeName { get; set; }
        public float ShoeVolumeOffset { get; set; }
        public uint ShoeLPFCutoff { get; set; }
        public uint ShoeAttackTime { get; set; }
        public float DragScuffProbability { get; set; }
        public float DirtVolumeOffset { get; set; }
        public uint DirtLPFCutoff { get; set; }
        public uint DirtAttackTime { get; set; }
        public MetaHash DirtSweetenerCurve { get; set; }
        public float CreakVolumeOffset { get; set; }
        public uint CreakLPFCutoff { get; set; }
        public uint CreakAttackTime { get; set; }
        public MetaHash CreakSweetenerCurve { get; set; }
        public float GlassVolumeOffset { get; set; }
        public uint GlassLPFCutoff { get; set; }
        public uint GlassAttackTime { get; set; }
        public MetaHash GlassSweetenerCurve { get; set; }
        public float WetVolumeOffset { get; set; }
        public uint WetLPFCutoff { get; set; }
        public uint WetAttackTime { get; set; }
        public MetaHash WetSweetenerCurve { get; set; }
        public float CustomVolumeOffset { get; set; }
        public uint CustomLPFCutoff { get; set; }
        public uint CustomAttackTime { get; set; }
        public float MaterialImpactImpulseScale { get; set; }

        public Dat151ModelFootStepTuningItem()
        { }
        public Dat151ModelFootStepTuningItem(BinaryReader br)
        {
            ModeName = br.ReadUInt32();
            ShoeVolumeOffset = br.ReadSingle();
            ShoeLPFCutoff = br.ReadUInt32();
            ShoeAttackTime = br.ReadUInt32();
            DragScuffProbability = br.ReadSingle();
            DirtVolumeOffset = br.ReadSingle();
            DirtLPFCutoff = br.ReadUInt32();
            DirtAttackTime = br.ReadUInt32();
            DirtSweetenerCurve = br.ReadUInt32();
            CreakVolumeOffset = br.ReadSingle();
            CreakLPFCutoff = br.ReadUInt32();
            CreakAttackTime = br.ReadUInt32();
            CreakSweetenerCurve = br.ReadUInt32();
            GlassVolumeOffset = br.ReadSingle();
            GlassLPFCutoff = br.ReadUInt32();
            GlassAttackTime = br.ReadUInt32();
            GlassSweetenerCurve = br.ReadUInt32();
            WetVolumeOffset = br.ReadSingle();
            WetLPFCutoff = br.ReadUInt32();
            WetAttackTime = br.ReadUInt32();
            WetSweetenerCurve = br.ReadUInt32();
            CustomVolumeOffset = br.ReadSingle();
            CustomLPFCutoff = br.ReadUInt32();
            CustomAttackTime = br.ReadUInt32();
            MaterialImpactImpulseScale = br.ReadSingle();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(ModeName);
            bw.Write(ShoeVolumeOffset);
            bw.Write(ShoeLPFCutoff);
            bw.Write(ShoeAttackTime);
            bw.Write(DragScuffProbability);
            bw.Write(DirtVolumeOffset);
            bw.Write(DirtLPFCutoff);
            bw.Write(DirtAttackTime);
            bw.Write(DirtSweetenerCurve);
            bw.Write(CreakVolumeOffset);
            bw.Write(CreakLPFCutoff);
            bw.Write(CreakAttackTime);
            bw.Write(CreakSweetenerCurve);
            bw.Write(GlassVolumeOffset);
            bw.Write(GlassLPFCutoff);
            bw.Write(GlassAttackTime);
            bw.Write(GlassSweetenerCurve);
            bw.Write(WetVolumeOffset);
            bw.Write(WetLPFCutoff);
            bw.Write(WetAttackTime);
            bw.Write(WetSweetenerCurve);
            bw.Write(CustomVolumeOffset);
            bw.Write(CustomLPFCutoff);
            bw.Write(CustomAttackTime);
            bw.Write(MaterialImpactImpulseScale);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "ModeName", RelXml.HashString(ModeName));
            RelXml.ValueTag(sb, indent, "ShoeVolumeOffset", FloatUtil.ToString(ShoeVolumeOffset));
            RelXml.ValueTag(sb, indent, "ShoeLPFCutoff", ShoeLPFCutoff.ToString());
            RelXml.ValueTag(sb, indent, "ShoeAttackTime", ShoeAttackTime.ToString());
            RelXml.ValueTag(sb, indent, "DragScuffProbability", FloatUtil.ToString(DragScuffProbability));
            RelXml.ValueTag(sb, indent, "DirtVolumeOffset", FloatUtil.ToString(DirtVolumeOffset));
            RelXml.ValueTag(sb, indent, "DirtLPFCutoff", DirtLPFCutoff.ToString());
            RelXml.ValueTag(sb, indent, "DirtAttackTime", DirtAttackTime.ToString());
            RelXml.StringTag(sb, indent, "DirtSweetenerCurve", RelXml.HashString(DirtSweetenerCurve));
            RelXml.ValueTag(sb, indent, "CreakVolumeOffset", FloatUtil.ToString(CreakVolumeOffset));
            RelXml.ValueTag(sb, indent, "CreakLPFCutoff", CreakLPFCutoff.ToString());
            RelXml.ValueTag(sb, indent, "CreakAttackTime", CreakAttackTime.ToString());
            RelXml.StringTag(sb, indent, "CreakSweetenerCurve", RelXml.HashString(CreakSweetenerCurve));
            RelXml.ValueTag(sb, indent, "GlassVolumeOffset", FloatUtil.ToString(GlassVolumeOffset));
            RelXml.ValueTag(sb, indent, "GlassLPFCutoff", GlassLPFCutoff.ToString());
            RelXml.ValueTag(sb, indent, "GlassAttackTime", GlassAttackTime.ToString());
            RelXml.StringTag(sb, indent, "GlassSweetenerCurve", RelXml.HashString(GlassSweetenerCurve));
            RelXml.ValueTag(sb, indent, "WetVolumeOffset", FloatUtil.ToString(WetVolumeOffset));
            RelXml.ValueTag(sb, indent, "WetLPFCutoff", WetLPFCutoff.ToString());
            RelXml.ValueTag(sb, indent, "WetAttackTime", WetAttackTime.ToString());
            RelXml.StringTag(sb, indent, "WetSweetenerCurve", RelXml.HashString(WetSweetenerCurve));
            RelXml.ValueTag(sb, indent, "CustomVolumeOffset", FloatUtil.ToString(CustomVolumeOffset));
            RelXml.ValueTag(sb, indent, "CustomLPFCutoff", CustomLPFCutoff.ToString());
            RelXml.ValueTag(sb, indent, "CustomAttackTime", CustomAttackTime.ToString());
            RelXml.ValueTag(sb, indent, "MaterialImpactImpulseScale", FloatUtil.ToString(MaterialImpactImpulseScale));
        }
        public void ReadXml(XmlNode node)
        {
            ModeName = XmlRel.GetHash(Xml.GetChildInnerText(node, "ModeName"));
            ShoeVolumeOffset = Xml.GetChildFloatAttribute(node, "ShoeVolumeOffset", "value");
            ShoeLPFCutoff = Xml.GetChildUIntAttribute(node, "ShoeLPFCutoff", "value");
            ShoeAttackTime = Xml.GetChildUIntAttribute(node, "ShoeAttackTime", "value");
            DragScuffProbability = Xml.GetChildFloatAttribute(node, "DragScuffProbability", "value");
            DirtVolumeOffset = Xml.GetChildFloatAttribute(node, "DirtVolumeOffset", "value");
            DirtLPFCutoff = Xml.GetChildUIntAttribute(node, "DirtLPFCutoff", "value");
            DirtAttackTime = Xml.GetChildUIntAttribute(node, "DirtAttackTime", "value");
            DirtSweetenerCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "DirtSweetenerCurve"));
            CreakVolumeOffset = Xml.GetChildFloatAttribute(node, "CreakVolumeOffset", "value");
            CreakLPFCutoff = Xml.GetChildUIntAttribute(node, "CreakLPFCutoff", "value");
            CreakAttackTime = Xml.GetChildUIntAttribute(node, "CreakAttackTime", "value");
            CreakSweetenerCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "CreakSweetenerCurve"));
            GlassVolumeOffset = Xml.GetChildFloatAttribute(node, "GlassVolumeOffset", "value");
            GlassLPFCutoff = Xml.GetChildUIntAttribute(node, "GlassLPFCutoff", "value");
            GlassAttackTime = Xml.GetChildUIntAttribute(node, "GlassAttackTime", "value");
            GlassSweetenerCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "GlassSweetenerCurve"));
            WetVolumeOffset = Xml.GetChildFloatAttribute(node, "WetVolumeOffset", "value");
            WetLPFCutoff = Xml.GetChildUIntAttribute(node, "WetLPFCutoff", "value");
            WetAttackTime = Xml.GetChildUIntAttribute(node, "WetAttackTime", "value");
            WetSweetenerCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "WetSweetenerCurve"));
            CustomVolumeOffset = Xml.GetChildFloatAttribute(node, "CustomVolumeOffset", "value");
            CustomLPFCutoff = Xml.GetChildUIntAttribute(node, "CustomLPFCutoff", "value");
            CustomAttackTime = Xml.GetChildUIntAttribute(node, "CustomAttackTime", "value");
            MaterialImpactImpulseScale = Xml.GetChildFloatAttribute(node, "MaterialImpactImpulseScale", "value");
        }
        public override string ToString()
        {
            return ModeName.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ModelFootStepTuning : Dat151RelData
    {
        public float FootstepPitchRatioMin { get; set; }
        public float FootstepPitchRatioMax { get; set; }
        public float InLeftPocketProbability { get; set; }
        public float HasKeysProbability { get; set; }
        public float HasMoneyProbability { get; set; }
        public int ItemCount { get; set; }
        public Dat151ModelFootStepTuningItem[] Items { get; set; }

        public Dat151ModelFootStepTuning(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ModelFootStepTuning;
            TypeID = (byte)Type;
        }
        public Dat151ModelFootStepTuning(RelData d, BinaryReader br) : base(d, br)
        {
            FootstepPitchRatioMin = br.ReadSingle();
            FootstepPitchRatioMax = br.ReadSingle();
            InLeftPocketProbability = br.ReadSingle();
            HasKeysProbability = br.ReadSingle();
            HasMoneyProbability = br.ReadSingle();

            ItemCount = br.ReadInt32();
            Items = new Dat151ModelFootStepTuningItem[ItemCount];
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i] = new Dat151ModelFootStepTuningItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(FootstepPitchRatioMin);
            bw.Write(FootstepPitchRatioMax);
            bw.Write(InLeftPocketProbability);
            bw.Write(HasKeysProbability);
            bw.Write(HasMoneyProbability);

            bw.Write(ItemCount);
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "FootstepPitchRatioMin", FloatUtil.ToString(FootstepPitchRatioMin));
            RelXml.ValueTag(sb, indent, "FootstepPitchRatioMax", FloatUtil.ToString(FootstepPitchRatioMax));
            RelXml.ValueTag(sb, indent, "InLeftPocketProbability", FloatUtil.ToString(InLeftPocketProbability));
            RelXml.ValueTag(sb, indent, "HasKeysProbability", FloatUtil.ToString(HasKeysProbability));
            RelXml.ValueTag(sb, indent, "HasMoneyProbability", FloatUtil.ToString(HasMoneyProbability));
            RelXml.WriteItemArray(sb, Items, indent, "Items");
        }
        public override void ReadXml(XmlNode node)
        {
            FootstepPitchRatioMin = Xml.GetChildFloatAttribute(node, "FootstepPitchRatioMin", "value");
            FootstepPitchRatioMax = Xml.GetChildFloatAttribute(node, "FootstepPitchRatioMax", "value");
            InLeftPocketProbability = Xml.GetChildFloatAttribute(node, "InLeftPocketProbability", "value");
            HasKeysProbability = Xml.GetChildFloatAttribute(node, "HasKeysProbability", "value");
            HasMoneyProbability = Xml.GetChildFloatAttribute(node, "HasMoneyProbability", "value");
            Items = XmlRel.ReadItemArray<Dat151ModelFootStepTuningItem>(node, "Items");
            ItemCount = (Items?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151SilenceConstraint : Dat151RelData
    {
        public float MinimumDuration { get; set; }

        public Dat151SilenceConstraint(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.SilenceConstraint;
            TypeID = (byte)Type;
        }
        public Dat151SilenceConstraint(RelData d, BinaryReader br) : base(d, br)
        {
            MinimumDuration = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(MinimumDuration);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "MinimumDuration", FloatUtil.ToString(MinimumDuration));
        }
        public override void ReadXml(XmlNode node)
        {
            MinimumDuration = Xml.GetChildFloatAttribute(node, "MinimumDuration", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ReflectionsSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public float MinDelay { get; set; }
        public float MaxDelay { get; set; }
        public float DelayTimeScalar { get; set; }
        public float DelayTimeAddition { get; set; }
        public MetaHash EnterSound { get; set; }
        public MetaHash ExitSound { get; set; }
        public MetaHash SubmixVoice { get; set; }
        public float Smoothing { get; set; }
        public int PostSubmixVolumeAttenuation { get; set; }
        public float RollOffScale { get; set; }
        public int FilterMode { get; set; }
        public float FilterFrequencyMin { get; set; }
        public float FilterFrequencyMax { get; set; }
        public float FilterResonanceMin { get; set; }
        public float FilterResonanceMax { get; set; }
        public float FilterBandwidthMin { get; set; }
        public float FilterBandwidthMax { get; set; }
        public MetaHash DistanceToFilterInput { get; set; }

        public Dat151ReflectionsSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ReflectionsSettings;
            TypeID = (byte)Type;
        }
        public Dat151ReflectionsSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            MinDelay = br.ReadSingle();
            MaxDelay = br.ReadSingle();
            DelayTimeScalar = br.ReadSingle();
            DelayTimeAddition = br.ReadSingle();
            EnterSound = br.ReadUInt32();
            ExitSound = br.ReadUInt32();
            SubmixVoice = br.ReadUInt32();
            Smoothing = br.ReadSingle();
            PostSubmixVolumeAttenuation = br.ReadInt32();
            RollOffScale = br.ReadSingle();
            FilterMode = br.ReadInt32();
            FilterFrequencyMin = br.ReadSingle();
            FilterFrequencyMax = br.ReadSingle();
            FilterResonanceMin = br.ReadSingle();
            FilterResonanceMax = br.ReadSingle();
            FilterBandwidthMin = br.ReadSingle();
            FilterBandwidthMax = br.ReadSingle();
            DistanceToFilterInput = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(MinDelay);
            bw.Write(MaxDelay);
            bw.Write(DelayTimeScalar);
            bw.Write(DelayTimeAddition);
            bw.Write(EnterSound);
            bw.Write(ExitSound);
            bw.Write(SubmixVoice);
            bw.Write(Smoothing);
            bw.Write(PostSubmixVolumeAttenuation);
            bw.Write(RollOffScale);
            bw.Write(FilterMode);
            bw.Write(FilterFrequencyMin);
            bw.Write(FilterFrequencyMax);
            bw.Write(FilterResonanceMin);
            bw.Write(FilterResonanceMax);
            bw.Write(FilterBandwidthMin);
            bw.Write(FilterBandwidthMax);
            bw.Write(DistanceToFilterInput);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinDelay", FloatUtil.ToString(MinDelay));
            RelXml.ValueTag(sb, indent, "MaxDelay", FloatUtil.ToString(MaxDelay));
            RelXml.ValueTag(sb, indent, "DelayTimeScalar", FloatUtil.ToString(DelayTimeScalar));
            RelXml.ValueTag(sb, indent, "DelayTimeAddition", FloatUtil.ToString(DelayTimeAddition));
            RelXml.StringTag(sb, indent, "EnterSound", RelXml.HashString(EnterSound));
            RelXml.StringTag(sb, indent, "ExitSound", RelXml.HashString(ExitSound));
            RelXml.StringTag(sb, indent, "SubmixVoice", RelXml.HashString(SubmixVoice));
            RelXml.ValueTag(sb, indent, "Smoothing", FloatUtil.ToString(Smoothing));
            RelXml.ValueTag(sb, indent, "PostSubmixVolumeAttenuation", PostSubmixVolumeAttenuation.ToString());
            RelXml.ValueTag(sb, indent, "RollOffScale", FloatUtil.ToString(RollOffScale));
            RelXml.ValueTag(sb, indent, "FilterMode", FilterMode.ToString());
            RelXml.ValueTag(sb, indent, "FilterFrequencyMin", FloatUtil.ToString(FilterFrequencyMin));
            RelXml.ValueTag(sb, indent, "FilterFrequencyMax", FloatUtil.ToString(FilterFrequencyMax));
            RelXml.ValueTag(sb, indent, "FilterResonanceMin", FloatUtil.ToString(FilterResonanceMin));
            RelXml.ValueTag(sb, indent, "FilterResonanceMax", FloatUtil.ToString(FilterResonanceMax));
            RelXml.ValueTag(sb, indent, "FilterBandwidthMin", FloatUtil.ToString(FilterBandwidthMin));
            RelXml.ValueTag(sb, indent, "FilterBandwidthMax", FloatUtil.ToString(FilterBandwidthMax));
            RelXml.StringTag(sb, indent, "DistanceToFilterInput", RelXml.HashString(DistanceToFilterInput));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinDelay = Xml.GetChildFloatAttribute(node, "MinDelay", "value");
            MaxDelay = Xml.GetChildFloatAttribute(node, "MaxDelay", "value");
            DelayTimeScalar = Xml.GetChildFloatAttribute(node, "DelayTimeScalar", "value");
            DelayTimeAddition = Xml.GetChildFloatAttribute(node, "DelayTimeAddition", "value");
            EnterSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "EnterSound"));
            ExitSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "ExitSound"));
            SubmixVoice = XmlRel.GetHash(Xml.GetChildInnerText(node, "SubmixVoice"));
            Smoothing = Xml.GetChildFloatAttribute(node, "Smoothing", "value");
            PostSubmixVolumeAttenuation = Xml.GetChildIntAttribute(node, "PostSubmixVolumeAttenuation", "value");
            RollOffScale = Xml.GetChildFloatAttribute(node, "RollOffScale", "value");
            FilterMode = Xml.GetChildIntAttribute(node, "FilterMode", "value");
            FilterFrequencyMin = Xml.GetChildFloatAttribute(node, "FilterFrequencyMin", "value");
            FilterFrequencyMax = Xml.GetChildFloatAttribute(node, "FilterFrequencyMax", "value");
            FilterResonanceMin = Xml.GetChildFloatAttribute(node, "FilterResonanceMin", "value");
            FilterResonanceMax = Xml.GetChildFloatAttribute(node, "FilterResonanceMax", "value");
            FilterBandwidthMin = Xml.GetChildFloatAttribute(node, "FilterBandwidthMin", "value");
            FilterBandwidthMax = Xml.GetChildFloatAttribute(node, "FilterBandwidthMax", "value");
            DistanceToFilterInput = XmlRel.GetHash(Xml.GetChildInnerText(node, "DistanceToFilterInput"));
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { EnterSound, ExitSound, SubmixVoice };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151AlarmSettings : Dat151RelData
    {
        public MetaHash AlarmLoop { get; set; }
        public MetaHash AlarmDecayCurve { get; set; }
        public uint StopDistance { get; set; }
        public MetaHash InteriorSettings { get; set; }
        public MetaHash BankName { get; set; }
        public uint padding00 { get; set; }
        public uint padding01 { get; set; }
        public Vector3 Position { get; set; }
        public uint padding02 { get; set; }

        public Dat151AlarmSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.AlarmSettings;
            TypeID = (byte)Type;
        }
        public Dat151AlarmSettings(RelData d, BinaryReader br) : base(d, br)
        {
            AlarmLoop = br.ReadUInt32();
            AlarmDecayCurve = br.ReadUInt32();
            StopDistance = br.ReadUInt32();
            InteriorSettings = br.ReadUInt32();
            BankName = br.ReadUInt32();
            padding00 = br.ReadUInt32();
            padding01 = br.ReadUInt32();
            Position = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            padding02 = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(AlarmLoop);
            bw.Write(AlarmDecayCurve);
            bw.Write(StopDistance);
            bw.Write(InteriorSettings);
            bw.Write(BankName);
            bw.Write(padding00);
            bw.Write(padding01);
            bw.Write(Position.X);
            bw.Write(Position.Y);
            bw.Write(Position.Z);
            bw.Write(padding02);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "AlarmLoop", RelXml.HashString(AlarmLoop));
            RelXml.StringTag(sb, indent, "AlarmDecayCurve", RelXml.HashString(AlarmDecayCurve));
            RelXml.ValueTag(sb, indent, "StopDistance", StopDistance.ToString());
            RelXml.StringTag(sb, indent, "InteriorSettings", RelXml.HashString(InteriorSettings));
            RelXml.StringTag(sb, indent, "BankName", RelXml.HashString(BankName));
            RelXml.SelfClosingTag(sb, indent, "Position " + FloatUtil.GetVector3XmlString(Position));
        }
        public override void ReadXml(XmlNode node)
        {
            AlarmLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "AlarmLoop"));
            AlarmDecayCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "AlarmDecayCurve"));
            StopDistance = Xml.GetChildUIntAttribute(node, "StopDistance", "value");
            InteriorSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "InteriorSettings"));
            BankName = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankName"));
            Position = Xml.GetChildVector3Attributes(node, "Position");
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { AlarmDecayCurve };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { AlarmLoop };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151SlowMoSettings : Dat151RelData
    {
        public MetaHash Scene { get; set; }
        public int Priority { get; set; }
        public float Release { get; set; }
        public MetaHash SlowMoSound { get; set; }

        public Dat151SlowMoSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.SlowMoSettings;
            TypeID = (byte)Type;
        }
        public Dat151SlowMoSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Scene = br.ReadUInt32();
            Priority = br.ReadInt32();
            Release = br.ReadSingle();
            SlowMoSound = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Scene);
            bw.Write(Priority);
            bw.Write(Release);
            bw.Write(SlowMoSound);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Scene", RelXml.HashString(Scene));
            RelXml.ValueTag(sb, indent, "Priority", Priority.ToString());
            RelXml.ValueTag(sb, indent, "Release", FloatUtil.ToString(Release));
            RelXml.StringTag(sb, indent, "SlowMoSound", RelXml.HashString(SlowMoSound));
        }
        public override void ReadXml(XmlNode node)
        {
            Scene = XmlRel.GetHash(Xml.GetChildInnerText(node, "Scene"));
            Priority = Xml.GetChildIntAttribute(node, "Priority", "value");
            Release = Xml.GetChildFloatAttribute(node, "Release", "value");
            SlowMoSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SlowMoSound"));
        }
        public override MetaHash[] GetMixerHashes()
        {
            return new[] { Scene };
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { SlowMoSound };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151PedScenarioAudioSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public int MaxInstances { get; set; }
        public MetaHash Sound { get; set; }
        public float SharedOwnershipRadius { get; set; }
        public int VariationsCount { get; set; }
        public Dat151PedScenarioAudioSettingsItem[] Variations { get; set; }

        public Dat151PedScenarioAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.PedScenarioAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151PedScenarioAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            MaxInstances = br.ReadInt32();
            Sound = br.ReadUInt32();
            SharedOwnershipRadius = br.ReadSingle();

            VariationsCount = br.ReadInt32();
            Variations = new Dat151PedScenarioAudioSettingsItem[VariationsCount];
            for (int i = 0; i < VariationsCount; i++)
            {
                Variations[i] = new Dat151PedScenarioAudioSettingsItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(MaxInstances);
            bw.Write(Sound);
            bw.Write(SharedOwnershipRadius);

            bw.Write(VariationsCount);
            for (int i = 0; i < VariationsCount; i++)
            {
                Variations[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MaxInstances", MaxInstances.ToString());
            RelXml.StringTag(sb, indent, "Sound", RelXml.HashString(Sound));
            RelXml.ValueTag(sb, indent, "SharedOwnershipRadius", FloatUtil.ToString(SharedOwnershipRadius));
            RelXml.WriteItemArray(sb, Variations, indent, "Variations");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MaxInstances = Xml.GetChildIntAttribute(node, "MaxInstances", "value");
            Sound = XmlRel.GetHash(Xml.GetChildInnerText(node, "Sound"));
            SharedOwnershipRadius = Xml.GetChildFloatAttribute(node, "SharedOwnershipRadius", "value");
            Variations = XmlRel.ReadItemArray<Dat151PedScenarioAudioSettingsItem>(node, "Variations");
            VariationsCount = (Variations?.Length ?? 0);
        }
        public override MetaHash[] GetSoundHashes()
        {
            var list = new List<MetaHash>();
            list.Add(Sound);
            if (Variations != null)
            {
                foreach (var item in Variations)
                {
                    list.Add(item.Sound);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public struct Dat151PedScenarioAudioSettingsItem : IMetaXmlItem
    {
        public MetaHash Prop { get; set; }
        public MetaHash Sound { get; set; }

        public Dat151PedScenarioAudioSettingsItem(BinaryReader br)
        {
            Prop = br.ReadUInt32();
            Sound = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Prop);
            bw.Write(Sound);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Prop", RelXml.HashString(Prop));
            RelXml.StringTag(sb, indent, "Sound", RelXml.HashString(Sound));
        }
        public void ReadXml(XmlNode node)
        {
            Prop = XmlRel.GetHash(Xml.GetChildInnerText(node, "Prop"));
            Sound = XmlRel.GetHash(Xml.GetChildInnerText(node, "Sound"));
        }
        public override string ToString()
        {
            return Prop.ToString() + ": " + Sound.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151PortalSettings : Dat151RelData
    {
        //used in conjunction with the 'SET_PORTAL_SETTINGS_OVERRIDE'
        //and 'REMOVE_PORTAL_SETTINGS_OVERRIDE' natives to do real time changes to audio occlusion for interior portals.

        public float MaxOcclusion { get; set; } //value to override for a particular portal

        public Dat151PortalSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.PortalSettings;
            TypeID = (byte)Type;
        }
        public Dat151PortalSettings(RelData d, BinaryReader br) : base(d, br)
        {
            MaxOcclusion = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(MaxOcclusion);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "MaxOcclusion", FloatUtil.ToString(MaxOcclusion));
        }
        public override void ReadXml(XmlNode node)
        {
            MaxOcclusion = Xml.GetChildFloatAttribute(node, "MaxOcclusion", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ElectricEngineAudioSettings : Dat151RelData
    {
        public uint MasterVolume { get; set; }
        public MetaHash SpeedLoop { get; set; }
        public int SpeedLoop_MinPitch { get; set; }
        public int SpeedLoop_MaxPitch { get; set; }
        public int SpeedLoop_ThrottleVol { get; set; }
        public MetaHash BoostLoop { get; set; }
        public int BoostLoop_MinPitch { get; set; }
        public int BoostLoop_MaxPitch { get; set; }
        public int BoostLoop_SpinupSpeed { get; set; }
        public int BoostLoop_Vol { get; set; }
        public MetaHash RevsOffLoop { get; set; }
        public int RevsOffLoop_MinPitch { get; set; }
        public int RevsOffLoop_MaxPitch { get; set; }
        public int RevsOffLoop_Vol { get; set; }
        public MetaHash BankLoadSound { get; set; }
        public MetaHash EngineStartUp { get; set; }

        public Dat151ElectricEngineAudioSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ElectricEngineAudioSettings;
            TypeID = (byte)Type;
        }
        public Dat151ElectricEngineAudioSettings(RelData d, BinaryReader br) : base(d, br)
        {
            MasterVolume = br.ReadUInt32();
            SpeedLoop = br.ReadUInt32();
            SpeedLoop_MinPitch = br.ReadInt32();
            SpeedLoop_MaxPitch = br.ReadInt32();
            SpeedLoop_ThrottleVol = br.ReadInt32();
            BoostLoop = br.ReadUInt32();
            BoostLoop_MinPitch = br.ReadInt32();
            BoostLoop_MaxPitch = br.ReadInt32();
            BoostLoop_SpinupSpeed = br.ReadInt32();
            BoostLoop_Vol = br.ReadInt32();
            RevsOffLoop = br.ReadUInt32();
            RevsOffLoop_MinPitch = br.ReadInt32();
            RevsOffLoop_MaxPitch = br.ReadInt32();
            RevsOffLoop_Vol = br.ReadInt32();
            BankLoadSound = br.ReadUInt32();
            EngineStartUp = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(MasterVolume);
            bw.Write(SpeedLoop);
            bw.Write(SpeedLoop_MinPitch);
            bw.Write(SpeedLoop_MaxPitch);
            bw.Write(SpeedLoop_ThrottleVol);
            bw.Write(BoostLoop);
            bw.Write(BoostLoop_MinPitch);
            bw.Write(BoostLoop_MaxPitch);
            bw.Write(BoostLoop_SpinupSpeed);
            bw.Write(BoostLoop_Vol);
            bw.Write(RevsOffLoop);
            bw.Write(RevsOffLoop_MinPitch);
            bw.Write(RevsOffLoop_MaxPitch);
            bw.Write(RevsOffLoop_Vol);
            bw.Write(BankLoadSound);
            bw.Write(EngineStartUp);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "MasterVolume", MasterVolume.ToString());
            RelXml.StringTag(sb, indent, "SpeedLoop", RelXml.HashString(SpeedLoop));
            RelXml.ValueTag(sb, indent, "SpeedLoop_MinPitch", SpeedLoop_MinPitch.ToString());
            RelXml.ValueTag(sb, indent, "SpeedLoop_MaxPitch", SpeedLoop_MaxPitch.ToString());
            RelXml.ValueTag(sb, indent, "SpeedLoop_ThrottleVol", SpeedLoop_ThrottleVol.ToString());
            RelXml.StringTag(sb, indent, "BoostLoop", RelXml.HashString(BoostLoop));
            RelXml.ValueTag(sb, indent, "BoostLoop_MinPitch", BoostLoop_MinPitch.ToString());
            RelXml.ValueTag(sb, indent, "BoostLoop_MaxPitch", BoostLoop_MaxPitch.ToString());
            RelXml.ValueTag(sb, indent, "BoostLoop_SpinupSpeed", BoostLoop_SpinupSpeed.ToString());
            RelXml.ValueTag(sb, indent, "BoostLoop_Vol", BoostLoop_Vol.ToString());
            RelXml.StringTag(sb, indent, "RevsOffLoop", RelXml.HashString(RevsOffLoop));
            RelXml.ValueTag(sb, indent, "RevsOffLoop_MinPitch", RevsOffLoop_MinPitch.ToString());
            RelXml.ValueTag(sb, indent, "RevsOffLoop_MaxPitch", RevsOffLoop_MaxPitch.ToString());
            RelXml.ValueTag(sb, indent, "RevsOffLoop_Vol", RevsOffLoop_Vol.ToString());
            RelXml.StringTag(sb, indent, "BankLoadSound", RelXml.HashString(BankLoadSound));
            RelXml.StringTag(sb, indent, "EngineStartUp", RelXml.HashString(EngineStartUp));
        }
        public override void ReadXml(XmlNode node)
        {
            MasterVolume = Xml.GetChildUIntAttribute(node, "MasterVolume", "value");
            SpeedLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "SpeedLoop"));
            SpeedLoop_MinPitch = Xml.GetChildIntAttribute(node, "SpeedLoop_MinPitch", "value");
            SpeedLoop_MaxPitch = Xml.GetChildIntAttribute(node, "SpeedLoop_MaxPitch", "value");
            SpeedLoop_ThrottleVol = Xml.GetChildIntAttribute(node, "SpeedLoop_ThrottleVol", "value");
            BoostLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "BoostLoop"));
            BoostLoop_MinPitch = Xml.GetChildIntAttribute(node, "BoostLoop_MinPitch", "value");
            BoostLoop_MaxPitch = Xml.GetChildIntAttribute(node, "BoostLoop_MaxPitch", "value");
            BoostLoop_SpinupSpeed = Xml.GetChildIntAttribute(node, "BoostLoop_SpinupSpeed", "value");
            BoostLoop_Vol = Xml.GetChildIntAttribute(node, "BoostLoop_Vol", "value");
            RevsOffLoop = XmlRel.GetHash(Xml.GetChildInnerText(node, "RevsOffLoop"));
            RevsOffLoop_MinPitch = Xml.GetChildIntAttribute(node, "RevsOffLoop_MinPitch", "value");
            RevsOffLoop_MaxPitch = Xml.GetChildIntAttribute(node, "RevsOffLoop_MaxPitch", "value");
            RevsOffLoop_Vol = Xml.GetChildIntAttribute(node, "RevsOffLoop_Vol", "value");
            BankLoadSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "BankLoadSound"));
            EngineStartUp = XmlRel.GetHash(Xml.GetChildInnerText(node, "EngineStartUp"));
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { SpeedLoop, BoostLoop, RevsOffLoop, BankLoadSound, EngineStartUp };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151PlayerBreathingSettings : Dat151RelData
    {
        public int TimeBetweenLowRunBreaths { get; set; }
        public int TimeBetweenHighRunBreaths { get; set; }
        public int TimeBetweenExhaustedBreaths { get; set; }
        public int TimeBetweenFinalBreaths { get; set; }
        public int MinBreathStateChangeWaitToLow { get; set; }
        public int MaxBreathStateChangeWaitToLow { get; set; }
        public int MinBreathStateChangeLowToHighFromWait { get; set; }
        public int MaxBreathStateChangeLowToHighFromWait { get; set; }
        public int MinBreathStateChangeHighToLowFromLow { get; set; }
        public int MaxBreathStateChangeHighToLowFromLow { get; set; }
        public int MinBreathStateChangeLowToHighFromHigh { get; set; }
        public int MaxBreathStateChangeLowToHighFromHigh { get; set; }
        public int MinBreathStateChangeExhaustedToIdleFromLow { get; set; }
        public int MaxBreathStateChangeExhaustedToIdleFromLow { get; set; }
        public int MinBreathStateChangeExhaustedToIdleFromHigh { get; set; }
        public int MaxBreathStateChangeExhaustedToIdleFromHigh { get; set; }
        public int MinBreathStateChangeLowToHighFromExhausted { get; set; }
        public int MaxBreathStateChangeLowToHighFromExhausted { get; set; }

        public Dat151PlayerBreathingSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.PlayerBreathingSettings;
            TypeID = (byte)Type;
        }
        public Dat151PlayerBreathingSettings(RelData d, BinaryReader br) : base(d, br)
        {
            TimeBetweenLowRunBreaths = br.ReadInt32();
            TimeBetweenHighRunBreaths = br.ReadInt32();
            TimeBetweenExhaustedBreaths = br.ReadInt32();
            TimeBetweenFinalBreaths = br.ReadInt32();
            MinBreathStateChangeWaitToLow = br.ReadInt32();
            MaxBreathStateChangeWaitToLow = br.ReadInt32();
            MinBreathStateChangeLowToHighFromWait = br.ReadInt32();
            MaxBreathStateChangeLowToHighFromWait = br.ReadInt32();
            MinBreathStateChangeHighToLowFromLow = br.ReadInt32();
            MaxBreathStateChangeHighToLowFromLow = br.ReadInt32();
            MinBreathStateChangeLowToHighFromHigh = br.ReadInt32();
            MaxBreathStateChangeLowToHighFromHigh = br.ReadInt32();
            MinBreathStateChangeExhaustedToIdleFromLow = br.ReadInt32();
            MaxBreathStateChangeExhaustedToIdleFromLow = br.ReadInt32();
            MinBreathStateChangeExhaustedToIdleFromHigh = br.ReadInt32();
            MaxBreathStateChangeExhaustedToIdleFromHigh = br.ReadInt32();
            MinBreathStateChangeLowToHighFromExhausted = br.ReadInt32();
            MaxBreathStateChangeLowToHighFromExhausted = br.ReadInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(TimeBetweenLowRunBreaths);
            bw.Write(TimeBetweenHighRunBreaths);
            bw.Write(TimeBetweenExhaustedBreaths);
            bw.Write(TimeBetweenFinalBreaths);
            bw.Write(MinBreathStateChangeWaitToLow);
            bw.Write(MaxBreathStateChangeWaitToLow);
            bw.Write(MinBreathStateChangeLowToHighFromWait);
            bw.Write(MaxBreathStateChangeLowToHighFromWait);
            bw.Write(MinBreathStateChangeHighToLowFromLow);
            bw.Write(MaxBreathStateChangeHighToLowFromLow);
            bw.Write(MinBreathStateChangeLowToHighFromHigh);
            bw.Write(MaxBreathStateChangeLowToHighFromHigh);
            bw.Write(MinBreathStateChangeExhaustedToIdleFromLow);
            bw.Write(MaxBreathStateChangeExhaustedToIdleFromLow);
            bw.Write(MinBreathStateChangeExhaustedToIdleFromHigh);
            bw.Write(MaxBreathStateChangeExhaustedToIdleFromHigh);
            bw.Write(MinBreathStateChangeLowToHighFromExhausted);
            bw.Write(MaxBreathStateChangeLowToHighFromExhausted);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "TimeBetweenLowRunBreaths", TimeBetweenLowRunBreaths.ToString());
            RelXml.ValueTag(sb, indent, "TimeBetweenHighRunBreaths", TimeBetweenHighRunBreaths.ToString());
            RelXml.ValueTag(sb, indent, "TimeBetweenExhaustedBreaths", TimeBetweenExhaustedBreaths.ToString());
            RelXml.ValueTag(sb, indent, "TimeBetweenFinalBreaths", TimeBetweenFinalBreaths.ToString());
            RelXml.ValueTag(sb, indent, "MinBreathStateChangeWaitToLow", MinBreathStateChangeWaitToLow.ToString());
            RelXml.ValueTag(sb, indent, "MaxBreathStateChangeWaitToLow", MaxBreathStateChangeWaitToLow.ToString());
            RelXml.ValueTag(sb, indent, "MinBreathStateChangeLowToHighFromWait", MinBreathStateChangeLowToHighFromWait.ToString());
            RelXml.ValueTag(sb, indent, "MaxBreathStateChangeLowToHighFromWait", MaxBreathStateChangeLowToHighFromWait.ToString());
            RelXml.ValueTag(sb, indent, "MinBreathStateChangeHighToLowFromLow", MinBreathStateChangeHighToLowFromLow.ToString());
            RelXml.ValueTag(sb, indent, "MaxBreathStateChangeHighToLowFromLow", MaxBreathStateChangeHighToLowFromLow.ToString());
            RelXml.ValueTag(sb, indent, "MinBreathStateChangeLowToHighFromHigh", MinBreathStateChangeLowToHighFromHigh.ToString());
            RelXml.ValueTag(sb, indent, "MaxBreathStateChangeLowToHighFromHigh", MaxBreathStateChangeLowToHighFromHigh.ToString());
            RelXml.ValueTag(sb, indent, "MinBreathStateChangeExhaustedToIdleFromLow", MinBreathStateChangeExhaustedToIdleFromLow.ToString());
            RelXml.ValueTag(sb, indent, "MaxBreathStateChangeExhaustedToIdleFromLow", MaxBreathStateChangeExhaustedToIdleFromLow.ToString());
            RelXml.ValueTag(sb, indent, "MinBreathStateChangeExhaustedToIdleFromHigh", MinBreathStateChangeExhaustedToIdleFromHigh.ToString());
            RelXml.ValueTag(sb, indent, "MaxBreathStateChangeExhaustedToIdleFromHigh", MaxBreathStateChangeExhaustedToIdleFromHigh.ToString());
            RelXml.ValueTag(sb, indent, "MinBreathStateChangeLowToHighFromExhausted", MinBreathStateChangeLowToHighFromExhausted.ToString());
            RelXml.ValueTag(sb, indent, "MaxBreathStateChangeLowToHighFromExhausted", MaxBreathStateChangeLowToHighFromExhausted.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            TimeBetweenLowRunBreaths = Xml.GetChildIntAttribute(node, "TimeBetweenLowRunBreaths", "value");
            TimeBetweenHighRunBreaths = Xml.GetChildIntAttribute(node, "TimeBetweenHighRunBreaths", "value");
            TimeBetweenExhaustedBreaths = Xml.GetChildIntAttribute(node, "TimeBetweenExhaustedBreaths", "value");
            TimeBetweenFinalBreaths = Xml.GetChildIntAttribute(node, "TimeBetweenFinalBreaths", "value");
            MinBreathStateChangeWaitToLow = Xml.GetChildIntAttribute(node, "MinBreathStateChangeWaitToLow", "value");
            MaxBreathStateChangeWaitToLow = Xml.GetChildIntAttribute(node, "MaxBreathStateChangeWaitToLow", "value");
            MinBreathStateChangeLowToHighFromWait = Xml.GetChildIntAttribute(node, "MinBreathStateChangeLowToHighFromWait", "value");
            MaxBreathStateChangeLowToHighFromWait = Xml.GetChildIntAttribute(node, "MaxBreathStateChangeLowToHighFromWait", "value");
            MinBreathStateChangeHighToLowFromLow = Xml.GetChildIntAttribute(node, "MinBreathStateChangeHighToLowFromLow", "value");
            MaxBreathStateChangeHighToLowFromLow = Xml.GetChildIntAttribute(node, "MaxBreathStateChangeHighToLowFromLow", "value");
            MinBreathStateChangeLowToHighFromHigh = Xml.GetChildIntAttribute(node, "MinBreathStateChangeLowToHighFromHigh", "value");
            MaxBreathStateChangeLowToHighFromHigh = Xml.GetChildIntAttribute(node, "MaxBreathStateChangeLowToHighFromHigh", "value");
            MinBreathStateChangeExhaustedToIdleFromLow = Xml.GetChildIntAttribute(node, "MinBreathStateChangeExhaustedToIdleFromLow", "value");
            MaxBreathStateChangeExhaustedToIdleFromLow = Xml.GetChildIntAttribute(node, "MaxBreathStateChangeExhaustedToIdleFromLow", "value");
            MinBreathStateChangeExhaustedToIdleFromHigh = Xml.GetChildIntAttribute(node, "MinBreathStateChangeExhaustedToIdleFromHigh", "value");
            MaxBreathStateChangeExhaustedToIdleFromHigh = Xml.GetChildIntAttribute(node, "MaxBreathStateChangeExhaustedToIdleFromHigh", "value");
            MinBreathStateChangeLowToHighFromExhausted = Xml.GetChildIntAttribute(node, "MinBreathStateChangeLowToHighFromExhausted", "value");
            MaxBreathStateChangeLowToHighFromExhausted = Xml.GetChildIntAttribute(node, "MaxBreathStateChangeLowToHighFromExhausted", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151PedWallaSpeechSettingsItem : IMetaXmlItem
    {
        public string ContextName { get; set; }
        public byte Variations { get; set; }

        public override string ToString()
        {
            return ContextName + ", " + Variations.ToString();
        }

        public Dat151PedWallaSpeechSettingsItem()
        {
        }
        public Dat151PedWallaSpeechSettingsItem(BinaryReader br)
        {
            var data = br.ReadBytes(32);
            ContextName = Encoding.ASCII.GetString(data).Replace("\0", "");
            Variations = br.ReadByte();
        }
        public void Write(BinaryWriter bw)
        {
            var data = new byte[32];
            int len = Math.Min(ContextName?.Length ?? 0, 32);
            if (len > 0)
            {
                Encoding.ASCII.GetBytes(ContextName, 0, len, data, 0);
            }
            bw.Write(data);
            bw.Write(Variations);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "ContextName", ContextName.Replace("\n", "\\n"));
            RelXml.ValueTag(sb, indent, "Variations", Variations.ToString());
        }
        public void ReadXml(XmlNode node)
        {
            ContextName = Xml.GetChildInnerText(node, "ContextName").Replace("\\n", "\n");
            Variations = (byte)Xml.GetChildUIntAttribute(node, "Variations", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151PedWallaSpeechSettings : Dat151RelData
    {
        public MetaHash SpeechSound { get; set; }
        public short VolumeAboveRMSLevel { get; set; }
        public short MaxVolume { get; set; }
        public float PedDensityThreshold { get; set; }
        public byte ItemCount { get; set; }
        public Dat151PedWallaSpeechSettingsItem[] Items { get; set; }

        public Dat151PedWallaSpeechSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.PedWallaSpeechSettings;
            TypeID = (byte)Type;
        }
        public Dat151PedWallaSpeechSettings(RelData d, BinaryReader br) : base(d, br)
        {
            SpeechSound = br.ReadUInt32();
            VolumeAboveRMSLevel = br.ReadInt16();
            MaxVolume = br.ReadInt16();
            PedDensityThreshold = br.ReadSingle();
            ItemCount = br.ReadByte();
            Items = new Dat151PedWallaSpeechSettingsItem[ItemCount];
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i] = new Dat151PedWallaSpeechSettingsItem(br);
            }

            var brem = (4 - ((ItemCount + 1) % 4)) % 4;
            var pads = br.ReadBytes(brem);
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(SpeechSound);
            bw.Write(VolumeAboveRMSLevel);
            bw.Write(MaxVolume);
            bw.Write(PedDensityThreshold);
            bw.Write(ItemCount);
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i].Write(bw);
            }

            var brem = (4 - ((ItemCount + 1) % 4)) % 4;
            for (int i = 0; i < brem; i++)
            {
                bw.Write((byte)0);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "SpeechSound", RelXml.HashString(SpeechSound));
            RelXml.ValueTag(sb, indent, "VolumeAboveRMSLevel", VolumeAboveRMSLevel.ToString());
            RelXml.ValueTag(sb, indent, "MaxVolume", MaxVolume.ToString());
            RelXml.ValueTag(sb, indent, "PedDensityThreshold", FloatUtil.ToString(PedDensityThreshold));
            RelXml.WriteItemArray(sb, Items, indent, "Items");
        }
        public override void ReadXml(XmlNode node)
        {
            SpeechSound = XmlRel.GetHash(Xml.GetChildInnerText(node, "SpeechSound"));
            VolumeAboveRMSLevel = (short)Xml.GetChildIntAttribute(node, "VolumeAboveRMSLevel", "value");
            MaxVolume = (short)Xml.GetChildIntAttribute(node, "MaxVolume", "value");
            PedDensityThreshold = Xml.GetChildFloatAttribute(node, "PedDensityThreshold", "value");
            Items = XmlRel.ReadItemArray<Dat151PedWallaSpeechSettingsItem>(node, "Items");
            ItemCount = (byte)(Items?.Length ?? 0);
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { SpeechSound };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151AircraftWarningSettings : Dat151RelData
    {
        public int MinTimeBetweenDamageReports { get; set; }
        public int TargetedLockedMinTimeInStateToTrigger { get; set; }
        public int TargetedLockedMaxTimeBetweenTriggerAndPlay { get; set; }
        public int TargetedLockedMinTimeBetweenPlay { get; set; }
        public int MissileFiredMinTimeInStateToTrigger { get; set; }
        public int MissileFiredMaxTimeBetweenTriggerAndPlay { get; set; }
        public int MissileFiredMinTimeBetweenPlay { get; set; }
        public int AcquiringTargetMinTimeInStateToTrigger { get; set; }
        public int AcquiringTargetMaxTimeBetweenTriggerAndPlay { get; set; }
        public int AcquiringTargetMinTimeBetweenPlay { get; set; }
        public int TargetAcquiredMinTimeInStateToTrigger { get; set; }
        public int TargetAcquiredMaxTimeBetweenTriggerAndPlay { get; set; }
        public int TargetAcquiredMinTimeBetweenPlay { get; set; }
        public int AllClearMinTimeInStateToTrigger { get; set; }
        public int AllClearMaxTimeBetweenTriggerAndPlay { get; set; }
        public int AllClearMinTimeBetweenPlay { get; set; }
        public int PlaneWarningStallMinTimeInStateToTrigger { get; set; }
        public int PlaneWarningStallMaxTimeBetweenTriggerAndPlay { get; set; }
        public int PlaneWarningStallMinTimeBetweenPlay { get; set; }
        public int AltitudeWarningLowMinTimeInStateToTrigger { get; set; }
        public int AltitudeWarningLowMaxTimeBetweenTriggerAndPlay { get; set; }
        public int AltitudeWarningLowMinTimeBetweenPlay { get; set; }
        public float AltitudeWarningLowDownProbeLength { get; set; }
        public int AltitudeWarningHighMinTimeInStateToTrigger { get; set; }
        public int AltitudeWarningHighMaxTimeBetweenTriggerAndPlay { get; set; }
        public int AltitudeWarningHighMinTimeBetweenPlay { get; set; }
        public int Engine1FireMinTimeInStateToTrigger { get; set; }
        public int Engine1FireMaxTimeBetweenTriggerAndPlay { get; set; }
        public int Engine1FireMinTimeBetweenPlay { get; set; }
        public int Engine2FireMinTimeInStateToTrigger { get; set; }
        public int Engine2FireMaxTimeBetweenTriggerAndPlay { get; set; }
        public int Engine2FireMinTimeBetweenPlay { get; set; }
        public int Engine3FireMinTimeInStateToTrigger { get; set; }
        public int Engine3FireMaxTimeBetweenTriggerAndPlay { get; set; }
        public int Engine3FireMinTimeBetweenPlay { get; set; }
        public int Engine4FireMinTimeInStateToTrigger { get; set; }
        public int Engine4FireMaxTimeBetweenTriggerAndPlay { get; set; }
        public int Engine4FireMinTimeBetweenPlay { get; set; }
        public int DamagedSeriousMinTimeInStateToTrigger { get; set; }
        public int DamagedSeriousMaxTimeBetweenTriggerAndPlay { get; set; }
        public int DamagedSeriousMinTimeBetweenPlay { get; set; }
        public int DamagedCriticalMinTimeInStateToTrigger { get; set; }
        public int DamagedCriticalMaxTimeBetweenTriggerAndPlay { get; set; }
        public int DamagedCriticalMinTimeBetweenPlay { get; set; }
        public int OverspeedMinTimeInStateToTrigger { get; set; }
        public int OverspeedMaxTimeBetweenTriggerAndPlay { get; set; }
        public int OverspeedMinTimeBetweenPlay { get; set; }
        public int TerrainMinTimeInStateToTrigger { get; set; }
        public int TerrainMaxTimeBetweenTriggerAndPlay { get; set; }
        public int TerrainMinTimeBetweenPlay { get; set; }
        public float TerrainForwardProbeLength { get; set; }
        public int PullUpMinTimeInStateToTrigger { get; set; }
        public int PullUpMaxTimeBetweenTriggerAndPlay { get; set; }
        public int PullUpMinTimeBetweenPlay { get; set; }
        public int PullUpMaxTimeSinceTerrainTriggerToPlay { get; set; }
        public int LowFuelMinTimeInStateToTrigger { get; set; }
        public int LowFuelMaxTimeBetweenTriggerAndPlay { get; set; }
        public int LowFuelMinTimeBetweenPlay { get; set; }


        public Dat151AircraftWarningSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.AircraftWarningSettings;
            TypeID = (byte)Type;
        }
        public Dat151AircraftWarningSettings(RelData d, BinaryReader br) : base(d, br)
        {
            MinTimeBetweenDamageReports = br.ReadInt32();
            TargetedLockedMinTimeInStateToTrigger = br.ReadInt32();
            TargetedLockedMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            TargetedLockedMinTimeBetweenPlay = br.ReadInt32();
            MissileFiredMinTimeInStateToTrigger = br.ReadInt32();
            MissileFiredMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            MissileFiredMinTimeBetweenPlay = br.ReadInt32();
            AcquiringTargetMinTimeInStateToTrigger = br.ReadInt32();
            AcquiringTargetMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            AcquiringTargetMinTimeBetweenPlay = br.ReadInt32();
            TargetAcquiredMinTimeInStateToTrigger = br.ReadInt32();
            TargetAcquiredMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            TargetAcquiredMinTimeBetweenPlay = br.ReadInt32();
            AllClearMinTimeInStateToTrigger = br.ReadInt32();
            AllClearMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            AllClearMinTimeBetweenPlay = br.ReadInt32();
            PlaneWarningStallMinTimeInStateToTrigger = br.ReadInt32();
            PlaneWarningStallMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            PlaneWarningStallMinTimeBetweenPlay = br.ReadInt32();
            AltitudeWarningLowMinTimeInStateToTrigger = br.ReadInt32();
            AltitudeWarningLowMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            AltitudeWarningLowMinTimeBetweenPlay = br.ReadInt32();
            AltitudeWarningLowDownProbeLength = br.ReadSingle();
            AltitudeWarningHighMinTimeInStateToTrigger = br.ReadInt32();
            AltitudeWarningHighMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            AltitudeWarningHighMinTimeBetweenPlay = br.ReadInt32();
            Engine1FireMinTimeInStateToTrigger = br.ReadInt32();
            Engine1FireMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            Engine1FireMinTimeBetweenPlay = br.ReadInt32();
            Engine2FireMinTimeInStateToTrigger = br.ReadInt32();
            Engine2FireMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            Engine2FireMinTimeBetweenPlay = br.ReadInt32();
            Engine3FireMinTimeInStateToTrigger = br.ReadInt32();
            Engine3FireMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            Engine3FireMinTimeBetweenPlay = br.ReadInt32();
            Engine4FireMinTimeInStateToTrigger = br.ReadInt32();
            Engine4FireMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            Engine4FireMinTimeBetweenPlay = br.ReadInt32();
            DamagedSeriousMinTimeInStateToTrigger = br.ReadInt32();
            DamagedSeriousMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            DamagedSeriousMinTimeBetweenPlay = br.ReadInt32();
            DamagedCriticalMinTimeInStateToTrigger = br.ReadInt32();
            DamagedCriticalMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            DamagedCriticalMinTimeBetweenPlay = br.ReadInt32();
            OverspeedMinTimeInStateToTrigger = br.ReadInt32();
            OverspeedMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            OverspeedMinTimeBetweenPlay = br.ReadInt32();
            TerrainMinTimeInStateToTrigger = br.ReadInt32();
            TerrainMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            TerrainMinTimeBetweenPlay = br.ReadInt32();
            TerrainForwardProbeLength = br.ReadSingle();
            PullUpMinTimeInStateToTrigger = br.ReadInt32();
            PullUpMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            PullUpMinTimeBetweenPlay = br.ReadInt32();
            PullUpMaxTimeSinceTerrainTriggerToPlay = br.ReadInt32();
            LowFuelMinTimeInStateToTrigger = br.ReadInt32();
            LowFuelMaxTimeBetweenTriggerAndPlay = br.ReadInt32();
            LowFuelMinTimeBetweenPlay = br.ReadInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(MinTimeBetweenDamageReports);
            bw.Write(TargetedLockedMinTimeInStateToTrigger);
            bw.Write(TargetedLockedMaxTimeBetweenTriggerAndPlay);
            bw.Write(TargetedLockedMinTimeBetweenPlay);
            bw.Write(MissileFiredMinTimeInStateToTrigger);
            bw.Write(MissileFiredMaxTimeBetweenTriggerAndPlay);
            bw.Write(MissileFiredMinTimeBetweenPlay);
            bw.Write(AcquiringTargetMinTimeInStateToTrigger);
            bw.Write(AcquiringTargetMaxTimeBetweenTriggerAndPlay);
            bw.Write(AcquiringTargetMinTimeBetweenPlay);
            bw.Write(TargetAcquiredMinTimeInStateToTrigger);
            bw.Write(TargetAcquiredMaxTimeBetweenTriggerAndPlay);
            bw.Write(TargetAcquiredMinTimeBetweenPlay);
            bw.Write(AllClearMinTimeInStateToTrigger);
            bw.Write(AllClearMaxTimeBetweenTriggerAndPlay);
            bw.Write(AllClearMinTimeBetweenPlay);
            bw.Write(PlaneWarningStallMinTimeInStateToTrigger);
            bw.Write(PlaneWarningStallMaxTimeBetweenTriggerAndPlay);
            bw.Write(PlaneWarningStallMinTimeBetweenPlay);
            bw.Write(AltitudeWarningLowMinTimeInStateToTrigger);
            bw.Write(AltitudeWarningLowMaxTimeBetweenTriggerAndPlay);
            bw.Write(AltitudeWarningLowMinTimeBetweenPlay);
            bw.Write(AltitudeWarningLowDownProbeLength);
            bw.Write(AltitudeWarningHighMinTimeInStateToTrigger);
            bw.Write(AltitudeWarningHighMaxTimeBetweenTriggerAndPlay);
            bw.Write(AltitudeWarningHighMinTimeBetweenPlay);
            bw.Write(Engine1FireMinTimeInStateToTrigger);
            bw.Write(Engine1FireMaxTimeBetweenTriggerAndPlay);
            bw.Write(Engine1FireMinTimeBetweenPlay);
            bw.Write(Engine2FireMinTimeInStateToTrigger);
            bw.Write(Engine2FireMaxTimeBetweenTriggerAndPlay);
            bw.Write(Engine2FireMinTimeBetweenPlay);
            bw.Write(Engine3FireMinTimeInStateToTrigger);
            bw.Write(Engine3FireMaxTimeBetweenTriggerAndPlay);
            bw.Write(Engine3FireMinTimeBetweenPlay);
            bw.Write(Engine4FireMinTimeInStateToTrigger);
            bw.Write(Engine4FireMaxTimeBetweenTriggerAndPlay);
            bw.Write(Engine4FireMinTimeBetweenPlay);
            bw.Write(DamagedSeriousMinTimeInStateToTrigger);
            bw.Write(DamagedSeriousMaxTimeBetweenTriggerAndPlay);
            bw.Write(DamagedSeriousMinTimeBetweenPlay);
            bw.Write(DamagedCriticalMinTimeInStateToTrigger);
            bw.Write(DamagedCriticalMaxTimeBetweenTriggerAndPlay);
            bw.Write(DamagedCriticalMinTimeBetweenPlay);
            bw.Write(OverspeedMinTimeInStateToTrigger);
            bw.Write(OverspeedMaxTimeBetweenTriggerAndPlay);
            bw.Write(OverspeedMinTimeBetweenPlay);
            bw.Write(TerrainMinTimeInStateToTrigger);
            bw.Write(TerrainMaxTimeBetweenTriggerAndPlay);
            bw.Write(TerrainMinTimeBetweenPlay);
            bw.Write(TerrainForwardProbeLength);
            bw.Write(PullUpMinTimeInStateToTrigger);
            bw.Write(PullUpMaxTimeBetweenTriggerAndPlay);
            bw.Write(PullUpMinTimeBetweenPlay);
            bw.Write(PullUpMaxTimeSinceTerrainTriggerToPlay);
            bw.Write(LowFuelMinTimeInStateToTrigger);
            bw.Write(LowFuelMaxTimeBetweenTriggerAndPlay);
            bw.Write(LowFuelMinTimeBetweenPlay);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "MinTimeBetweenDamageReports", MinTimeBetweenDamageReports.ToString());
            RelXml.ValueTag(sb, indent, "TargetedLockedMinTimeInStateToTrigger", TargetedLockedMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "TargetedLockedMaxTimeBetweenTriggerAndPlay", TargetedLockedMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "TargetedLockedMinTimeBetweenPlay", TargetedLockedMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "MissileFiredMinTimeInStateToTrigger", MissileFiredMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "MissileFiredMaxTimeBetweenTriggerAndPlay", MissileFiredMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "MissileFiredMinTimeBetweenPlay", MissileFiredMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "AcquiringTargetMinTimeInStateToTrigger", AcquiringTargetMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "AcquiringTargetMaxTimeBetweenTriggerAndPlay", AcquiringTargetMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "AcquiringTargetMinTimeBetweenPlay", AcquiringTargetMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "TargetAcquiredMinTimeInStateToTrigger", TargetAcquiredMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "TargetAcquiredMaxTimeBetweenTriggerAndPlay", TargetAcquiredMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "TargetAcquiredMinTimeBetweenPlay", TargetAcquiredMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "AllClearMinTimeInStateToTrigger", AllClearMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "AllClearMaxTimeBetweenTriggerAndPlay", AllClearMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "AllClearMinTimeBetweenPlay", AllClearMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "PlaneWarningStallMinTimeInStateToTrigger", PlaneWarningStallMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "PlaneWarningStallMaxTimeBetweenTriggerAndPlay", PlaneWarningStallMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "PlaneWarningStallMinTimeBetweenPlay", PlaneWarningStallMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "AltitudeWarningLowMinTimeInStateToTrigger", AltitudeWarningLowMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "AltitudeWarningLowMaxTimeBetweenTriggerAndPlay", AltitudeWarningLowMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "AltitudeWarningLowMinTimeBetweenPlay", AltitudeWarningLowMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "AltitudeWarningLowDownProbeLength", FloatUtil.ToString(AltitudeWarningLowDownProbeLength));
            RelXml.ValueTag(sb, indent, "AltitudeWarningHighMinTimeInStateToTrigger", AltitudeWarningHighMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "AltitudeWarningHighMaxTimeBetweenTriggerAndPlay", AltitudeWarningHighMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "AltitudeWarningHighMinTimeBetweenPlay", AltitudeWarningHighMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "Engine1FireMinTimeInStateToTrigger", Engine1FireMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "Engine1FireMaxTimeBetweenTriggerAndPlay", Engine1FireMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "Engine1FireMinTimeBetweenPlay", Engine1FireMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "Engine2FireMinTimeInStateToTrigger", Engine2FireMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "Engine2FireMaxTimeBetweenTriggerAndPlay", Engine2FireMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "Engine2FireMinTimeBetweenPlay", Engine2FireMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "Engine3FireMinTimeInStateToTrigger", Engine3FireMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "Engine3FireMaxTimeBetweenTriggerAndPlay", Engine3FireMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "Engine3FireMinTimeBetweenPlay", Engine3FireMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "Engine4FireMinTimeInStateToTrigger", Engine4FireMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "Engine4FireMaxTimeBetweenTriggerAndPlay", Engine4FireMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "Engine4FireMinTimeBetweenPlay", Engine4FireMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "DamagedSeriousMinTimeInStateToTrigger", DamagedSeriousMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "DamagedSeriousMaxTimeBetweenTriggerAndPlay", DamagedSeriousMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "DamagedSeriousMinTimeBetweenPlay", DamagedSeriousMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "DamagedCriticalMinTimeInStateToTrigger", DamagedCriticalMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "DamagedCriticalMaxTimeBetweenTriggerAndPlay", DamagedCriticalMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "DamagedCriticalMinTimeBetweenPlay", DamagedCriticalMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "OverspeedMinTimeInStateToTrigger", OverspeedMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "OverspeedMaxTimeBetweenTriggerAndPlay", OverspeedMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "OverspeedMinTimeBetweenPlay", OverspeedMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "TerrainMinTimeInStateToTrigger", TerrainMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "TerrainMaxTimeBetweenTriggerAndPlay", TerrainMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "TerrainMinTimeBetweenPlay", TerrainMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "TerrainForwardProbeLength", FloatUtil.ToString(TerrainForwardProbeLength));
            RelXml.ValueTag(sb, indent, "PullUpMinTimeInStateToTrigger", PullUpMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "PullUpMaxTimeBetweenTriggerAndPlay", PullUpMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "PullUpMinTimeBetweenPlay", PullUpMinTimeBetweenPlay.ToString());
            RelXml.ValueTag(sb, indent, "PullUpMaxTimeSinceTerrainTriggerToPlay", PullUpMaxTimeSinceTerrainTriggerToPlay.ToString());
            RelXml.ValueTag(sb, indent, "LowFuelMinTimeInStateToTrigger", LowFuelMinTimeInStateToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "LowFuelMaxTimeBetweenTriggerAndPlay", LowFuelMaxTimeBetweenTriggerAndPlay.ToString());
            RelXml.ValueTag(sb, indent, "LowFuelMinTimeBetweenPlay", LowFuelMinTimeBetweenPlay.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            MinTimeBetweenDamageReports = Xml.GetChildIntAttribute(node, "MinTimeBetweenDamageReports", "value");
            TargetedLockedMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "TargetedLockedMinTimeInStateToTrigger", "value");
            TargetedLockedMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "TargetedLockedMaxTimeBetweenTriggerAndPlay", "value");
            TargetedLockedMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "TargetedLockedMinTimeBetweenPlay", "value");
            MissileFiredMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "MissileFiredMinTimeInStateToTrigger", "value");
            MissileFiredMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "MissileFiredMaxTimeBetweenTriggerAndPlay", "value");
            MissileFiredMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "MissileFiredMinTimeBetweenPlay", "value");
            AcquiringTargetMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "AcquiringTargetMinTimeInStateToTrigger", "value");
            AcquiringTargetMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "AcquiringTargetMaxTimeBetweenTriggerAndPlay", "value");
            AcquiringTargetMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "AcquiringTargetMinTimeBetweenPlay", "value");
            TargetAcquiredMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "TargetAcquiredMinTimeInStateToTrigger", "value");
            TargetAcquiredMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "TargetAcquiredMaxTimeBetweenTriggerAndPlay", "value");
            TargetAcquiredMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "TargetAcquiredMinTimeBetweenPlay", "value");
            AllClearMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "AllClearMinTimeInStateToTrigger", "value");
            AllClearMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "AllClearMaxTimeBetweenTriggerAndPlay", "value");
            AllClearMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "AllClearMinTimeBetweenPlay", "value");
            PlaneWarningStallMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "PlaneWarningStallMinTimeInStateToTrigger", "value");
            PlaneWarningStallMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "PlaneWarningStallMaxTimeBetweenTriggerAndPlay", "value");
            PlaneWarningStallMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "PlaneWarningStallMinTimeBetweenPlay", "value");
            AltitudeWarningLowMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "AltitudeWarningLowMinTimeInStateToTrigger", "value");
            AltitudeWarningLowMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "AltitudeWarningLowMaxTimeBetweenTriggerAndPlay", "value");
            AltitudeWarningLowMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "AltitudeWarningLowMinTimeBetweenPlay", "value");
            AltitudeWarningLowDownProbeLength = Xml.GetChildFloatAttribute(node, "AltitudeWarningLowDownProbeLength", "value");
            AltitudeWarningHighMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "AltitudeWarningHighMinTimeInStateToTrigger", "value");
            AltitudeWarningHighMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "AltitudeWarningHighMaxTimeBetweenTriggerAndPlay", "value");
            AltitudeWarningHighMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "AltitudeWarningHighMinTimeBetweenPlay", "value");
            Engine1FireMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "Engine1FireMinTimeInStateToTrigger", "value");
            Engine1FireMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "Engine1FireMaxTimeBetweenTriggerAndPlay", "value");
            Engine1FireMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "Engine1FireMinTimeBetweenPlay", "value");
            Engine2FireMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "Engine2FireMinTimeInStateToTrigger", "value");
            Engine2FireMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "Engine2FireMaxTimeBetweenTriggerAndPlay", "value");
            Engine2FireMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "Engine2FireMinTimeBetweenPlay", "value");
            Engine3FireMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "Engine3FireMinTimeInStateToTrigger", "value");
            Engine3FireMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "Engine3FireMaxTimeBetweenTriggerAndPlay", "value");
            Engine3FireMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "Engine3FireMinTimeBetweenPlay", "value");
            Engine4FireMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "Engine4FireMinTimeInStateToTrigger", "value");
            Engine4FireMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "Engine4FireMaxTimeBetweenTriggerAndPlay", "value");
            Engine4FireMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "Engine4FireMinTimeBetweenPlay", "value");
            DamagedSeriousMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "DamagedSeriousMinTimeInStateToTrigger", "value");
            DamagedSeriousMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "DamagedSeriousMaxTimeBetweenTriggerAndPlay", "value");
            DamagedSeriousMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "DamagedSeriousMinTimeBetweenPlay", "value");
            DamagedCriticalMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "DamagedCriticalMinTimeInStateToTrigger", "value");
            DamagedCriticalMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "DamagedCriticalMaxTimeBetweenTriggerAndPlay", "value");
            DamagedCriticalMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "DamagedCriticalMinTimeBetweenPlay", "value");
            OverspeedMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "OverspeedMinTimeInStateToTrigger", "value");
            OverspeedMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "OverspeedMaxTimeBetweenTriggerAndPlay", "value");
            OverspeedMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "OverspeedMinTimeBetweenPlay", "value");
            TerrainMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "TerrainMinTimeInStateToTrigger", "value");
            TerrainMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "TerrainMaxTimeBetweenTriggerAndPlay", "value");
            TerrainMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "TerrainMinTimeBetweenPlay", "value");
            TerrainForwardProbeLength = Xml.GetChildFloatAttribute(node, "TerrainForwardProbeLength", "value");
            PullUpMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "PullUpMinTimeInStateToTrigger", "value");
            PullUpMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "PullUpMaxTimeBetweenTriggerAndPlay", "value");
            PullUpMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "PullUpMinTimeBetweenPlay", "value");
            PullUpMaxTimeSinceTerrainTriggerToPlay = Xml.GetChildIntAttribute(node, "PullUpMaxTimeSinceTerrainTriggerToPlay", "value");
            LowFuelMinTimeInStateToTrigger = Xml.GetChildIntAttribute(node, "LowFuelMinTimeInStateToTrigger", "value");
            LowFuelMaxTimeBetweenTriggerAndPlay = Xml.GetChildIntAttribute(node, "LowFuelMaxTimeBetweenTriggerAndPlay", "value");
            LowFuelMinTimeBetweenPlay = Xml.GetChildIntAttribute(node, "LowFuelMinTimeBetweenPlay", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151PedWallaSpeechSettingsListItem : IMetaXmlItem
    {
        public MetaHash PedWallaSettings { get; set; }
        public float Weight { get; set; }
        public float PedDensityThreshold { get; set; }
        public byte IsMale { get; set; }
        public byte IsGang { get; set; }
        public short padding00 { get; set; }

        public Dat151PedWallaSpeechSettingsListItem()
        { }
        public Dat151PedWallaSpeechSettingsListItem(BinaryReader br)
        {
            PedWallaSettings = br.ReadUInt32();
            Weight = br.ReadSingle();
            PedDensityThreshold = br.ReadSingle();
            IsMale = br.ReadByte();
            IsGang = br.ReadByte();
            padding00 = br.ReadInt16();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(PedWallaSettings);
            bw.Write(Weight);
            bw.Write(PedDensityThreshold);
            bw.Write(IsMale);
            bw.Write(IsGang);
            bw.Write(padding00);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "PedWallaSettings", RelXml.HashString(PedWallaSettings));
            RelXml.ValueTag(sb, indent, "Weight", FloatUtil.ToString(Weight));
            RelXml.ValueTag(sb, indent, "PedDensityThreshold", FloatUtil.ToString(PedDensityThreshold));
            RelXml.ValueTag(sb, indent, "IsMale", IsMale.ToString());
            RelXml.ValueTag(sb, indent, "IsGang", IsGang.ToString());
        }
        public void ReadXml(XmlNode node)
        {
            PedWallaSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "PedWallaSettings"));
            Weight = Xml.GetChildFloatAttribute(node, "Weight", "value");
            PedDensityThreshold = Xml.GetChildFloatAttribute(node, "PedDensityThreshold", "value");
            IsMale = (byte)Xml.GetChildUIntAttribute(node, "IsMale", "value");
            IsGang = (byte)Xml.GetChildUIntAttribute(node, "IsGang", "value");
        }
        public override string ToString()
        {
            return PedWallaSettings.ToString() + ": " + Weight.ToString() + ", " + PedDensityThreshold.ToString() + ", " + IsMale.ToString() + ", " + IsGang.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151PedWallaSpeechSettingsList : Dat151RelData
    {
        public int ItemCount { get; set; }
        public Dat151PedWallaSpeechSettingsListItem[] Items { get; set; }

        public Dat151PedWallaSpeechSettingsList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.PedWallaSpeechSettingsList;
            TypeID = (byte)Type;
        }
        public Dat151PedWallaSpeechSettingsList(RelData d, BinaryReader br) : base(d, br)
        {
            ItemCount = br.ReadInt32();
            Items = new Dat151PedWallaSpeechSettingsListItem[ItemCount];
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i] = new Dat151PedWallaSpeechSettingsListItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(ItemCount);
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, Items, indent, "Items");
        }
        public override void ReadXml(XmlNode node)
        {
            Items = XmlRel.ReadItemArray<Dat151PedWallaSpeechSettingsListItem>(node, "Items");
            ItemCount = (Items?.Length ?? 0);
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            if (Items != null)
            {
                foreach (var item in Items)
                {
                    list.Add(item.PedWallaSettings);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151CopDispatchInteractionSettings : Dat151RelData
    {
        public int MinTimeBetweenInteractions { get; set; }
        public int MinTimeBetweenInteractionsVariance { get; set; }
        public int FirstLinePredelay { get; set; }
        public int FirstLinePredelayVariance { get; set; }
        public int SecondLinePredelay { get; set; }
        public int SecondLinePredelayVariance { get; set; }
        public int ScannerPredelay { get; set; }
        public int ScannerPredelayVariance { get; set; }
        public int MinTimeBetweenSpottedAndVehicleLinePlays { get; set; }
        public int MinTimeBetweenSpottedAndVehicleLinePlaysVariance { get; set; }
        public int MaxTimeAfterVehicleChangeSpottedLineCanPlay { get; set; }
        public int TimePassedSinceLastLineToForceVoiceChange { get; set; }
        public int NumCopsKilledToForceVoiceChange { get; set; }
        public int SuspectCrashedVehicleTimeBetween { get; set; }
        public int SuspectCrashedVehicleTimeBetweenVariance { get; set; }
        public int SuspectEnteredFreewayTimeBetween { get; set; }
        public int SuspectEnteredFreewayTimeBetweenVariance { get; set; }
        public int SuspectEnteredMetroTimeBetween { get; set; }
        public int SuspectEnteredMetroTimeBetweenVariance { get; set; }
        public int SuspectIsInCarTimeBetween { get; set; }
        public int SuspectIsInCarTimeBetweenVariance { get; set; }
        public int SuspectIsOnFootTimeBetween { get; set; }
        public int SuspectIsOnFootTimeBetweenVariance { get; set; }
        public int SuspectIsOnMotorcycleTimeBetween { get; set; }
        public int SuspectIsOnMotorcycleTimeBetweenVariance { get; set; }
        public int SuspectLeftFreewayTimeBetween { get; set; }
        public int SuspectLeftFreewayTimeBetweenVariance { get; set; }
        public int RequestBackupTimeBetween { get; set; }
        public int RequestBackupTimeBetweenVariance { get; set; }
        public int AcknowledgeSituationTimeBetween { get; set; }
        public int AcknowledgeSituationTimeBetweenVariance { get; set; }
        public float RespondingDispatchProbability { get; set; }
        public int GuidanceDispatchTimeBetween { get; set; }
        public int GuidanceDispatchTimeBetweenVariance { get; set; }
        public int GuidanceDispatchTimeNotSpottedToTrigger { get; set; }
        public float GuidanceDispatchProbabilityOfMegaphoneLine { get; set; }
        public int HeliMaydayDispatchTimeBetween { get; set; }
        public int HeliMaydayDispatchTimeBetweenVariance { get; set; }
        public int ShotAtHeliTimeBetween { get; set; }
        public int ShotAtHeliTimeBetweenVariance { get; set; }
        public int HeliApproachingDispatchTimeBetween { get; set; }
        public int HeliApproachingDispatchTimeBetweenVariance { get; set; }

        public Dat151CopDispatchInteractionSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.CopDispatchInteractionSettings;
            TypeID = (byte)Type;
        }
        public Dat151CopDispatchInteractionSettings(RelData d, BinaryReader br) : base(d, br)
        {
            MinTimeBetweenInteractions = br.ReadInt32();
            MinTimeBetweenInteractionsVariance = br.ReadInt32();
            FirstLinePredelay = br.ReadInt32();
            FirstLinePredelayVariance = br.ReadInt32();
            SecondLinePredelay = br.ReadInt32();
            SecondLinePredelayVariance = br.ReadInt32();
            ScannerPredelay = br.ReadInt32();
            ScannerPredelayVariance = br.ReadInt32();
            MinTimeBetweenSpottedAndVehicleLinePlays = br.ReadInt32();
            MinTimeBetweenSpottedAndVehicleLinePlaysVariance = br.ReadInt32();
            MaxTimeAfterVehicleChangeSpottedLineCanPlay = br.ReadInt32();
            TimePassedSinceLastLineToForceVoiceChange = br.ReadInt32();
            NumCopsKilledToForceVoiceChange = br.ReadInt32();
            SuspectCrashedVehicleTimeBetween = br.ReadInt32();
            SuspectCrashedVehicleTimeBetweenVariance = br.ReadInt32();
            SuspectEnteredFreewayTimeBetween = br.ReadInt32();
            SuspectEnteredFreewayTimeBetweenVariance = br.ReadInt32();
            SuspectEnteredMetroTimeBetween = br.ReadInt32();
            SuspectEnteredMetroTimeBetweenVariance = br.ReadInt32();
            SuspectIsInCarTimeBetween = br.ReadInt32();
            SuspectIsInCarTimeBetweenVariance = br.ReadInt32();
            SuspectIsOnFootTimeBetween = br.ReadInt32();
            SuspectIsOnFootTimeBetweenVariance = br.ReadInt32();
            SuspectIsOnMotorcycleTimeBetween = br.ReadInt32();
            SuspectIsOnMotorcycleTimeBetweenVariance = br.ReadInt32();
            SuspectLeftFreewayTimeBetween = br.ReadInt32();
            SuspectLeftFreewayTimeBetweenVariance = br.ReadInt32();
            RequestBackupTimeBetween = br.ReadInt32();
            RequestBackupTimeBetweenVariance = br.ReadInt32();
            AcknowledgeSituationTimeBetween = br.ReadInt32();
            AcknowledgeSituationTimeBetweenVariance = br.ReadInt32();
            RespondingDispatchProbability = br.ReadSingle();
            GuidanceDispatchTimeBetween = br.ReadInt32();
            GuidanceDispatchTimeBetweenVariance = br.ReadInt32();
            GuidanceDispatchTimeNotSpottedToTrigger = br.ReadInt32();
            GuidanceDispatchProbabilityOfMegaphoneLine = br.ReadSingle();
            HeliMaydayDispatchTimeBetween = br.ReadInt32();
            HeliMaydayDispatchTimeBetweenVariance = br.ReadInt32();
            ShotAtHeliTimeBetween = br.ReadInt32();
            ShotAtHeliTimeBetweenVariance = br.ReadInt32();
            HeliApproachingDispatchTimeBetween = br.ReadInt32();
            HeliApproachingDispatchTimeBetweenVariance = br.ReadInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(MinTimeBetweenInteractions);
            bw.Write(MinTimeBetweenInteractionsVariance);
            bw.Write(FirstLinePredelay);
            bw.Write(FirstLinePredelayVariance);
            bw.Write(SecondLinePredelay);
            bw.Write(SecondLinePredelayVariance);
            bw.Write(ScannerPredelay);
            bw.Write(ScannerPredelayVariance);
            bw.Write(MinTimeBetweenSpottedAndVehicleLinePlays);
            bw.Write(MinTimeBetweenSpottedAndVehicleLinePlaysVariance);
            bw.Write(MaxTimeAfterVehicleChangeSpottedLineCanPlay);
            bw.Write(TimePassedSinceLastLineToForceVoiceChange);
            bw.Write(NumCopsKilledToForceVoiceChange);
            bw.Write(SuspectCrashedVehicleTimeBetween);
            bw.Write(SuspectCrashedVehicleTimeBetweenVariance);
            bw.Write(SuspectEnteredFreewayTimeBetween);
            bw.Write(SuspectEnteredFreewayTimeBetweenVariance);
            bw.Write(SuspectEnteredMetroTimeBetween);
            bw.Write(SuspectEnteredMetroTimeBetweenVariance);
            bw.Write(SuspectIsInCarTimeBetween);
            bw.Write(SuspectIsInCarTimeBetweenVariance);
            bw.Write(SuspectIsOnFootTimeBetween);
            bw.Write(SuspectIsOnFootTimeBetweenVariance);
            bw.Write(SuspectIsOnMotorcycleTimeBetween);
            bw.Write(SuspectIsOnMotorcycleTimeBetweenVariance);
            bw.Write(SuspectLeftFreewayTimeBetween);
            bw.Write(SuspectLeftFreewayTimeBetweenVariance);
            bw.Write(RequestBackupTimeBetween);
            bw.Write(RequestBackupTimeBetweenVariance);
            bw.Write(AcknowledgeSituationTimeBetween);
            bw.Write(AcknowledgeSituationTimeBetweenVariance);
            bw.Write(RespondingDispatchProbability);
            bw.Write(GuidanceDispatchTimeBetween);
            bw.Write(GuidanceDispatchTimeBetweenVariance);
            bw.Write(GuidanceDispatchTimeNotSpottedToTrigger);
            bw.Write(GuidanceDispatchProbabilityOfMegaphoneLine);
            bw.Write(HeliMaydayDispatchTimeBetween);
            bw.Write(HeliMaydayDispatchTimeBetweenVariance);
            bw.Write(ShotAtHeliTimeBetween);
            bw.Write(ShotAtHeliTimeBetweenVariance);
            bw.Write(HeliApproachingDispatchTimeBetween);
            bw.Write(HeliApproachingDispatchTimeBetweenVariance);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "MinTimeBetweenInteractions", MinTimeBetweenInteractions.ToString());
            RelXml.ValueTag(sb, indent, "MinTimeBetweenInteractionsVariance", MinTimeBetweenInteractionsVariance.ToString());
            RelXml.ValueTag(sb, indent, "FirstLinePredelay", FirstLinePredelay.ToString());
            RelXml.ValueTag(sb, indent, "FirstLinePredelayVariance", FirstLinePredelayVariance.ToString());
            RelXml.ValueTag(sb, indent, "SecondLinePredelay", SecondLinePredelay.ToString());
            RelXml.ValueTag(sb, indent, "SecondLinePredelayVariance", SecondLinePredelayVariance.ToString());
            RelXml.ValueTag(sb, indent, "ScannerPredelay", ScannerPredelay.ToString());
            RelXml.ValueTag(sb, indent, "ScannerPredelayVariance", ScannerPredelayVariance.ToString());
            RelXml.ValueTag(sb, indent, "MinTimeBetweenSpottedAndVehicleLinePlays", MinTimeBetweenSpottedAndVehicleLinePlays.ToString());
            RelXml.ValueTag(sb, indent, "MinTimeBetweenSpottedAndVehicleLinePlaysVariance", MinTimeBetweenSpottedAndVehicleLinePlaysVariance.ToString());
            RelXml.ValueTag(sb, indent, "MaxTimeAfterVehicleChangeSpottedLineCanPlay", MaxTimeAfterVehicleChangeSpottedLineCanPlay.ToString());
            RelXml.ValueTag(sb, indent, "TimePassedSinceLastLineToForceVoiceChange", TimePassedSinceLastLineToForceVoiceChange.ToString());
            RelXml.ValueTag(sb, indent, "NumCopsKilledToForceVoiceChange", NumCopsKilledToForceVoiceChange.ToString());
            RelXml.ValueTag(sb, indent, "SuspectCrashedVehicleTimeBetween", SuspectCrashedVehicleTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "SuspectCrashedVehicleTimeBetweenVariance", SuspectCrashedVehicleTimeBetweenVariance.ToString());
            RelXml.ValueTag(sb, indent, "SuspectEnteredFreewayTimeBetween", SuspectEnteredFreewayTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "SuspectEnteredFreewayTimeBetweenVariance", SuspectEnteredFreewayTimeBetweenVariance.ToString());
            RelXml.ValueTag(sb, indent, "SuspectEnteredMetroTimeBetween", SuspectEnteredMetroTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "SuspectEnteredMetroTimeBetweenVariance", SuspectEnteredMetroTimeBetweenVariance.ToString());
            RelXml.ValueTag(sb, indent, "SuspectIsInCarTimeBetween", SuspectIsInCarTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "SuspectIsInCarTimeBetweenVariance", SuspectIsInCarTimeBetweenVariance.ToString());
            RelXml.ValueTag(sb, indent, "SuspectIsOnFootTimeBetween", SuspectIsOnFootTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "SuspectIsOnFootTimeBetweenVariance", SuspectIsOnFootTimeBetweenVariance.ToString());
            RelXml.ValueTag(sb, indent, "SuspectIsOnMotorcycleTimeBetween", SuspectIsOnMotorcycleTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "SuspectIsOnMotorcycleTimeBetweenVariance", SuspectIsOnMotorcycleTimeBetweenVariance.ToString());
            RelXml.ValueTag(sb, indent, "SuspectLeftFreewayTimeBetween", SuspectLeftFreewayTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "SuspectLeftFreewayTimeBetweenVariance", SuspectLeftFreewayTimeBetweenVariance.ToString());
            RelXml.ValueTag(sb, indent, "RequestBackupTimeBetween", RequestBackupTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "RequestBackupTimeBetweenVariance", RequestBackupTimeBetweenVariance.ToString());
            RelXml.ValueTag(sb, indent, "AcknowledgeSituationTimeBetween", AcknowledgeSituationTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "AcknowledgeSituationTimeBetweenVariance", AcknowledgeSituationTimeBetweenVariance.ToString());
            RelXml.ValueTag(sb, indent, "RespondingDispatchProbability", FloatUtil.ToString(RespondingDispatchProbability));
            RelXml.ValueTag(sb, indent, "GuidanceDispatchTimeBetween", GuidanceDispatchTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "GuidanceDispatchTimeBetweenVariance", GuidanceDispatchTimeBetweenVariance.ToString());
            RelXml.ValueTag(sb, indent, "GuidanceDispatchTimeNotSpottedToTrigger", GuidanceDispatchTimeNotSpottedToTrigger.ToString());
            RelXml.ValueTag(sb, indent, "GuidanceDispatchProbabilityOfMegaphoneLine", FloatUtil.ToString(GuidanceDispatchProbabilityOfMegaphoneLine));
            RelXml.ValueTag(sb, indent, "HeliMaydayDispatchTimeBetween", HeliMaydayDispatchTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "HeliMaydayDispatchTimeBetweenVariance", HeliMaydayDispatchTimeBetweenVariance.ToString());
            RelXml.ValueTag(sb, indent, "ShotAtHeliTimeBetween", ShotAtHeliTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "ShotAtHeliTimeBetweenVariance", ShotAtHeliTimeBetweenVariance.ToString());
            RelXml.ValueTag(sb, indent, "HeliApproachingDispatchTimeBetween", HeliApproachingDispatchTimeBetween.ToString());
            RelXml.ValueTag(sb, indent, "HeliApproachingDispatchTimeBetweenVariance", HeliApproachingDispatchTimeBetweenVariance.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            MinTimeBetweenInteractions = Xml.GetChildIntAttribute(node, "MinTimeBetweenInteractions", "value");
            MinTimeBetweenInteractionsVariance = Xml.GetChildIntAttribute(node, "MinTimeBetweenInteractionsVariance", "value");
            FirstLinePredelay = Xml.GetChildIntAttribute(node, "FirstLinePredelay", "value");
            FirstLinePredelayVariance = Xml.GetChildIntAttribute(node, "FirstLinePredelayVariance", "value");
            SecondLinePredelay = Xml.GetChildIntAttribute(node, "SecondLinePredelay", "value");
            SecondLinePredelayVariance = Xml.GetChildIntAttribute(node, "SecondLinePredelayVariance", "value");
            ScannerPredelay = Xml.GetChildIntAttribute(node, "ScannerPredelay", "value");
            ScannerPredelayVariance = Xml.GetChildIntAttribute(node, "ScannerPredelayVariance", "value");
            MinTimeBetweenSpottedAndVehicleLinePlays = Xml.GetChildIntAttribute(node, "MinTimeBetweenSpottedAndVehicleLinePlays", "value");
            MinTimeBetweenSpottedAndVehicleLinePlaysVariance = Xml.GetChildIntAttribute(node, "MinTimeBetweenSpottedAndVehicleLinePlaysVariance", "value");
            MaxTimeAfterVehicleChangeSpottedLineCanPlay = Xml.GetChildIntAttribute(node, "MaxTimeAfterVehicleChangeSpottedLineCanPlay", "value");
            TimePassedSinceLastLineToForceVoiceChange = Xml.GetChildIntAttribute(node, "TimePassedSinceLastLineToForceVoiceChange", "value");
            NumCopsKilledToForceVoiceChange = Xml.GetChildIntAttribute(node, "NumCopsKilledToForceVoiceChange", "value");
            SuspectCrashedVehicleTimeBetween = Xml.GetChildIntAttribute(node, "SuspectCrashedVehicleTimeBetween", "value");
            SuspectCrashedVehicleTimeBetweenVariance = Xml.GetChildIntAttribute(node, "SuspectCrashedVehicleTimeBetweenVariance", "value");
            SuspectEnteredFreewayTimeBetween = Xml.GetChildIntAttribute(node, "SuspectEnteredFreewayTimeBetween", "value");
            SuspectEnteredFreewayTimeBetweenVariance = Xml.GetChildIntAttribute(node, "SuspectEnteredFreewayTimeBetweenVariance", "value");
            SuspectEnteredMetroTimeBetween = Xml.GetChildIntAttribute(node, "SuspectEnteredMetroTimeBetween", "value");
            SuspectEnteredMetroTimeBetweenVariance = Xml.GetChildIntAttribute(node, "SuspectEnteredMetroTimeBetweenVariance", "value");
            SuspectIsInCarTimeBetween = Xml.GetChildIntAttribute(node, "SuspectIsInCarTimeBetween", "value");
            SuspectIsInCarTimeBetweenVariance = Xml.GetChildIntAttribute(node, "SuspectIsInCarTimeBetweenVariance", "value");
            SuspectIsOnFootTimeBetween = Xml.GetChildIntAttribute(node, "SuspectIsOnFootTimeBetween", "value");
            SuspectIsOnFootTimeBetweenVariance = Xml.GetChildIntAttribute(node, "SuspectIsOnFootTimeBetweenVariance", "value");
            SuspectIsOnMotorcycleTimeBetween = Xml.GetChildIntAttribute(node, "SuspectIsOnMotorcycleTimeBetween", "value");
            SuspectIsOnMotorcycleTimeBetweenVariance = Xml.GetChildIntAttribute(node, "SuspectIsOnMotorcycleTimeBetweenVariance", "value");
            SuspectLeftFreewayTimeBetween = Xml.GetChildIntAttribute(node, "SuspectLeftFreewayTimeBetween", "value");
            SuspectLeftFreewayTimeBetweenVariance = Xml.GetChildIntAttribute(node, "SuspectLeftFreewayTimeBetweenVariance", "value");
            RequestBackupTimeBetween = Xml.GetChildIntAttribute(node, "RequestBackupTimeBetween", "value");
            RequestBackupTimeBetweenVariance = Xml.GetChildIntAttribute(node, "RequestBackupTimeBetweenVariance", "value");
            AcknowledgeSituationTimeBetween = Xml.GetChildIntAttribute(node, "AcknowledgeSituationTimeBetween", "value");
            AcknowledgeSituationTimeBetweenVariance = Xml.GetChildIntAttribute(node, "AcknowledgeSituationTimeBetweenVariance", "value");
            RespondingDispatchProbability = Xml.GetChildFloatAttribute(node, "RespondingDispatchProbability", "value");
            GuidanceDispatchTimeBetween = Xml.GetChildIntAttribute(node, "GuidanceDispatchTimeBetween", "value");
            GuidanceDispatchTimeBetweenVariance = Xml.GetChildIntAttribute(node, "GuidanceDispatchTimeBetweenVariance", "value");
            GuidanceDispatchTimeNotSpottedToTrigger = Xml.GetChildIntAttribute(node, "GuidanceDispatchTimeNotSpottedToTrigger", "value");
            GuidanceDispatchProbabilityOfMegaphoneLine = Xml.GetChildFloatAttribute(node, "GuidanceDispatchProbabilityOfMegaphoneLine", "value");
            HeliMaydayDispatchTimeBetween = Xml.GetChildIntAttribute(node, "HeliMaydayDispatchTimeBetween", "value");
            HeliMaydayDispatchTimeBetweenVariance = Xml.GetChildIntAttribute(node, "HeliMaydayDispatchTimeBetweenVariance", "value");
            ShotAtHeliTimeBetween = Xml.GetChildIntAttribute(node, "ShotAtHeliTimeBetween", "value");
            ShotAtHeliTimeBetweenVariance = Xml.GetChildIntAttribute(node, "ShotAtHeliTimeBetweenVariance", "value");
            HeliApproachingDispatchTimeBetween = Xml.GetChildIntAttribute(node, "HeliApproachingDispatchTimeBetween", "value");
            HeliApproachingDispatchTimeBetweenVariance = Xml.GetChildIntAttribute(node, "HeliApproachingDispatchTimeBetweenVariance", "value");
        }
    }

    [TC(typeof(EXP))]
    public class Dat151RandomisedRadioEmitterSettings : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public float VehicleEmitterBias { get; set; }
        public MetaHash StaticEmitter { get; set; }
        public float StaticEmitterMinTime { get; set; }
        public float StaticEmitterMaxTime { get; set; }
        public float StaticEmitterMinFadeRadius { get; set; }
        public float StaticEmitterMaxFadeRadius { get; set; }
        public uint StaticEmitterMinRetriggerTime { get; set; }
        public uint StaticEmitterMaxRetriggerTime { get; set; }
        public MetaHash VehicleEmitter { get; set; }
        public float VehicleEmitterStaticEmitterMinTime { get; set; }
        public float VehicleEmitterStaticEmitterMaxTime { get; set; }
        public uint VehicleEmitterMinAttackTime { get; set; }
        public uint VehicleEmitterMaxAttackTime { get; set; }
        public uint VehicleEmitterMinHoldTime { get; set; }
        public uint VehicleEmitterMaxHoldTime { get; set; }
        public uint VehicleEmitterMinReleaseTime { get; set; }
        public uint VehicleEmitterMaxReleaseTime { get; set; }
        public float VehicleEmitterMinPanAngleChange { get; set; }
        public float VehicleEmitterMaxPanAngleChange { get; set; }
        public uint VehicleEmitterRetriggerTimeMin { get; set; }
        public uint VehicleEmitterRetriggerTimeMax { get; set; }

        public Dat151RandomisedRadioEmitterSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.RandomisedRadioEmitterSettings;
            TypeID = (byte)Type;
        }
        public Dat151RandomisedRadioEmitterSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            VehicleEmitterBias = br.ReadSingle();
            StaticEmitter = br.ReadUInt32();
            StaticEmitterMinTime = br.ReadSingle();
            StaticEmitterMaxTime = br.ReadSingle();
            StaticEmitterMinFadeRadius = br.ReadSingle();
            StaticEmitterMaxFadeRadius = br.ReadSingle();
            StaticEmitterMinRetriggerTime = br.ReadUInt32();
            StaticEmitterMaxRetriggerTime = br.ReadUInt32();
            VehicleEmitter = br.ReadUInt32();
            VehicleEmitterStaticEmitterMinTime = br.ReadSingle();
            VehicleEmitterStaticEmitterMaxTime = br.ReadSingle();
            VehicleEmitterMinAttackTime = br.ReadUInt32();
            VehicleEmitterMaxAttackTime = br.ReadUInt32();
            VehicleEmitterMinHoldTime = br.ReadUInt32();
            VehicleEmitterMaxHoldTime = br.ReadUInt32();
            VehicleEmitterMinReleaseTime = br.ReadUInt32();
            VehicleEmitterMaxReleaseTime = br.ReadUInt32();
            VehicleEmitterMinPanAngleChange = br.ReadSingle();
            VehicleEmitterMaxPanAngleChange = br.ReadSingle();
            VehicleEmitterRetriggerTimeMin = br.ReadUInt32();
            VehicleEmitterRetriggerTimeMax = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(VehicleEmitterBias);
            bw.Write(StaticEmitter);
            bw.Write(StaticEmitterMinTime);
            bw.Write(StaticEmitterMaxTime);
            bw.Write(StaticEmitterMinFadeRadius);
            bw.Write(StaticEmitterMaxFadeRadius);
            bw.Write(StaticEmitterMinRetriggerTime);
            bw.Write(StaticEmitterMaxRetriggerTime);
            bw.Write(VehicleEmitter);
            bw.Write(VehicleEmitterStaticEmitterMinTime);
            bw.Write(VehicleEmitterStaticEmitterMaxTime);
            bw.Write(VehicleEmitterMinAttackTime);
            bw.Write(VehicleEmitterMaxAttackTime);
            bw.Write(VehicleEmitterMinHoldTime);
            bw.Write(VehicleEmitterMaxHoldTime);
            bw.Write(VehicleEmitterMinReleaseTime);
            bw.Write(VehicleEmitterMaxReleaseTime);
            bw.Write(VehicleEmitterMinPanAngleChange);
            bw.Write(VehicleEmitterMaxPanAngleChange);
            bw.Write(VehicleEmitterRetriggerTimeMin);
            bw.Write(VehicleEmitterRetriggerTimeMax);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "VehicleEmitterBias", FloatUtil.ToString(VehicleEmitterBias));
            RelXml.StringTag(sb, indent, "StaticEmitter", RelXml.HashString(StaticEmitter));
            RelXml.ValueTag(sb, indent, "StaticEmitterMinTime", FloatUtil.ToString(StaticEmitterMinTime));
            RelXml.ValueTag(sb, indent, "StaticEmitterMaxTime", FloatUtil.ToString(StaticEmitterMaxTime));
            RelXml.ValueTag(sb, indent, "StaticEmitterMinFadeRadius", FloatUtil.ToString(StaticEmitterMinFadeRadius));
            RelXml.ValueTag(sb, indent, "StaticEmitterMaxFadeRadius", FloatUtil.ToString(StaticEmitterMaxFadeRadius));
            RelXml.ValueTag(sb, indent, "StaticEmitterMinRetriggerTime", StaticEmitterMinRetriggerTime.ToString());
            RelXml.ValueTag(sb, indent, "StaticEmitterMaxRetriggerTime", StaticEmitterMaxRetriggerTime.ToString());
            RelXml.StringTag(sb, indent, "VehicleEmitter", RelXml.HashString(VehicleEmitter));
            RelXml.ValueTag(sb, indent, "VehicleEmitterStaticEmitterMinTime", FloatUtil.ToString(VehicleEmitterStaticEmitterMinTime));
            RelXml.ValueTag(sb, indent, "VehicleEmitterStaticEmitterMaxTime", FloatUtil.ToString(VehicleEmitterStaticEmitterMaxTime));
            RelXml.ValueTag(sb, indent, "VehicleEmitterMinAttackTime", VehicleEmitterMinAttackTime.ToString());
            RelXml.ValueTag(sb, indent, "VehicleEmitterMaxAttackTime", VehicleEmitterMaxAttackTime.ToString());
            RelXml.ValueTag(sb, indent, "VehicleEmitterMinHoldTime", VehicleEmitterMinHoldTime.ToString());
            RelXml.ValueTag(sb, indent, "VehicleEmitterMaxHoldTime", VehicleEmitterMaxHoldTime.ToString());
            RelXml.ValueTag(sb, indent, "VehicleEmitterMinReleaseTime", VehicleEmitterMinReleaseTime.ToString());
            RelXml.ValueTag(sb, indent, "VehicleEmitterMaxReleaseTime", VehicleEmitterMaxReleaseTime.ToString());
            RelXml.ValueTag(sb, indent, "VehicleEmitterMinPanAngleChange", FloatUtil.ToString(VehicleEmitterMinPanAngleChange));
            RelXml.ValueTag(sb, indent, "VehicleEmitterMaxPanAngleChange", FloatUtil.ToString(VehicleEmitterMaxPanAngleChange));
            RelXml.ValueTag(sb, indent, "VehicleEmitterRetriggerTimeMin", VehicleEmitterRetriggerTimeMin.ToString());
            RelXml.ValueTag(sb, indent, "VehicleEmitterRetriggerTimeMax", VehicleEmitterRetriggerTimeMax.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            VehicleEmitterBias = Xml.GetChildFloatAttribute(node, "VehicleEmitterBias", "value");
            StaticEmitter = XmlRel.GetHash(Xml.GetChildInnerText(node, "StaticEmitter"));
            StaticEmitterMinTime = Xml.GetChildFloatAttribute(node, "StaticEmitterMinTime", "value");
            StaticEmitterMaxTime = Xml.GetChildFloatAttribute(node, "StaticEmitterMaxTime", "value");
            StaticEmitterMinFadeRadius = Xml.GetChildFloatAttribute(node, "StaticEmitterMinFadeRadius", "value");
            StaticEmitterMaxFadeRadius = Xml.GetChildFloatAttribute(node, "StaticEmitterMaxFadeRadius", "value");
            StaticEmitterMinRetriggerTime = Xml.GetChildUIntAttribute(node, "StaticEmitterMinRetriggerTime", "value");
            StaticEmitterMaxRetriggerTime = Xml.GetChildUIntAttribute(node, "StaticEmitterMaxRetriggerTime", "value");
            VehicleEmitter = XmlRel.GetHash(Xml.GetChildInnerText(node, "VehicleEmitter"));
            VehicleEmitterStaticEmitterMinTime = Xml.GetChildFloatAttribute(node, "VehicleEmitterStaticEmitterMinTime", "value");
            VehicleEmitterStaticEmitterMaxTime = Xml.GetChildFloatAttribute(node, "VehicleEmitterStaticEmitterMaxTime", "value");
            VehicleEmitterMinAttackTime = Xml.GetChildUIntAttribute(node, "VehicleEmitterMinAttackTime", "value");
            VehicleEmitterMaxAttackTime = Xml.GetChildUIntAttribute(node, "VehicleEmitterMaxAttackTime", "value");
            VehicleEmitterMinHoldTime = Xml.GetChildUIntAttribute(node, "VehicleEmitterMinHoldTime", "value");
            VehicleEmitterMaxHoldTime = Xml.GetChildUIntAttribute(node, "VehicleEmitterMaxHoldTime", "value");
            VehicleEmitterMinReleaseTime = Xml.GetChildUIntAttribute(node, "VehicleEmitterMinReleaseTime", "value");
            VehicleEmitterMaxReleaseTime = Xml.GetChildUIntAttribute(node, "VehicleEmitterMaxReleaseTime", "value");
            VehicleEmitterMinPanAngleChange = Xml.GetChildFloatAttribute(node, "VehicleEmitterMinPanAngleChange", "value");
            VehicleEmitterMaxPanAngleChange = Xml.GetChildFloatAttribute(node, "VehicleEmitterMaxPanAngleChange", "value");
            VehicleEmitterRetriggerTimeMin = Xml.GetChildUIntAttribute(node, "VehicleEmitterRetriggerTimeMin", "value");
            VehicleEmitterRetriggerTimeMax = Xml.GetChildUIntAttribute(node, "VehicleEmitterRetriggerTimeMax", "value");
        }
        public override MetaHash[] GetGameHashes()
        {
            return new[] { StaticEmitter, VehicleEmitter };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151TennisVocalizationSettings : Dat151RelData
    {
        public float LightNullWeight { get; set; }
        public float LightLiteWeight { get; set; }
        public float LightMedWeight { get; set; }
        public float LightStrongWeight { get; set; }
        // tLite
        public float MediumNullWeight { get; set; }
        public float MediumLiteWeight { get; set; }
        public float MediumMedWeight { get; set; }
        public float MediumStrongWeight { get; set; }
        // tMed
        public float StrongNullWeight { get; set; }
        public float StrongLiteWeight { get; set; }
        public float StrongMedWeight { get; set; }
        public float StrongStrongWeight { get; set; }

        public Dat151TennisVocalizationSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.TennisVocalizationSettings;
            TypeID = (byte)Type;
        }
        public Dat151TennisVocalizationSettings(RelData d, BinaryReader br) : base(d, br)
        {
            LightNullWeight = br.ReadSingle();
            LightLiteWeight = br.ReadSingle();
            LightMedWeight = br.ReadSingle();
            LightStrongWeight = br.ReadSingle();
            MediumNullWeight = br.ReadSingle();
            MediumLiteWeight = br.ReadSingle();
            MediumMedWeight = br.ReadSingle();
            MediumStrongWeight = br.ReadSingle();
            StrongNullWeight = br.ReadSingle();
            StrongLiteWeight = br.ReadSingle();
            StrongMedWeight = br.ReadSingle();
            StrongStrongWeight = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(LightNullWeight);
            bw.Write(LightLiteWeight);
            bw.Write(LightMedWeight);
            bw.Write(LightStrongWeight);
            bw.Write(MediumNullWeight);
            bw.Write(MediumLiteWeight);
            bw.Write(MediumMedWeight);
            bw.Write(MediumStrongWeight);
            bw.Write(StrongNullWeight);
            bw.Write(StrongLiteWeight);
            bw.Write(StrongMedWeight);
            bw.Write(StrongStrongWeight);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "LightNullWeight", FloatUtil.ToString(LightNullWeight));
            RelXml.ValueTag(sb, indent, "LightLiteWeight", FloatUtil.ToString(LightLiteWeight));
            RelXml.ValueTag(sb, indent, "LightMedWeight", FloatUtil.ToString(LightMedWeight));
            RelXml.ValueTag(sb, indent, "LightStrongWeight", FloatUtil.ToString(LightStrongWeight));
            RelXml.ValueTag(sb, indent, "MediumNullWeight", FloatUtil.ToString(MediumNullWeight));
            RelXml.ValueTag(sb, indent, "MediumLiteWeight", FloatUtil.ToString(MediumLiteWeight));
            RelXml.ValueTag(sb, indent, "MediumMedWeight", FloatUtil.ToString(MediumMedWeight));
            RelXml.ValueTag(sb, indent, "MediumStrongWeight", FloatUtil.ToString(MediumStrongWeight));
            RelXml.ValueTag(sb, indent, "StrongNullWeight", FloatUtil.ToString(StrongNullWeight));
            RelXml.ValueTag(sb, indent, "StrongLiteWeight", FloatUtil.ToString(StrongLiteWeight));
            RelXml.ValueTag(sb, indent, "StrongMedWeight", FloatUtil.ToString(StrongMedWeight));
            RelXml.ValueTag(sb, indent, "StrongStrongWeight", FloatUtil.ToString(StrongStrongWeight));
        }
        public override void ReadXml(XmlNode node)
        {
            LightNullWeight = Xml.GetChildFloatAttribute(node, "LightNullWeight", "value");
            LightLiteWeight = Xml.GetChildFloatAttribute(node, "LightLiteWeight", "value");
            LightMedWeight = Xml.GetChildFloatAttribute(node, "LightMedWeight", "value");
            LightStrongWeight = Xml.GetChildFloatAttribute(node, "LightStrongWeight", "value");
            MediumNullWeight = Xml.GetChildFloatAttribute(node, "MediumNullWeight", "value");
            MediumLiteWeight = Xml.GetChildFloatAttribute(node, "MediumLiteWeight", "value");
            MediumMedWeight = Xml.GetChildFloatAttribute(node, "MediumMedWeight", "value");
            MediumStrongWeight = Xml.GetChildFloatAttribute(node, "MediumStrongWeight", "value");
            StrongNullWeight = Xml.GetChildFloatAttribute(node, "StrongNullWeight", "value");
            StrongLiteWeight = Xml.GetChildFloatAttribute(node, "StrongLiteWeight", "value");
            StrongMedWeight = Xml.GetChildFloatAttribute(node, "StrongMedWeight", "value");
            StrongStrongWeight = Xml.GetChildFloatAttribute(node, "StrongStrongWeight", "value");
        }
    }

    [TC(typeof(EXP))]
    public class Dat151SportsCarRevsSettings : Dat151RelData
    {
        public int EngineVolumeBoost { get; set; }
        public int ExhaustVolumeBoost { get; set; }
        public float RollOffBoost { get; set; }
        public int MinTriggerTime { get; set; }
        public int MinRepeatTime { get; set; }
        public float AttackTimeScalar { get; set; }
        public float ReleaseTimeScalar { get; set; }
        public byte SmallReverbSend { get; set; }
        public byte MediumReverbSend { get; set; }
        public byte LargeReverbSend { get; set; }
        public byte padding { get; set; }
        public float JunctionTriggerSpeed { get; set; }
        public float JunctionStopSpeed { get; set; }
        public int JunctionMinDistance { get; set; }
        public int JunctionMaxDistance { get; set; }
        public float PassbyTriggerSpeed { get; set; }
        public float PassbyStopSpeed { get; set; }
        public int PassbyMinDistance { get; set; }
        public int PassbyMaxDistance { get; set; }
        public float PassbyLookaheadTime { get; set; }
        public int ClusterTriggerDistance { get; set; }
        public float ClusterTriggerSpeed { get; set; }

        public Dat151SportsCarRevsSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.SportsCarRevsSettings;
            TypeID = (byte)Type;
        }
        public Dat151SportsCarRevsSettings(RelData d, BinaryReader br) : base(d, br)
        {
            EngineVolumeBoost = br.ReadInt32();
            ExhaustVolumeBoost = br.ReadInt32();
            RollOffBoost = br.ReadSingle();
            MinTriggerTime = br.ReadInt32();
            MinRepeatTime = br.ReadInt32();
            AttackTimeScalar = br.ReadSingle();
            ReleaseTimeScalar = br.ReadSingle();
            SmallReverbSend = br.ReadByte();
            MediumReverbSend = br.ReadByte();
            LargeReverbSend = br.ReadByte();
            padding = br.ReadByte();
            JunctionTriggerSpeed = br.ReadSingle();
            JunctionStopSpeed = br.ReadSingle();
            JunctionMinDistance = br.ReadInt32();
            JunctionMaxDistance = br.ReadInt32();
            PassbyTriggerSpeed = br.ReadSingle();
            PassbyStopSpeed = br.ReadSingle();
            PassbyMinDistance = br.ReadInt32();
            PassbyMaxDistance = br.ReadInt32();
            PassbyLookaheadTime = br.ReadSingle();
            ClusterTriggerDistance = br.ReadInt32();
            ClusterTriggerSpeed = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(EngineVolumeBoost);
            bw.Write(ExhaustVolumeBoost);
            bw.Write(RollOffBoost);
            bw.Write(MinTriggerTime);
            bw.Write(MinRepeatTime);
            bw.Write(AttackTimeScalar);
            bw.Write(ReleaseTimeScalar);
            bw.Write(SmallReverbSend);
            bw.Write(MediumReverbSend);
            bw.Write(LargeReverbSend);
            bw.Write(padding);
            bw.Write(JunctionTriggerSpeed);
            bw.Write(JunctionStopSpeed);
            bw.Write(JunctionMinDistance);
            bw.Write(JunctionMaxDistance);
            bw.Write(PassbyTriggerSpeed);
            bw.Write(PassbyStopSpeed);
            bw.Write(PassbyMinDistance);
            bw.Write(PassbyMaxDistance);
            bw.Write(PassbyLookaheadTime);
            bw.Write(ClusterTriggerDistance);
            bw.Write(ClusterTriggerSpeed);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "EngineVolumeBoost", EngineVolumeBoost.ToString());
            RelXml.ValueTag(sb, indent, "ExhaustVolumeBoost", ExhaustVolumeBoost.ToString());
            RelXml.ValueTag(sb, indent, "RollOffBoost", FloatUtil.ToString(RollOffBoost));
            RelXml.ValueTag(sb, indent, "MinTriggerTime", MinTriggerTime.ToString());
            RelXml.ValueTag(sb, indent, "MinRepeatTime", MinRepeatTime.ToString());
            RelXml.ValueTag(sb, indent, "AttackTimeScalar", FloatUtil.ToString(AttackTimeScalar));
            RelXml.ValueTag(sb, indent, "ReleaseTimeScalar", FloatUtil.ToString(ReleaseTimeScalar));
            RelXml.ValueTag(sb, indent, "SmallReverbSend", SmallReverbSend.ToString());
            RelXml.ValueTag(sb, indent, "MediumReverbSend", MediumReverbSend.ToString());
            RelXml.ValueTag(sb, indent, "LargeReverbSend", LargeReverbSend.ToString());
            RelXml.ValueTag(sb, indent, "JunctionTriggerSpeed", FloatUtil.ToString(JunctionTriggerSpeed));
            RelXml.ValueTag(sb, indent, "JunctionStopSpeed", FloatUtil.ToString(JunctionStopSpeed));
            RelXml.ValueTag(sb, indent, "JunctionMinDistance", JunctionMinDistance.ToString());
            RelXml.ValueTag(sb, indent, "JunctionMaxDistance", JunctionMaxDistance.ToString());
            RelXml.ValueTag(sb, indent, "PassbyTriggerSpeed", FloatUtil.ToString(PassbyTriggerSpeed));
            RelXml.ValueTag(sb, indent, "PassbyStopSpeed", FloatUtil.ToString(PassbyStopSpeed));
            RelXml.ValueTag(sb, indent, "PassbyMinDistance", PassbyMinDistance.ToString());
            RelXml.ValueTag(sb, indent, "PassbyMaxDistance", PassbyMaxDistance.ToString());
            RelXml.ValueTag(sb, indent, "PassbyLookaheadTime", FloatUtil.ToString(PassbyLookaheadTime));
            RelXml.ValueTag(sb, indent, "ClusterTriggerDistance", ClusterTriggerDistance.ToString());
            RelXml.ValueTag(sb, indent, "ClusterTriggerSpeed", FloatUtil.ToString(ClusterTriggerSpeed));
        }
        public override void ReadXml(XmlNode node)
        {
            EngineVolumeBoost = Xml.GetChildIntAttribute(node, "EngineVolumeBoost", "value");
            ExhaustVolumeBoost = Xml.GetChildIntAttribute(node, "ExhaustVolumeBoost", "value");
            RollOffBoost = Xml.GetChildFloatAttribute(node, "RollOffBoost", "value");
            MinTriggerTime = Xml.GetChildIntAttribute(node, "MinTriggerTime", "value");
            MinRepeatTime = Xml.GetChildIntAttribute(node, "MinRepeatTime", "value");
            AttackTimeScalar = Xml.GetChildFloatAttribute(node, "AttackTimeScalar", "value");
            ReleaseTimeScalar = Xml.GetChildFloatAttribute(node, "ReleaseTimeScalar", "value");
            SmallReverbSend = (byte)Xml.GetChildIntAttribute(node, "SmallReverbSend", "value");
            MediumReverbSend = (byte)Xml.GetChildIntAttribute(node, "MediumReverbSend", "value");
            LargeReverbSend = (byte)Xml.GetChildIntAttribute(node, "LargeReverbSend", "value");
            JunctionTriggerSpeed = Xml.GetChildFloatAttribute(node, "JunctionTriggerSpeed", "value");
            JunctionStopSpeed = Xml.GetChildFloatAttribute(node, "JunctionStopSpeed", "value");
            JunctionMinDistance = Xml.GetChildIntAttribute(node, "JunctionMinDistance", "value");
            JunctionMaxDistance = Xml.GetChildIntAttribute(node, "JunctionMaxDistance", "value");
            PassbyTriggerSpeed = Xml.GetChildFloatAttribute(node, "PassbyTriggerSpeed", "value");
            PassbyStopSpeed = Xml.GetChildFloatAttribute(node, "PassbyStopSpeed", "value");
            PassbyMinDistance = Xml.GetChildIntAttribute(node, "PassbyMinDistance", "value");
            PassbyMaxDistance = Xml.GetChildIntAttribute(node, "PassbyMaxDistance", "value");
            PassbyLookaheadTime = Xml.GetChildFloatAttribute(node, "PassbyLookaheadTime", "value");
            ClusterTriggerDistance = Xml.GetChildIntAttribute(node, "ClusterTriggerDistance", "value");
            ClusterTriggerSpeed = Xml.GetChildFloatAttribute(node, "ClusterTriggerSpeed", "value");
        }
    }

    [TC(typeof(EXP))]
    public class Dat151FoliageSettings : Dat151RelData
    {
        public MetaHash Run { get; set; }
        public MetaHash Sprint { get; set; }
        public MetaHash Walk { get; set; }

        public Dat151FoliageSettings(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.FoliageSettings;
            TypeID = (byte)Type;
        }
        public Dat151FoliageSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Run = br.ReadUInt32();
            Sprint = br.ReadUInt32();
            Walk = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Run);
            bw.Write(Sprint);
            bw.Write(Walk);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Run", RelXml.HashString(Run));
            RelXml.StringTag(sb, indent, "Sprint", RelXml.HashString(Sprint));
            RelXml.StringTag(sb, indent, "Walk", RelXml.HashString(Walk));
        }
        public override void ReadXml(XmlNode node)
        {
            Run = XmlRel.GetHash(Xml.GetChildInnerText(node, "Run"));
            Sprint = XmlRel.GetHash(Xml.GetChildInnerText(node, "Sprint"));
            Walk = XmlRel.GetHash(Xml.GetChildInnerText(node, "Walk"));
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { Run, Sprint, Walk };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat151ModelAudioCollisionSettingsOverrideList : Dat151RelData
    {
        public int ItemCount { get; set; }
        public Dat151ModelAudioCollisionSettingsOverrideListItem[] Items { get; set; }

        public Dat151ModelAudioCollisionSettingsOverrideList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.ModelAudioCollisionSettingsOverrideList;
            TypeID = (byte)Type;
        }
        public Dat151ModelAudioCollisionSettingsOverrideList(RelData d, BinaryReader br) : base(d, br)
        {
            ItemCount = br.ReadInt32();
            Items = new Dat151ModelAudioCollisionSettingsOverrideListItem[ItemCount];
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i] = new Dat151ModelAudioCollisionSettingsOverrideListItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(ItemCount);
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.WriteItemArray(sb, Items, indent, "Items");
        }
        public override void ReadXml(XmlNode node)
        {
            Items = XmlRel.ReadItemArray<Dat151ModelAudioCollisionSettingsOverrideListItem>(node, "Items");
            ItemCount = (Items?.Length ?? 0);
        }
        public override MetaHash[] GetGameHashes()
        {
            var list = new List<MetaHash>();
            if (Items != null)
            {
                foreach (var item in Items)
                {
                    list.Add(item.ModelAudioCollisionSettings);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public struct Dat151ModelAudioCollisionSettingsOverrideListItem : IMetaXmlItem
    {
        public MetaHash Prop { get; set; }
        public MetaHash ModelAudioCollisionSettings { get; set; }

        public Dat151ModelAudioCollisionSettingsOverrideListItem(BinaryReader br)
        {
            Prop = br.ReadUInt32();
            ModelAudioCollisionSettings = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Prop);
            bw.Write(ModelAudioCollisionSettings);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Prop", RelXml.HashString(Prop));
            RelXml.StringTag(sb, indent, "ModelAudioCollisionSettings", RelXml.HashString(ModelAudioCollisionSettings));
        }
        public void ReadXml(XmlNode node)
        {
            Prop = XmlRel.GetHash(Xml.GetChildInnerText(node, "Prop"));
            ModelAudioCollisionSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "ModelAudioCollisionSettings"));
        }
        public override string ToString()
        {
            return Prop.ToString() + ": " + ModelAudioCollisionSettings.ToString();
        }
    }

    [TC(typeof(EXP))]
    public class Dat151GameObjectHashList : Dat151RelData
    {
        public FlagsUint Flags { get; set; }
        public uint GameObjectHashesCount { get; set; }
        public MetaHash[] GameObjectHashes { get; set; }

        public Dat151GameObjectHashList(RelFile rel) : base(rel)
        {
            Type = Dat151RelType.GameObjectHashList;
            TypeID = (byte)Type;
        }
        public Dat151GameObjectHashList(RelData d, BinaryReader br) : base(d, br)
        {
            Flags = br.ReadUInt32();
            GameObjectHashesCount = br.ReadUInt32();
            GameObjectHashes = new MetaHash[GameObjectHashesCount];
            for (int i = 0; i < GameObjectHashesCount; i++)
            {
                GameObjectHashes[i] = br.ReadUInt32();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffset(bw);

            bw.Write(Flags);
            bw.Write(GameObjectHashesCount);
            for (int i = 0; i < GameObjectHashesCount; i++)
            {
                bw.Write(GameObjectHashes[i]);
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.WriteHashItemArray(sb, GameObjectHashes, indent, "GameObjectHashes");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            GameObjectHashes = XmlRel.ReadHashItemArray(node, "GameObjectHashes");
            GameObjectHashesCount = (uint)(GameObjectHashes?.Length ?? 0);
        }
        public override MetaHash[] GetGameHashes()
        {
            return GameObjectHashes;
        }
    }




    #endregion




    #region dat4 (config)


    public enum Dat4ConfigType : byte
    {
        Int = 0,
        UnsignedInt = 1,
        Float = 2,
        String = 3,
        Vector3 = 5,
        VariableList = 7,
        WaveSlot = 8,
        WaveSlotsList = 9,
        ERSettings = 10,
    }

    [TC(typeof(EXP))] 
    public class Dat4ConfigData : RelData
    {
        public Dat4ConfigType Type { get; set; }
        public uint NameTableOffset { get; set; }
        public FlagsUint Flags { get; set; } = 0xAAAAAAAA;

        public Dat4ConfigData(RelFile rel) : base(rel) { }
        public Dat4ConfigData(RelFile rel, Dat4ConfigType type) : base(rel)
        {
            Type = type;
            TypeID = (byte)type;
        }
        public Dat4ConfigData(RelData d, BinaryReader br) : base(d)
        {
            Type = (Dat4ConfigType)TypeID;

            br.BaseStream.Position = 0; //1 byte was read already (TypeID)

            NameTableOffset = ((br.ReadUInt32() >> 8) & 0xFFFFFF);
            Flags = br.ReadUInt32();

            if (Flags != 0xAAAAAAAA)
            { }
        }

        public override void Write(BinaryWriter bw)
        {
            //don't use this as a fallback case, since it won't write as raw data
            var val = ((NameTableOffset & 0xFFFFFF) << 8) + TypeID;
            bw.Write(val);
            bw.Write(Flags);
        }

        public override void WriteXml(StringBuilder sb, int indent)
        {
            //base.WriteXml(sb, indent);
            //RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
        }
        public override void ReadXml(XmlNode node)
        {
            //base.ReadXml(node);
            //Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Flags = 0xAAAAAAAA; //it's always this value so what's the point of putting it in XML?
        }

        public override string ToString()
        {
            return GetBaseString() + ": " + Type.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat4ConfigInt : Dat4ConfigData
    {
        public int Value { get; set; }

        public Dat4ConfigInt(RelFile rel) : base(rel)
        {
            Type = Dat4ConfigType.Int;
            TypeID = (byte)Type;
        }
        public Dat4ConfigInt(RelData d, BinaryReader br) : base(d, br)
        {
            Value = br.ReadInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(Value);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "Value", Value.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            Value = Xml.GetChildIntAttribute(node, "Value", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat4ConfigUnsignedInt : Dat4ConfigData
    {
        public uint Value { get; set; }

        public Dat4ConfigUnsignedInt(RelFile rel) : base(rel)
        {
            Type = Dat4ConfigType.UnsignedInt;
            TypeID = (byte)Type;
        }
        public Dat4ConfigUnsignedInt(RelData d, BinaryReader br) : base(d, br)
        {
            Value = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(Value);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "Value", Value.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            Value = Xml.GetChildUIntAttribute(node, "Value", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat4ConfigFloat : Dat4ConfigData
    {
        public float Value { get; set; }

        public Dat4ConfigFloat(RelFile rel) : base(rel)
        {
            Type = Dat4ConfigType.Float;
            TypeID = (byte)Type;
        }
        public Dat4ConfigFloat(RelData d, BinaryReader br) : base(d, br)
        {
            Value = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(Value);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "Value", FloatUtil.ToString(Value));
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            Value = Xml.GetChildFloatAttribute(node, "Value", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat4ConfigString : Dat4ConfigData
    {
        public string Value { get; set; }

        public Dat4ConfigString(RelFile rel) : base(rel)
        {
            Type = Dat4ConfigType.String;
            TypeID = (byte)Type;
        }
        public Dat4ConfigString(RelData d, BinaryReader br) : base(d, br)
        {
            var data = br.ReadBytes(64);
            Value = Encoding.ASCII.GetString(data).Replace("\0", "");
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);

            byte[] data = new byte[64];
            int len = Math.Min(Value?.Length ?? 0, 64);
            if (len > 0)
            {
                Encoding.ASCII.GetBytes(Value, 0, len, data, 0);
            }
            bw.Write(data);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.StringTag(sb, indent, "Value", Value);
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            Value = Xml.GetChildInnerText(node, "Value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat4ConfigVector3 : Dat4ConfigData
    {
        public Vector3 Value { get; set; }

        public Dat4ConfigVector3(RelFile rel) : base(rel)
        {
            Type = Dat4ConfigType.Vector3;
            TypeID = (byte)Type;
        }
        public Dat4ConfigVector3(RelData d, BinaryReader br) : base(d, br)
        {
            br.ReadBytes(8); // alignment padding
            Value = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());//0x10-0x1C
            br.ReadBytes(4); // alignment padding
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(new byte[8]);
            bw.Write(Value.X);
            bw.Write(Value.Y);
            bw.Write(Value.Z);
            bw.Write(new byte[4]);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.SelfClosingTag(sb, indent, "Value " + FloatUtil.GetVector3XmlString(Value));
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            Value = Xml.GetChildVector3Attributes(node, "Value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat4ConfigVariableList : Dat4ConfigData
    {
        public int VariableCount { get; set; }
        public VariableValue[] Variables { get; set; }
        public class VariableValue : IMetaXmlItem
        {
            public MetaHash Name { get; set; }
            public float Value { get; set; }

            public VariableValue() { }
            public VariableValue(BinaryReader br)
            {
                Name = br.ReadUInt32();
                Value = br.ReadSingle();
            }
            public void Write(BinaryWriter bw)
            {
                bw.Write(Name);
                bw.Write(Value);
            }
            public void WriteXml(StringBuilder sb, int indent)
            {
                RelXml.StringTag(sb, indent, "Name", RelXml.HashString(Name));
                RelXml.ValueTag(sb, indent, "Value", FloatUtil.ToString(Value));
            }
            public void ReadXml(XmlNode node)
            {
                Name = XmlRel.GetHash(Xml.GetChildInnerText(node, "Name"));
                Value = Xml.GetChildFloatAttribute(node, "Value", "value");
            }
            public override string ToString()
            {
                return Name + ": " + Value.ToString();
            }
        }

        public Dat4ConfigVariableList(RelFile rel) : base(rel)
        {
            Type = Dat4ConfigType.VariableList;
            TypeID = (byte)Type;
        }
        public Dat4ConfigVariableList(RelData d, BinaryReader br) : base(d, br)
        {
            VariableCount = br.ReadInt32();
            Variables = new VariableValue[VariableCount];
            for (int i = 0; i < VariableCount; i++)
            {
                Variables[i] = new VariableValue(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(VariableCount);
            for (int i = 0; i < VariableCount; i++)
            {
                Variables[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.WriteItemArray(sb, Variables, indent, "Variables");
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            Variables = XmlRel.ReadItemArray<VariableValue>(node, "Variables");
            VariableCount = (Variables?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))]
    public class Dat4ConfigWaveSlot : Dat4ConfigData
    {
        public int LoadType { get; set; }
        public uint MaxHeaderSize { get; set; }
        public uint Size { get; set; }
        public MetaHash StaticBank { get; set; }
        public uint MaxMetadataSize { get; set; }
        public uint MaxDataSize { get; set; }

        public Dat4ConfigWaveSlot(RelFile rel) : base(rel)
        {
            Type = Dat4ConfigType.WaveSlot;
            TypeID = (byte)Type;
        }
        public Dat4ConfigWaveSlot(RelData d, BinaryReader br) : base(d, br)
        {
            LoadType = br.ReadInt32();
            MaxHeaderSize = br.ReadUInt32();
            Size = br.ReadUInt32();
            StaticBank = br.ReadUInt32();
            MaxMetadataSize = br.ReadUInt32();
            MaxDataSize = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);

            bw.Write(LoadType);
            bw.Write(MaxHeaderSize);
            bw.Write(Size);
            bw.Write(StaticBank);
            bw.Write(MaxMetadataSize);
            bw.Write(MaxDataSize);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "LoadType", LoadType.ToString());
            RelXml.ValueTag(sb, indent, "MaxHeaderSize", MaxHeaderSize.ToString());
            RelXml.ValueTag(sb, indent, "Size", Size.ToString());
            RelXml.StringTag(sb, indent, "StaticBank", RelXml.HashString(StaticBank));
            RelXml.ValueTag(sb, indent, "MaxMetadataSize", MaxMetadataSize.ToString());
            RelXml.ValueTag(sb, indent, "MaxDataSize", MaxDataSize.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            LoadType = Xml.GetChildIntAttribute(node, "LoadType", "value");
            MaxHeaderSize = Xml.GetChildUIntAttribute(node, "MaxHeaderSize", "value");
            Size = Xml.GetChildUIntAttribute(node, "Size", "value");
            StaticBank = XmlRel.GetHash(Xml.GetChildInnerText(node, "StaticBank"));
            MaxMetadataSize = Xml.GetChildUIntAttribute(node, "MaxMetadataSize", "value");
            MaxDataSize = Xml.GetChildUIntAttribute(node, "MaxDataSize", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat4ConfigWaveSlotsList : Dat4ConfigData
    {
        public int WaveSlotsCount { get; set; }
        public MetaHash[] WaveSlots { get; set; }

        public Dat4ConfigWaveSlotsList(RelFile rel) : base(rel)
        {
            Type = Dat4ConfigType.WaveSlotsList;
            TypeID = (byte)Type;
        }
        public Dat4ConfigWaveSlotsList(RelData d, BinaryReader br) : base(d, br)
        {
            WaveSlotsCount = br.ReadInt32();
            WaveSlots = new MetaHash[WaveSlotsCount];
            for (int i = 0; i < WaveSlotsCount; i++)
            {
                WaveSlots[i] = br.ReadUInt32();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(WaveSlotsCount);
            for (int i = 0; i < WaveSlotsCount; i++)
            {
                bw.Write(WaveSlots[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.WriteHashItemArray(sb, WaveSlots, indent, "WaveSlots");
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            WaveSlots = XmlRel.ReadHashItemArray(node, "WaveSlots");
            WaveSlotsCount = (WaveSlots?.Length ?? 0);
        }
        public override uint[] GetHashTableOffsets()
        {
            var offsets = new List<uint>();
            for (uint i = 0; i < WaveSlotsCount; i++)
            {
                offsets.Add(8 + i * 4);
            }
            return offsets.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat4ConfigERSettings : Dat4ConfigData
    {
        // hashes appear in companion
        float RoomSize { get; set; }
        Vector3 RoomDimensions { get; set; }
        Vector3 ListenerPos { get; set; }
        int AllPassesCount { get; set; }
        Pass[] AllPasses { get; set; }
        Vector4[] NodeGainMatrix { get; set; } // fixed length 6
        Vector4 Gain_1stOrder { get; set; }
        Vector4 Gain_2ndOrder { get; set; }
        Vector4 Gain_3rdOrder { get; set; }
        int NodeLPF_1stOrdersCount { get; set; }
        Vector4[] NodeLPF_1stOrder { get; set; }
        int NodeLPF_2ndOrdersCount { get; set; }
        Vector4[] NodeLPF_2ndOrder { get; set; }
        int NodeLPF_3rdOrders { get; set; }
        Vector4[] NodeLPF_3rdOrder { get; set; }


        public class Pass : IMetaXmlItem
        {
            public float UnkFloat { get; set; }
            public int UnkInt { get; set; }

            public Pass() { }
            public Pass(BinaryReader br)
            {
                UnkFloat = br.ReadSingle();
                UnkInt = br.ReadInt32();
            }
            public void Write(BinaryWriter bw)
            {
                bw.Write(UnkFloat);
                bw.Write(UnkInt);
            }
            public void WriteXml(StringBuilder sb, int indent)
            {
                RelXml.ValueTag(sb, indent, "UnkFloat", FloatUtil.ToString(UnkFloat));
                RelXml.ValueTag(sb, indent, "UnkInt", UnkInt.ToString());
            }
            public void ReadXml(XmlNode node)
            {
                UnkFloat = Xml.GetChildFloatAttribute(node, "UnkFloat", "value");
                UnkInt = Xml.GetChildIntAttribute(node, "UnkInt", "value");
            }
            public override string ToString()
            {
                return FloatUtil.ToString(UnkFloat) + ", " + UnkInt.ToString();
            }
        }


        public Dat4ConfigERSettings(RelFile rel) : base(rel)
        {
            Type = Dat4ConfigType.ERSettings;
            TypeID = (byte)Type;
        }
        public Dat4ConfigERSettings(RelData d, BinaryReader br) : base(d, br)
        {
            RoomSize = br.ReadSingle();
            RoomDimensions = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            ListenerPos = new Vector3(br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            AllPassesCount = br.ReadInt32();
            AllPasses = new Pass[AllPassesCount];
            for (int i = 0; i < AllPassesCount; i++)
            {
                AllPasses[i] = new Pass(br);
            }
            NodeGainMatrix = new Vector4[6];
            for (int i = 0; i < NodeGainMatrix.Length; i++)
            {
                NodeGainMatrix[i] = new Vector4(br.ReadSingle(), br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            }
            Gain_1stOrder = new Vector4(br.ReadSingle(), br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            Gain_2ndOrder = new Vector4(br.ReadSingle(), br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            Gain_3rdOrder = new Vector4(br.ReadSingle(), br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            NodeLPF_1stOrdersCount = br.ReadInt32();
            NodeLPF_1stOrder = new Vector4[NodeLPF_1stOrdersCount];
            for (int i = 0; i < NodeLPF_1stOrdersCount; i++)
            {
                NodeLPF_1stOrder[i] = new Vector4(br.ReadSingle(), br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            }
            NodeLPF_2ndOrdersCount = br.ReadInt32();
            NodeLPF_2ndOrder = new Vector4[NodeLPF_1stOrdersCount];
            for (int i = 0; i < NodeLPF_2ndOrdersCount; i++)
            {
                NodeLPF_2ndOrder[i] = new Vector4(br.ReadSingle(), br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            }
            NodeLPF_3rdOrders = br.ReadInt32();
            NodeLPF_3rdOrder = new Vector4[NodeLPF_1stOrdersCount];
            for (int i = 0; i < NodeLPF_3rdOrders; i++)
            {
                NodeLPF_3rdOrder[i] = new Vector4(br.ReadSingle(), br.ReadSingle(), br.ReadSingle(), br.ReadSingle());
            }
        }
        public override void Write(BinaryWriter bw)
        {
            base.Write(bw);
            bw.Write(RoomSize);
            bw.Write(RoomDimensions.X);
            bw.Write(RoomDimensions.Y);
            bw.Write(RoomDimensions.Z);
            bw.Write(ListenerPos.X);
            bw.Write(ListenerPos.Y);
            bw.Write(ListenerPos.Z);
            bw.Write(AllPassesCount);
            for (int i = 0; i < AllPassesCount; i++)
            {
                AllPasses[i].Write(bw);
            }
            for (int i = 0; i < NodeGainMatrix.Length; i++)
            {
                bw.Write(NodeGainMatrix[i].X);
                bw.Write(NodeGainMatrix[i].Y);
                bw.Write(NodeGainMatrix[i].Z);
                bw.Write(NodeGainMatrix[i].W);
            }
            bw.Write(Gain_1stOrder.X);
            bw.Write(Gain_1stOrder.Y);
            bw.Write(Gain_1stOrder.Z);
            bw.Write(Gain_1stOrder.W);
            bw.Write(Gain_2ndOrder.X);
            bw.Write(Gain_2ndOrder.Y);
            bw.Write(Gain_2ndOrder.Z);
            bw.Write(Gain_2ndOrder.W);
            bw.Write(Gain_3rdOrder.X);
            bw.Write(Gain_3rdOrder.Y);
            bw.Write(Gain_3rdOrder.Z);
            bw.Write(Gain_3rdOrder.W);
            bw.Write(NodeLPF_1stOrdersCount);
            for (int i = 0; i < NodeLPF_1stOrdersCount; i++)
            {
                bw.Write(NodeLPF_1stOrder[i].X);
                bw.Write(NodeLPF_1stOrder[i].Y);
                bw.Write(NodeLPF_1stOrder[i].Z);
                bw.Write(NodeLPF_1stOrder[i].W);
            }
            bw.Write(NodeLPF_2ndOrdersCount);
            for (int i = 0; i < NodeLPF_2ndOrdersCount; i++)
            {
                bw.Write(NodeLPF_2ndOrder[i].X);
                bw.Write(NodeLPF_2ndOrder[i].Y);
                bw.Write(NodeLPF_2ndOrder[i].Z);
                bw.Write(NodeLPF_2ndOrder[i].W);
            }
            bw.Write(NodeLPF_3rdOrders);
            for (int i = 0; i < NodeLPF_3rdOrders; i++)
            {
                bw.Write(NodeLPF_3rdOrder[i].X);
                bw.Write(NodeLPF_3rdOrder[i].Y);
                bw.Write(NodeLPF_3rdOrder[i].Z);
                bw.Write(NodeLPF_3rdOrder[i].W);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            base.WriteXml(sb, indent);
            RelXml.ValueTag(sb, indent, "RoomSize", FloatUtil.ToString(RoomSize));
            RelXml.SelfClosingTag(sb, indent, "RoomDimensions " + FloatUtil.GetVector3XmlString(RoomDimensions));
            RelXml.SelfClosingTag(sb, indent, "ListenerPos " + FloatUtil.GetVector3XmlString(ListenerPos));
            RelXml.WriteItemArray(sb, AllPasses, indent, "AllPasses");
            RelXml.WriteRawArray(sb, NodeGainMatrix, indent, "NodeGainMatrix", "", RelXml.FormatVector4, 1);
            RelXml.SelfClosingTag(sb, indent, "Gain_1stOrder " + FloatUtil.GetVector4XmlString(Gain_1stOrder));
            RelXml.SelfClosingTag(sb, indent, "Gain_2ndOrder " + FloatUtil.GetVector4XmlString(Gain_2ndOrder));
            RelXml.SelfClosingTag(sb, indent, "Gain_3rdOrder " + FloatUtil.GetVector4XmlString(Gain_3rdOrder));
            RelXml.WriteRawArray(sb, NodeLPF_1stOrder, indent, "NodeLPF_1stOrder", "", RelXml.FormatVector4, 1);
            RelXml.WriteRawArray(sb, NodeLPF_2ndOrder, indent, "NodeLPF_2ndOrder", "", RelXml.FormatVector4, 1);
            RelXml.WriteRawArray(sb, NodeLPF_3rdOrder, indent, "NodeLPF_3rdOrder", "", RelXml.FormatVector4, 1);
        }
        public override void ReadXml(XmlNode node)
        {
            base.ReadXml(node);
            RoomSize = Xml.GetChildFloatAttribute(node, "RoomSize", "value");
            RoomDimensions = Xml.GetChildVector3Attributes(node, "RoomDimensions");
            ListenerPos = Xml.GetChildVector3Attributes(node, "ListenerPos");
            AllPasses = XmlRel.ReadItemArray<Pass>(node, "AllPasses");
            AllPassesCount = (AllPasses?.Length ?? 0);
            NodeGainMatrix = Xml.GetChildRawVector4Array(node, "NodeGainMatrix");
            Gain_1stOrder = Xml.GetChildVector4Attributes(node, "Gain_1stOrder");
            Gain_2ndOrder = Xml.GetChildVector4Attributes(node, "Gain_2ndOrder");
            Gain_3rdOrder = Xml.GetChildVector4Attributes(node, "Gain_3rdOrder");
            NodeLPF_1stOrder = Xml.GetChildRawVector4Array(node, "NodeLPF_1stOrder");
            NodeLPF_2ndOrder = Xml.GetChildRawVector4Array(node, "NodeLPF_2ndOrder");
            NodeLPF_3rdOrder = Xml.GetChildRawVector4Array(node, "NodeLPF_3rdOrder");
            NodeLPF_1stOrdersCount = NodeLPF_1stOrder?.Length ?? 0;
            NodeLPF_2ndOrdersCount = NodeLPF_2ndOrder?.Length ?? 0;
            NodeLPF_3rdOrders = NodeLPF_3rdOrder?.Length ?? 0;
        }
    }




    #endregion
    
    
    
    
    #region dat4 (speech)

    public enum Dat4SpeechType : byte
    {
        ByteArray = 0,
        Hash = 4,
        Container = 8,
    }

    [TC(typeof(EXP))] 
    public class Dat4SpeechData : RelData
    {
        public Dat4SpeechType Type { get; set; }

        public uint NameTableOffset { get; set; }
        public MetaHash ContainerHash { get; set; }
        public MetaHash Hash { get; set; }


        public Dat4SpeechData(RelFile rel) : base(rel)
        { }
        public Dat4SpeechData(RelData d, BinaryReader br) : base(d)
        {
            br.BaseStream.Position = 0; //1 byte was read already (TypeID)


            if ((TypeID == 4) && (br.BaseStream.Length == 8))
            {
                NameTableOffset = ((br.ReadUInt32() >> 8) & 0xFFFFFF);
                ContainerHash = br.ReadUInt32();
            }
        }

        public override void Write(BinaryWriter bw)
        {
            switch (Type)
            {
                case Dat4SpeechType.Hash:
                    bw.Write(Hash);
                    break;
                case Dat4SpeechType.Container:
                    bw.Write(((NameTableOffset & 0xFFFFFF) << 8) + 4 /*TypeID*/);
                    bw.Write(ContainerHash);
                    break;
                default:
                    bw.Write(Data);
                    break;
            }
        }

        public override void WriteXml(StringBuilder sb, int indent)
        {
            switch (Type)
            {
                case Dat4SpeechType.Hash:
                    RelXml.StringTag(sb, indent, "Hash", RelXml.HashString(Hash));
                    break;
                case Dat4SpeechType.Container:
                    RelXml.StringTag(sb, indent, "ContainerHash", RelXml.HashString(ContainerHash));
                    break;
                default:
                    RelXml.WriteRawArray(sb, Data, indent, "RawData", "", RelXml.FormatHexByte, 16);
                    break;
            }
        }
        public override void ReadXml(XmlNode node)
        {
            switch (Type)
            {
                case Dat4SpeechType.Hash:
                    Hash = XmlRel.GetHash(Xml.GetChildInnerText(node, "Hash"));
                    break;
                case Dat4SpeechType.Container:
                    ContainerHash = XmlRel.GetHash(Xml.GetChildInnerText(node, "ContainerHash"));
                    break;
                default:
                    var rawnode = node.SelectSingleNode("RawData");
                    if (rawnode != null)
                    {
                        Data = Xml.GetRawByteArray(rawnode);
                        DataLength = (uint)Data.Length;
                    }
                    break;
            }
        }

        public override uint[] GetHashTableOffsets()
        {
            switch (Type)
            {
                case Dat4SpeechType.Hash:
                    return new uint[] { 0 };
            }
            return null;
        }
        public override uint[] GetPackTableOffsets()
        {
            switch (Type)
            {
                case Dat4SpeechType.Container:
                    return new uint[] { 4 };
            }
            return null;
        }

        public override string ToString()
        {
            switch (Type)
            {
                case Dat4SpeechType.Hash:
                    return GetBaseString() + ": " + Type.ToString() + ": " + Hash.ToString();
                case Dat4SpeechType.Container:
                    return GetBaseString() + ": " + Type.ToString() + ": " + ContainerHash.ToString();
            }
            return GetBaseString();
        }

    }


    #endregion




    #region dat10


    public enum Dat10RelType : byte
    {
        SynthPreset = 1,
        Synth = 3,
    }

    [TC(typeof(EXP))] 
    public class Dat10RelData : RelData
    {
        public Dat10RelType Type { get; set; }
        public uint NameTableOffset { get; set; }
        public FlagsUint Flags { get; set; }

        public Dat10RelData(RelFile rel) : base(rel) { }
        public Dat10RelData(RelFile rel, Dat10RelType type) : base(rel)
        {
            Type = type;
            TypeID = (byte)type;
        }
        public Dat10RelData(RelData d, BinaryReader br) : base(d)
        {
            Type = (Dat10RelType)TypeID;

            br.BaseStream.Position = 0; //1 byte was read already (TypeID)

            NameTableOffset = ((br.ReadUInt32() >> 8) & 0xFFFFFF);
            Flags = br.ReadUInt32();
        }

        public void WriteTypeAndOffsetAndFlags(BinaryWriter bw)
        {
            var val = ((NameTableOffset & 0xFFFFFF) << 8) + TypeID;
            bw.Write(val);
            bw.Write(Flags);
        }

        public override string ToString()
        {
            return GetBaseString() + ": " + Type.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat10SynthPresetVariable : IMetaXmlItem
    {
        public MetaHash Name { get; set; }
        public float Value1 { get; set; }
        public float Value2 { get; set; }

        public Dat10SynthPresetVariable()
        { }
        public Dat10SynthPresetVariable(BinaryReader br)
        {
            Name = br.ReadUInt32();
            Value1 = br.ReadSingle();
            Value2 = br.ReadSingle();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Name);
            bw.Write(Value1);
            bw.Write(Value2);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Name", RelXml.HashString(Name));
            RelXml.ValueTag(sb, indent, "Value1", FloatUtil.ToString(Value1));
            RelXml.ValueTag(sb, indent, "Value2", FloatUtil.ToString(Value2));
        }
        public void ReadXml(XmlNode node)
        {
            Name = XmlRel.GetHash(Xml.GetChildInnerText(node, "Name"));
            Value1 = Xml.GetChildFloatAttribute(node, "Value1", "value");
            Value2 = Xml.GetChildFloatAttribute(node, "Value2", "value");
        }
        public override string ToString()
        {
            return Name.ToString() + ": " + Value1.ToString() + ", " + Value2.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat10SynthPreset : Dat10RelData
    {
        public byte VariableCount { get; set; }
        public Dat10SynthPresetVariable[] Variables { get; set; }

        public Dat10SynthPreset(RelFile rel) : base(rel)
        {
            Type = Dat10RelType.SynthPreset;
            TypeID = (byte)Type;
        }
        public Dat10SynthPreset(RelData d, BinaryReader br) : base(d, br)
        {
            VariableCount = br.ReadByte();
            Variables = new Dat10SynthPresetVariable[VariableCount];
            for (int i = 0; i < VariableCount; i++)
            {
                Variables[i] = new Dat10SynthPresetVariable(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(VariableCount);
            for (int i = 0; i < VariableCount; i++)
            {
                Variables[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.WriteItemArray(sb, Variables, indent, "Variables");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Variables = XmlRel.ReadItemArray<Dat10SynthPresetVariable>(node, "Variables");
            VariableCount = (byte)(Variables?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))] 
    public class Dat10SynthVariable : IMetaXmlItem
    {
        public MetaHash Name { get; set; }
        public float Value { get; set; }

        public Dat10SynthVariable()
        { }
        public Dat10SynthVariable(BinaryReader br)
        {
            Name = br.ReadUInt32();
            Value = br.ReadSingle();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Name);
            bw.Write(Value);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Name", RelXml.HashString(Name));
            RelXml.ValueTag(sb, indent, "Value", FloatUtil.ToString(Value));
        }
        public void ReadXml(XmlNode node)
        {
            Name = XmlRel.GetHash(Xml.GetChildInnerText(node, "Name"));
            Value = Xml.GetChildFloatAttribute(node, "Value", "value");
        }
        public override string ToString()
        {
            return Name.ToString() + ": " + Value.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat10Synth : Dat10RelData
    {
        // limits hardcoded in the .exe
        public const int MaxStateBlocks = 64;
        public const int MaxRegisters = 48;
        public const int MaxBuffers = 16;
        public const int MaxOutputs = 4;

        public int BuffersCount { get; set; }//buffers count           (4)  (for synth_ambient_aircon_full)
        public int RegistersCount { get; set; }//registers count       (21)
        public int OutputsCount { get; set; }//outputs count           (1)
        public byte[] OutputsIndices { get; set; }//outputs indices: determines the buffers used as outputs   (1, 0, 0, 0)
        public int BytecodeLength { get; set; }//bytecode length       (504)
        public int StateBlocksCount { get; set; }//state blocks count  (18)
        public int RuntimeCost { get; set; }//runtime cost             (50)
        public byte[] Bytecode { get; set; }
        public int ConstantsCount { get; set; }//constants count       (21)
        public float[] Constants { get; set; }//constants (floats)
        public int VariablesCount { get; set; }//variables count       (8)
        public Dat10SynthVariable[] Variables { get; set; }//variables

        public Dat10Synth(RelFile rel) : base(rel)
        {
            Type = Dat10RelType.Synth;
            TypeID = (byte)Type;
        }
        public Dat10Synth(RelData d, BinaryReader br) : base(d, br)
        {
            BuffersCount = br.ReadInt32();//buffers count           (4)  (for synth_ambient_aircon_full)
            RegistersCount = br.ReadInt32();//registers count       (21)
            OutputsCount = br.ReadInt32();//outputs count           (1)
            OutputsIndices = br.ReadBytes(MaxOutputs);//outputs indices      (1, 0, 0, 0)
            BytecodeLength = br.ReadInt32();//bytecode length       (504)
            StateBlocksCount = br.ReadInt32();//state blocks count  (18)
            RuntimeCost = br.ReadInt32();//runtime cost             (50)
            Bytecode = br.ReadBytes(BytecodeLength);
            ConstantsCount = br.ReadInt32(); //constants count      (21)              
            Constants = new float[ConstantsCount];//constants (floats)
            for (int i = 0; i < ConstantsCount; i++)
            {
                Constants[i] = br.ReadSingle();
            }
            VariablesCount = br.ReadInt32(); //variables count      (8)
            Variables = new Dat10SynthVariable[VariablesCount];//variables
            for (int i = 0; i < VariablesCount; i++)
            {
                Variables[i] = new Dat10SynthVariable(br);
            }

            if (d.NameHash == 2095626595)//synth_ambient_aircon_full
            { }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(BuffersCount);
            bw.Write(RegistersCount);
            bw.Write(OutputsCount);
            bw.Write(OutputsIndices);
            bw.Write(BytecodeLength);
            bw.Write(StateBlocksCount);
            bw.Write(RuntimeCost);
            bw.Write(Bytecode);
            bw.Write(ConstantsCount);
            for (int i = 0; i < ConstantsCount; i++)
            {
                bw.Write(Constants[i]);
            }
            bw.Write(VariablesCount);
            for (int i = 0; i < VariablesCount; i++)
            {
                Variables[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.WriteItemArray(sb, Variables, indent, "Variables");

            var disasm = Disassemble(Bytecode, Constants, Variables, false);
            var reasm = Assemble(disasm.Disassembly, Variables);//TODO: adjust disassembly code to make this not necessary
            RelXml.OpenTag(sb, indent, "Assembly");
            var reader = new StringReader(disasm.Disassembly);
            string line;
            while ((line = reader.ReadLine()) != null)
            {
                RelXml.Indent(sb, indent + 1);
                sb.AppendLine(line);
            }
            RelXml.CloseTag(sb, indent, "Assembly");

            var outputs = new List<byte>();
            for (int i = 0; i < OutputsCount; i++)
            {
                if (i >= OutputsIndices.Length) break;
                outputs.Add(OutputsIndices[i]);
            }
            RelXml.WriteRawArray(sb, outputs.ToArray(), indent, "OutputBuffers", "", arrRowSize: 4);

            var extraConstants = new List<float>();
            for (int i = reasm.Constants.Count; i < ConstantsCount; i++)
            {
                extraConstants.Add(Constants[i]);
            }
            if (extraConstants.Count > 0)
            {
                RelXml.WriteRawArray(sb, extraConstants.ToArray(), indent, "ExtraConstants", "", FloatUtil.ToString, 1);
            }

            var extraRegisters = RegistersCount - reasm.RegistersCount;
            if (extraRegisters > 0)
            {
                RelXml.ValueTag(sb, indent, "ExtraRegisters", extraRegisters.ToString());
            }

            RelXml.ValueTag(sb, indent, "RuntimeCost", RuntimeCost.ToString());//TODO: calculate this during reassembly

        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Variables = XmlRel.ReadItemArray<Dat10SynthVariable>(node, "Variables");
            VariablesCount = (Variables?.Length ?? 0);

            var assembly = Xml.GetChildInnerText(node, "Assembly");
            var assembled = Assemble(assembly, Variables);
            Bytecode = assembled.Bytecode;
            BytecodeLength = (Bytecode?.Length ?? 0);
            BuffersCount = assembled.BuffersCount;
            StateBlocksCount = assembled.StateBlocksCount;

            var outputs = Xml.GetChildRawByteArray(node, "OutputBuffers", fromBase: 10).ToList();
            OutputsCount = outputs.Count;
            for (int i = OutputsCount; i < 4; i++)
            {
                outputs.Add(0);
            }
            OutputsIndices = outputs.ToArray();


            var extraConstants = Xml.GetChildRawFloatArray(node, "ExtraConstants");
            foreach (var extraConstant in extraConstants)
            {
                assembled.Constants.Add(extraConstant);
            }
            Constants = assembled.Constants.ToArray();
            ConstantsCount = (Constants?.Length ?? 0);

            var extraRegisters = Xml.GetChildIntAttribute(node, "ExtraRegisters", "value");
            RegistersCount = assembled.RegistersCount + extraRegisters;

            RuntimeCost = Xml.GetChildIntAttribute(node, "RuntimeCost", "value");

        }


        public void TestDisassembly()
        {
            var errors = new List<string>();
            var disasm = Disassemble(this.Bytecode, this.Constants, this.Variables, true);
            var reasm = Assemble(disasm.Disassembly, this.Variables, (s,i) => errors.Add(s));
            var disasm2 = Disassemble(reasm.Bytecode, reasm.Constants.ToArray(), this.Variables, true);

            if (errors.Count > 0)
            { }//no hit
            if (disasm.Disassembly != disasm2.Disassembly)
            { } //no hit!
            if (reasm.Bytecode.Length != Bytecode.Length)
            { }//no hit
            else
            {
                for (int i = 0; i < reasm.Bytecode.Length; i++)
                {
                    if (reasm.Bytecode[i] != Bytecode[i])
                    { break; }//no hit!
                }
            }
            if (reasm.BuffersCount != this.BuffersCount)
            { }//no hit
            if (reasm.StateBlocksCount != this.StateBlocksCount)
            { }//no hit
            if (reasm.Constants.Count <= Constants.Length)
            {
                for (int i = 0; i < reasm.Constants.Count; i++)
                {
                    if (reasm.Constants[i] != Constants[i])
                    { break; }//no hit
                }
            }
            if (reasm.Constants.Count != Constants.Length)
            {
                if (reasm.Constants.Count != Constants.Length - 1)
                { }//no hit
                else
                {
                    var lastc = Constants[Constants.Length - 1];
                    switch (lastc) //what is this?
                    {
                        case 0.0015f:
                        case 0.3595f:
                        case 0.323215f:
                        case 0.4435f:
                        case 0.5095f:
                        case 12000f:
                        case 3.590499f:
                        case 0.829645f:
                        case 0.5745f:
                        case -1f:
                        case 0.01f:
                        case 0.561f:
                        case 1.0754323f:
                        case 0.1845f:
                        case 0.508f:
                        case 0.006f:
                            break;
                        default:
                            break;//no hit
                    }
                }
            }
            if (reasm.VariablesCount != this.VariablesCount)
            { }//lots of hits.......
            if (reasm.RegistersCount != this.RegistersCount)
            {//quite a few hits
                var extregs = this.RegistersCount - reasm.RegistersCount;
                switch (extregs)
                {
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    default:
                        break;//no hits
                }
            }

        }


        public class DisassembleResult
        {
            public string Disassembly { get; set; }
            public List<Instruction> Instructions { get; set; } = new List<Instruction>();
        }

        public static DisassembleResult Disassemble(byte[] bytecode, float[] constants, Dat10SynthVariable[] variables, bool includeBytecode)
        {
            // TODO(alexguirre): THE NEW bytecodeReader DOESN'T LOOK QUITE RIGHT YET
            var bytecodeReader = new BinaryReader(new MemoryStream(bytecode));
            var sb = new StringBuilder();
            var dr = new DisassembleResult();
            for (int i = 0; i < bytecode.Length;)
            {
                var opcode = bytecode[i + 1];

                if (Enum.IsDefined(typeof(Opcode), (Opcode)opcode))
                {
                    var inst = Decode(bytecodeReader);
                    var size = inst.Size;

                    sb.Append(inst.ToString(constants, variables));
                    if (includeBytecode)
                    {
                        sb.Append("    ; ");
                        for (int k = 0; k < size; k++)
                        {
                            sb.Append(bytecode[i + k].ToString("X2"));
                            sb.Append(' ');
                        }
                    }
                    sb.AppendLine();
                    i += size;

                    dr.Instructions.Add(inst);
                }
                else
                {
                    sb.AppendLine($"Unknown opcode {opcode:X2}");
                    sb.Append("\t\t");
                    for (int k = 0; k < 16 && (i + k) < bytecode.Length; k++)
                    {
                        sb.Append(bytecode[i + k].ToString("X2"));
                        sb.Append(' ');
                    }
                    break;
                }

                if ((Opcode)opcode == Opcode.FINISH)
                {
                    break;
                }
            }

            dr.Disassembly = sb.ToString();

            return dr;
        }

        public static Instruction[] DisassembleGetInstructions(byte[] bytecode, float[] constants, Dat10SynthVariable[] variables)
        {
            // TODO(alexguirre): THE NEW bytecodeReader DOESN'T LOOK QUITE RIGHT YET
            var bytecodeReader = new BinaryReader(new MemoryStream(bytecode));
            var instructions = new List<Instruction>(128);
            for (int i = 0; i < bytecode.Length;)
            {
                var opcode = bytecode[i + 1];

                if (Enum.IsDefined(typeof(Opcode), (Opcode)opcode))
                {
                    var inst = Decode(bytecodeReader);
                    instructions.Add(inst);
                    i += inst.Size;
                }
                else
                {
                    throw new Exception($"Unknown opcode {opcode:X2}");
                }

                if ((Opcode)opcode == Opcode.FINISH)
                {
                    break;
                }
            }

            return instructions.ToArray();
        }

        public static int SizeOf(Opcode opcode, int inputs, int outputs)
        {
            switch (opcode)
            {
                case Opcode.COPY_BUFFER: return 4 + (2 * outputs);
                case Opcode.COPY_REGISTER: return 4 + (2 * outputs);
                case Opcode.CONVERT_BUFFER_TO_DENORMALIZED: return 4;
                case Opcode.CONVERT_SCALAR_TO_DENORMALIZED: return 6;
                case Opcode.CONVERT_BUFFER_TO_NORMALIZED: return 4;
                case Opcode.CONVERT_SCALAR_TO_NORMALIZED: return 6;
                case Opcode.FIRST_OF_BUFFER: return 6;
                case Opcode.MULTIPLY_BUFFER_BUFFER: return 6;
                case Opcode.MULTIPLY_BUFFER_SCALAR: return 6;
                case Opcode.MULTIPLY_SCALAR_SCALAR: return 8;
                case Opcode.SUM_BUFFER_BUFFER: return 6;
                case Opcode.SUM_BUFFER_SCALAR: return 6;
                case Opcode.SUM_SCALAR_SCALAR: return 8;
                case Opcode.SUBTRACT_BUFFER_BUFFER: return 6;
                case Opcode.SUBTRACT_BUFFER_SCALAR: return 6;
                case Opcode.SUBTRACT_SCALAR_BUFFER: return 8;
                case Opcode.SUBTRACT_SCALAR_SCALAR: return 8;
                case Opcode.DIVIDE_BUFFER_BUFFER: return 6;
                case Opcode.DIVIDE_BUFFER_SCALAR: return 6;
                case Opcode.DIVIDE_SCALAR_SCALAR: return 8;
                case Opcode.RESCALE_BUFFER_BUFFER: return 12;
                case Opcode.RESCALE_BUFFER_SCALAR: return 12;
                case Opcode.RESCALE_SCALAR_SCALAR: return 14;
                case Opcode.HARD_KNEE_BUFFER: return 6;
                case Opcode.HARD_KNEE_SCALAR_SCALAR: return 8;
                case Opcode.NOISE: return 4;
                case Opcode.RANDOM: return 12;
                case Opcode.ABS_BUFFER: return 4;
                case Opcode.ABS_SCALAR: return 6;
                case Opcode.FLOOR_BUFFER: return 4;
                case Opcode.FLOOR_SCALAR: return 6;
                case Opcode.CEIL_BUFFER: return 4;
                case Opcode.CEIL_SCALAR: return 6;
                case Opcode.ROUND_BUFFER: return 4;
                case Opcode.ROUND_SCALAR: return 6;
                case Opcode.SIGN_BUFFER: return 4;
                case Opcode.SIGN_SCALAR: return 6;
                case Opcode.MODULO_BUFFER: return 6;
                case Opcode.MODULO_SCALAR: return 8;
                case Opcode.POW_SCALAR: return 8;
                case Opcode.POW_BUFFER: return 6;
                case Opcode.MAX_SCALAR: return 10;
                case Opcode.MAX_BUFFER: return 8;
                case Opcode.COMPRESS_BUFFER: return 14;
                case Opcode._UNUSED_2C: return 2; // shouldn't get here
                case Opcode.LERP_BUFFER: return 8;
                case Opcode.LERP_BUFFER_2: return 10;
                case Opcode.LERP_SCALAR: return 10;
                case Opcode.HARD_CLIP_BUFFER_BUFFER: return 6;
                case Opcode.HARD_CLIP_BUFFER_SCALAR: return 6;
                case Opcode.HARD_CLIP_SCALAR_SCALAR: return 8;
                case Opcode.SOFT_CLIP_BUFFER_BUFFER: return 6;
                case Opcode.SOFT_CLIP_BUFFER_SCALAR: return 6;
                case Opcode.SOFT_CLIP_SCALAR_SCALAR: return 8;
                case Opcode.ENVELOPE_FOLLOWER_BUFFER: return 10;
                case Opcode.ENVELOPE_FOLLOWER_SCALAR: return 12;
                case Opcode.BiquadCoefficients_LowPass_1: return 16;
                case Opcode.BiquadCoefficients_HighPass_1: return 16;
                case Opcode.BiquadCoefficients_BandPass: return 16;
                case Opcode.BiquadCoefficients_BandStop: return 16;
                case Opcode.BiquadCoefficients_LowPass_2: return 16;
                case Opcode.BiquadCoefficients_HighPass_2: return 16;
                case Opcode.BiquadCoefficients_PeakingEQ: return 18;
                case Opcode.BiquadProcess_2Pole: return 16;
                case Opcode.BiquadProcess_4Pole: return 16;
                case Opcode.OnePole_LPF_BUFFER_BUFFER: return 8;
                case Opcode.OnePole_LPF_BUFFER_SCALAR: return 8;
                case Opcode.OnePole_LPF_SCALAR_SCALAR: return 10;
                case Opcode.OnePole_HPF_BUFFER_BUFFER: return 8;
                case Opcode.OnePole_HPF_BUFFER_SCALAR: return 8;
                case Opcode.OnePole_HPF_SCALAR_SCALAR: return 10;
                case Opcode.OSC_RAMP_BUFFER_BUFFER: return 6;
                case Opcode.OSC_RAMP_BUFFER_SCALAR: return 8;
                case Opcode.OSC_RAMP_SCALAR: return 8;
                case Opcode.SINE_BUFFER: return 4;
                case Opcode.SINE: return 6;
                case Opcode.COSINE_BUFFER: return 4;
                case Opcode.COSINE: return 6;
                case Opcode.TRIANGLE_BUFFER: return 4;
                case Opcode.TRIANGLE: return 6;
                case Opcode.SQUARE_BUFFER: return 4;
                case Opcode.SQUARE: return 6;
                case Opcode.SAW_BUFFER: return 4;
                case Opcode.SAW: return 6;
                case Opcode.TRIGGER_LATCH: return 10;

                case Opcode.ENVELOPE_GEN__R_LINEAR_T_INTERRUPTIBLE:
                case Opcode.ENVELOPE_GEN__R_LINEAR_T_ONE_SHOT:
                case Opcode.ENVELOPE_GEN__R_LINEAR_T_RETRIGGER:
                case Opcode.ENVELOPE_GEN__R_EXP_T_INTERRUPTIBLE:
                case Opcode.ENVELOPE_GEN__R_EXP_T_ONE_SHOT:
                case Opcode.ENVELOPE_GEN__R_EXP_T_RETRIGGER:
                    return outputs == 2 ? 22 : 20;

                case Opcode.TIMED_TRIGGER__T_INTERRUPTIBLE:
                case Opcode.TIMED_TRIGGER__T_ONE_SHOT:
                case Opcode.TIMED_TRIGGER__T_RETRIGGER:
                    return 26;

                case Opcode.READ_VARIABLE: return 6;
                case Opcode.STOP: return 4;

                case Opcode.READ_INPUT_BUFFER0:
                case Opcode.READ_INPUT_BUFFER1:
                case Opcode.READ_INPUT_BUFFER2:
                case Opcode.READ_INPUT_BUFFER3:
                case Opcode.READ_INPUT_BUFFER4:
                case Opcode.READ_INPUT_BUFFER5:
                case Opcode.READ_INPUT_BUFFER6:
                case Opcode.READ_INPUT_BUFFER7:
                    return 4;

                case Opcode.NOTE_TO_FREQUENCY_SCALAR: return 6;
                case Opcode.NOTE_TO_FREQUENCY_BUFFER: return 4;
                case Opcode.SAMPLE_AND_HOLD: return 10;
                case Opcode.DECIMATE_BUFFER: return 10;

                case Opcode.COUNTER:
                case Opcode.COUNTER_TRIGGER:
                    return 14;

                case Opcode.GATE_BUFFER_BUFFER: return 6;
                case Opcode.GATE_BUFFER_SCALAR: return 6;
                case Opcode.GATE_SCALAR_SCALAR: return 8;

                case Opcode.SMALL_DELAY_FRAC:
                case Opcode.SMALL_DELAY_NON_INTERP:
                    return 4 + (inputs == 3 ? 6 : 4);

                case Opcode.SMALL_DELAY_FRAC_FEEDBACK:
                case Opcode.SMALL_DELAY_NON_INTERP_FEEDBACK:
                    return 10;

                case Opcode.TRIGGER_DIFF: return 10;
                case Opcode.RANDOM_ON_INIT: return 10;
                case Opcode.FILL_BUFFER: return 6;
                case Opcode.AWProcess: return 10;
                case Opcode.LERP_BUFFER_BUFFER: return 8;

                case Opcode.BiquadCoefficients_HighShelf_1:
                case Opcode.BiquadCoefficients_HighShelf_2:
                case Opcode.BiquadCoefficients_LowShelf_1:
                case Opcode.BiquadCoefficients_LowShelf_2:
                    return 18;

                case Opcode.SWITCH_NORM_BUFFER:
                case Opcode.SWITCH_INDEX_BUFFER:
                case Opcode.SWITCH_LERP_BUFFER:
                case Opcode.SWITCH_EQUAL_POWER_BUFFFER:
                    return 6 + (inputs - 2) * 2;

                case Opcode.SWITCH_NORM_SCALAR:
                case Opcode.SWITCH_INDEX_SCALAR:
                case Opcode.SWITCH_LERP_SCALAR:
                case Opcode.SWITCH_EQUAL_POWER_SCALAR:
                    return 6 + (inputs - 1) * 2;

                case Opcode.AllpassProcess_BUFFER_SCALAR: return 8;
                case Opcode.AllpassProcess_BUFFER_BUFFER: return 8;

                case Opcode.FINISH: return 2;
            }

            throw new NotImplementedException($"SizeOf '{opcode}' is not implemented");
        }

        public class AssembleResult
        {
            public byte[] Bytecode { get; set; } = Array.Empty<byte>();
            public int BuffersCount { get; set; }
            public int RegistersCount { get; set; }
            public int StateBlocksCount { get; set; }
            public int VariablesCount { get; set; }
            public List<float> Constants { get; set; } = new List<float>();
        }

        public static AssembleResult Assemble(string assembly, Dat10SynthVariable[] variables, Action<string, int> onError = null)
        {
            var result = new AssembleResult();

            using (var reader = new StringReader(assembly))
            using (var mem = new MemoryStream())
            using (var bw = new BinaryWriter(mem))
            {
                string line;
                int lineNumber = 1;
                while ((line = reader.ReadLine()) != null)
                {
                    var inst = Parse(line, result, variables, msg => onError?.Invoke(msg, lineNumber));
                    inst?.Encode(bw);
                    lineNumber++;
                }

                const int Align = 4;
                var padding = (Align - (mem.Length % Align)) % Align;
                if (padding > 0) bw.Write(new byte[padding]);

                result.Bytecode = mem.ToArray();
                return result;
            }
        }

        private static Instruction? Parse(string line, AssembleResult result, Dat10SynthVariable[] variables, Action<string> onError)
        {
            var commentStart = line.IndexOf(';');
            if (commentStart != -1)
            {
                // remove comment
                line = line.Substring(0, commentStart);
            }

            line = line.Trim();
            if (line.Length == 0)
            {
                return null;
            }

            var opcodeName = line.Substring(0, line.TakeWhile(c => !char.IsWhiteSpace(c)).Count());

            if (!Enum.TryParse<Opcode>(opcodeName, out var opcode))
            {
                onError($"Unknown opcode '{opcodeName}'");
                return null;
            }

            if (line.Length - opcodeName.Length <= 0)
            {
                onError("Missing input/output parameters");
                return null;
            }

            line = line.Substring(opcodeName.Length);
            var parts = line.Split(new[] { "=>" }, StringSplitOptions.None);
            if (parts.Length != 2)
            {
                onError("Missing input or output parameters");
                return null;
            }

            var inputs = parts[0].Split(',').Select(s => s.Trim()).Where(s => !string.IsNullOrWhiteSpace(s)).ToArray();

            var stateBlockEnd = parts[1].LastIndexOf(']');
            var stateBlockStart = parts[1].IndexOf('[');

            if (stateBlockStart > stateBlockEnd)
            {
                onError("Mismatched state block brackets");
                return null;
            }

            if (stateBlockEnd != -1 && stateBlockEnd != parts[1].Length - 1)
            {
                onError($"Stuff after state block... '{parts[1].Substring(stateBlockEnd + 1)}'");
                return null;
            }

            var stateBlockUsed = false;
            var hasStateBlock = stateBlockStart != -1;
            var stateBlockStr = hasStateBlock ? parts[1].Substring(stateBlockStart + 1, stateBlockEnd - stateBlockStart - 1) : null;

            var outputs = parts[1].Substring(0, hasStateBlock ? stateBlockStart : parts[1].Length)
                                  .Split(',').Select(s => s.Trim()).Where(s => !string.IsNullOrWhiteSpace(s)).ToArray();

            var currInputIndex = 0;
            var currOutputIndex = 0;
            var parameters = new List<Parameter>();

            void Param(ParameterType type)
            {
                var currInput = Parameter.IsInputType(type) && currInputIndex < inputs.Length ? inputs[currInputIndex] : null;
                var currOutput = Parameter.IsOutputType(type) && currOutputIndex < outputs.Length ? outputs[currOutputIndex] : null;
                ushort paramValue = 0xFFFF;

                bool parseParameter = true;
                if (Parameter.IsInputType(type) && currInput == null)
                {
                    onError($"Missing input parameter #{currInputIndex}, expected {Parameter.TypeToStringReadable(type)}");
                    parseParameter = false;
                }

                if (Parameter.IsOutputType(type) && currOutput == null)
                {
                    onError($"Missing output parameter #{currOutputIndex}, expected {Parameter.TypeToStringReadable(type)}");
                    parseParameter = false;
                }

                if (parseParameter)
                {
                    switch (type)
                    {
                        case ParameterType.InputBuffer: paramValue = ParseBuffer(currInput, result, onError); break;
                        case ParameterType.InputRegister: paramValue = ParseRegister(currInput, result, onError); break;
                        case ParameterType.InputScalar:
                            paramValue = currInput[0] == 'R' ?
                                            ParseRegister(currInput, result, onError) :
                                            ParseConstant(currInput, result, onError);
                            break;
                        case ParameterType.InputVariable: paramValue = ParseVariable(currInput, variables, result, onError); break;
                        case ParameterType.OutputBuffer: paramValue = ParseBuffer(currOutput, result, onError); break;
                        case ParameterType.OutputRegister: paramValue = ParseRegister(currOutput, result, onError); break;
                        case ParameterType.InputOutputBuffer:
                            if (currInput != currOutput)
                            {
                                onError($"Expected same input/output buffer: input = '{currInput}', output = '{currOutput}'");
                            }

                            paramValue = ParseBuffer(currInput, result, onError);
                            break;
                        case ParameterType.StateBlock:
                            byte stateBlockIndex = 0;
                            if (!hasStateBlock)
                            {
                                onError($"Opcode '{opcodeName}' requires a state block");
                            }
                            else
                            {
                                if (!byte.TryParse(stateBlockStr, out stateBlockIndex))
                                {
                                    onError($"Invalid state block: '{stateBlockStr}' cannot be parsed as an 8-bit integer");
                                }

                                if (stateBlockIndex >= MaxStateBlocks)
                                {
                                    onError($"Invalid state block: {stateBlockIndex} is out of bounds (valid range: 0 to {MaxStateBlocks - 1})");
                                }
                            }

                            result.StateBlocksCount = Math.Max(stateBlockIndex + 1, result.StateBlocksCount);
                            paramValue = stateBlockIndex;
                            stateBlockUsed = true;
                            break;
                        case ParameterType.Ignored:
                            // the game doesn't use this value, but existing synths use the same value as the first param
                            paramValue = parameters[0].Value;
                            break;
                        default: throw new NotImplementedException();
                    }
                }

                if (Parameter.IsInputType(type))
                {
                    currInputIndex++;
                }

                if (Parameter.IsOutputType(type))
                {
                    currOutputIndex++;
                }

                parameters.Add(new Parameter(type, paramValue));
            }

            bool IsInputScalar() => currInputIndex < inputs.Length && inputs[currInputIndex][0] != 'B';

            var numInputs = inputs.Length;
            var numOutputs = outputs.Length;

            if (opcode == Opcode.COPY_BUFFER || opcode == Opcode.COPY_REGISTER)
            {
                // count the ignored param as output
                numOutputs++;
            }

            HandleOpcode(opcode, numInputs, numOutputs, Param, IsInputScalar);

            if (!stateBlockUsed && hasStateBlock)
            {
                onError($"State block specified but not required by opcode '{opcodeName}'");
            }

            if (currInputIndex < inputs.Length)
            {
                onError($"Too many inputs for opcode '{opcode}'");
            }

            if (currOutputIndex < outputs.Length)
            {
                onError($"Too many outputs for opcode '{opcode}'");
            }

            return new Instruction
            {
                Opcode = opcode,
                InputsOutputs = opcode != Opcode.FINISH ? (byte)((numInputs << 4) | numOutputs) : (byte)0xFF,
                Parameters = parameters.ToArray(),
            };
        }

        private static ushort ParseVariable(string str, Dat10SynthVariable[] variables, AssembleResult result, Action<string> onError)
        {
            bool foundByName = false;
            byte varIndex = 0xFF;
            if (variables != null && variables.Length > 0)
            {
                try
                {
                    var nameHash = XmlMeta.GetHash(str);

                    for (int i = 0; i < variables.Length; i++)
                    {
                        if (variables[i].Name == nameHash)
                        {
                            foundByName = true;
                            varIndex = (byte)i;
                            break;
                        }
                    }
                }
                catch (Exception e) // XmlMeta.GetHash throws an exception if the hash is not a valid hex number
                {
                    onError($"Invalid variable name '{str}': {e.Message}");
                    return 0;
                }
            }

            if (!foundByName)
            {
                if (str[0] != 'V')
                {
                    onError($"Unknown variable '{str}'");
                    return 0;
                }

                var indexStr = str.Substring(1);
                if (!byte.TryParse(indexStr, out varIndex))
                {
                    onError($"Invalid variable: '{indexStr}' cannot be parsed as an 8-bit integer");
                    return 0;
                }
            }

            result.VariablesCount = Math.Max(varIndex + 1, result.VariablesCount);
            return (ushort)(0x300 | varIndex);
        }

        private static ushort ParseConstant(string str, AssembleResult result, Action<string> onError)
        {
            if (!FloatUtil.TryParse(str, out var constantValue))
            {
                onError($"Invalid constant: '{str}' cannot be parsed as a float");
                return 0;
            }

            byte constantId;
            if (constantValue == 0.0f)
            {
                constantId = 0;
            }
            else if (constantValue == 1.0f)
            {
                constantId = 1;
            }
            else
            {
                var constants = result.Constants;

                // This is not exactly how R* compiler handles constants. Sometimes it reuses constants and sometimes it doesn't,
                // here we will always reuse the constant, so it won't generate the exact same bytecode when reassembling
                var constantIndex = -1;
                for (int i = 0; i < constants.Count; i++)
                {
                    if (constants[i] == constantValue)
                    {
                        constantIndex = i;
                        break;
                    }
                }

                if (constantIndex == -1)
                {
                    constantIndex = constants.Count;
                    constants.Add(constantValue);
                }

                constantId = (byte)(constantIndex + 2);
            }

            return (ushort)(0x200 | constantId);
        }

        private static ushort ParseRegister(string str, AssembleResult result, Action<string> onError)
        {
            if (str[0] != 'R')
            {
                onError($"Expected a register, found '{str}'");
                return 0;
            }

            var indexStr = str.Substring(1);
            if (!byte.TryParse(indexStr, out var index))
            {
                onError($"Invalid register: '{indexStr}' cannot be parsed as an 8-bit integer");
                return 0;
            }

            if (index >= MaxRegisters)
            {
                // the synth 'dlc_xm_superweapon_xxx' from 'update\update.rpf\x64\audio\config\optamp.dat10.rel' uses 72 registers even
                // though it is above the hardcoded .exe limit, so don't fail to allow to re-assemble the file.
                // The game just ignores this synth and uses the one with the same name from 'dlcchristmas2017_amp.dat10'
                // onError($"Invalid register: {registerIndex} is out of bounds (max: {MaxRegisters})");
            }

            result.RegistersCount = Math.Max(index + 1, result.RegistersCount);
            return (ushort)(0x100 | index);
        }

        private static ushort ParseBuffer(string str, AssembleResult result, Action<string> onError)
        {
            if (str[0] != 'B')
            {
                onError($"Expected a buffer, found '{str}'");
                return 0;
            }

            var indexStr = str.Substring(1);
            if (!byte.TryParse(indexStr, out var index))
            {
                onError($"Invalid buffer: '{indexStr}' cannot be parsed as an 8-bit integer");
                return 0;
            }

            if (index >= MaxBuffers)
            {
                onError($"Invalid buffer: B{index} is out of bounds (valid range: B0 to B{MaxBuffers - 1})");
            }

            result.BuffersCount = Math.Max(index + 1, result.BuffersCount);
            return index;
        }

        public static Instruction Decode(BinaryReader bytecode)
        {
            var result = new Instruction();
            result.InputsOutputs = bytecode.ReadByte();
            result.Opcode = (Opcode)bytecode.ReadByte();
            var outputs = result.InputsOutputs & 0xF;
            var inputs = result.InputsOutputs >> 4;
            var parameters = new List<Parameter>(8);

            void Param(ParameterType type) => parameters.Add(new Parameter(type, bytecode.ReadUInt16()));
            bool IsInputScalar()
            {
                var inputVal = bytecode.ReadUInt16();
                bytecode.BaseStream.Seek(-sizeof(ushort), SeekOrigin.Current);
                return (inputVal & 0xFF00) != 0;
            }

            HandleOpcode(result.Opcode, result.NumberOfInputs, result.NumberOfOutputs, Param, IsInputScalar);

            result.Parameters = parameters.ToArray();
            return result;
        }

        private static void HandleOpcode(Opcode opcode, int inputs, int outputs, Action<ParameterType> cb, Func<bool> isInputScalar)
        {
            switch (opcode)
            {
                case Opcode.COPY_BUFFER:
                    cb(ParameterType.InputBuffer);
                    for (int i = 0; i < (outputs - 1); i++)
                    {
                        cb(ParameterType.OutputBuffer);
                    }
                    cb(ParameterType.Ignored); // not used by the game, same value as the input buffer
                    break;

                case Opcode.COPY_REGISTER:
                    cb(ParameterType.InputRegister);
                    for (int i = 0; i < (outputs - 1); i++)
                    {
                        cb(ParameterType.OutputRegister);
                    }
                    cb(ParameterType.Ignored); // not used by the game, same value as the input register
                    break;

                case Opcode.CONVERT_BUFFER_TO_DENORMALIZED:
                case Opcode.CONVERT_BUFFER_TO_NORMALIZED:
                    cb(ParameterType.InputOutputBuffer);
                    break;

                case Opcode.CONVERT_SCALAR_TO_DENORMALIZED:
                case Opcode.CONVERT_SCALAR_TO_NORMALIZED:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    break;

                case Opcode.FIRST_OF_BUFFER:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputBuffer);
                    break;

                case Opcode.MULTIPLY_BUFFER_BUFFER:
                case Opcode.SUM_BUFFER_BUFFER:
                case Opcode.SUBTRACT_BUFFER_BUFFER:
                case Opcode.DIVIDE_BUFFER_BUFFER:
                case Opcode.HARD_CLIP_BUFFER_BUFFER:
                case Opcode.SOFT_CLIP_BUFFER_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputBuffer);
                    break;

                case Opcode.MULTIPLY_BUFFER_SCALAR:
                case Opcode.SUM_BUFFER_SCALAR:
                case Opcode.SUBTRACT_BUFFER_SCALAR:
                case Opcode.DIVIDE_BUFFER_SCALAR:
                case Opcode.HARD_CLIP_BUFFER_SCALAR:
                case Opcode.SOFT_CLIP_BUFFER_SCALAR:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar);
                    break;

                case Opcode.SUBTRACT_SCALAR_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.Ignored); // not used by the game
                    break;

                case Opcode.MULTIPLY_SCALAR_SCALAR:
                case Opcode.SUM_SCALAR_SCALAR:
                case Opcode.SUBTRACT_SCALAR_SCALAR:
                case Opcode.DIVIDE_SCALAR_SCALAR:
                case Opcode.HARD_CLIP_SCALAR_SCALAR:
                case Opcode.SOFT_CLIP_SCALAR_SCALAR:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    break;

                case Opcode.RESCALE_BUFFER_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputBuffer); // original min
                    cb(ParameterType.InputBuffer); // original max
                    cb(ParameterType.InputBuffer); // new min
                    cb(ParameterType.InputBuffer); // new max
                    break;

                case Opcode.RESCALE_BUFFER_SCALAR:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar); // original min
                    cb(ParameterType.InputScalar); // original max
                    cb(ParameterType.InputScalar); // new min
                    cb(ParameterType.InputScalar); // new max
                    break;

                case Opcode.RESCALE_SCALAR_SCALAR:
                    cb(ParameterType.OutputRegister); // result
                    cb(ParameterType.InputScalar); // value
                    cb(ParameterType.InputScalar); // original min
                    cb(ParameterType.InputScalar); // original max
                    cb(ParameterType.InputScalar); // new min
                    cb(ParameterType.InputScalar); // new max
                    break;

                case Opcode.HARD_KNEE_SCALAR_SCALAR:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    break;

                case Opcode.NOISE:
                    cb(ParameterType.OutputBuffer);
                    break;

                case Opcode.RANDOM:
                    cb(ParameterType.OutputRegister); // result
                    cb(ParameterType.InputScalar); // next: if >= 1.0 then generate a new random value; else return the last value
                    cb(ParameterType.InputScalar); // min
                    cb(ParameterType.InputScalar); // max
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.ABS_BUFFER:
                case Opcode.FLOOR_BUFFER:
                case Opcode.CEIL_BUFFER:
                case Opcode.ROUND_BUFFER:
                case Opcode.SIGN_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    break;

                case Opcode.ABS_SCALAR:
                case Opcode.FLOOR_SCALAR:
                case Opcode.CEIL_SCALAR:
                case Opcode.ROUND_SCALAR:
                case Opcode.SIGN_SCALAR:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    break;

                case Opcode.HARD_KNEE_BUFFER:
                case Opcode.MODULO_BUFFER:
                case Opcode.POW_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    if (isInputScalar())
                    {
                        cb(ParameterType.InputScalar);
                    }
                    else
                    {
                        cb(ParameterType.InputBuffer);
                    }
                    break;

                case Opcode.MODULO_SCALAR:
                case Opcode.POW_SCALAR:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    break;

                case Opcode.MAX_SCALAR:
                    cb(ParameterType.OutputRegister); // result: max value between the absolute value of the input and the stored value
                    cb(ParameterType.InputScalar); // input
                    cb(ParameterType.InputScalar); // trigger: if >= 1.0 then compare to 0.0 instead of stored value
                    cb(ParameterType.StateBlock);  // stores the last result value
                    break;

                case Opcode.MAX_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.COMPRESS_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode._UNUSED_2C: // shouldn't get here
                    break;

                case Opcode.LERP_BUFFER:
                    cb(ParameterType.InputOutputBuffer); // t
                    cb(ParameterType.InputScalar); // min
                    cb(ParameterType.InputScalar); // max
                    break;

                case Opcode.LERP_BUFFER_2:
                    cb(ParameterType.OutputBuffer); // this buffer should be the same as one of the input buffers
                    cb(ParameterType.InputScalar); // t
                    cb(ParameterType.InputBuffer);
                    cb(ParameterType.InputBuffer);
                    break;

                case Opcode.LERP_SCALAR:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar); // t
                    cb(ParameterType.InputScalar); // min
                    cb(ParameterType.InputScalar); // max
                    break;

                case Opcode.ENVELOPE_FOLLOWER_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.ENVELOPE_FOLLOWER_SCALAR:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.BiquadCoefficients_LowPass_1:  // bool = false
                case Opcode.BiquadCoefficients_HighPass_1: // bool = false
                case Opcode.BiquadCoefficients_BandPass:
                case Opcode.BiquadCoefficients_BandStop:
                case Opcode.BiquadCoefficients_LowPass_2:  // bool = true
                case Opcode.BiquadCoefficients_HighPass_2: // bool = true
                    cb(ParameterType.OutputRegister); // b0
                    cb(ParameterType.OutputRegister); // b1
                    cb(ParameterType.OutputRegister); // b2
                    cb(ParameterType.OutputRegister); // a1
                    cb(ParameterType.OutputRegister); // a2
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    break;

                case Opcode.BiquadCoefficients_PeakingEQ:
                    cb(ParameterType.OutputRegister); // b0
                    cb(ParameterType.OutputRegister); // b1
                    cb(ParameterType.OutputRegister); // b2
                    cb(ParameterType.OutputRegister); // a1
                    cb(ParameterType.OutputRegister); // a2
                    cb(ParameterType.InputScalar);    // centerFrequency
                    cb(ParameterType.InputScalar);    // unkFrequency
                    cb(ParameterType.InputScalar);    // gain
                    break;

                case Opcode.BiquadProcess_2Pole:
                case Opcode.BiquadProcess_4Pole:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar); // b0
                    cb(ParameterType.InputScalar); // b1
                    cb(ParameterType.InputScalar); // b2
                    cb(ParameterType.InputScalar); // a1
                    cb(ParameterType.InputScalar); // a2
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.OnePole_LPF_BUFFER_BUFFER:
                case Opcode.OnePole_HPF_BUFFER_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputBuffer);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.OnePole_LPF_BUFFER_SCALAR:
                case Opcode.OnePole_HPF_BUFFER_SCALAR:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.OnePole_LPF_SCALAR_SCALAR:
                case Opcode.OnePole_HPF_SCALAR_SCALAR:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.OSC_RAMP_BUFFER_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.OSC_RAMP_BUFFER_SCALAR:
                    cb(ParameterType.OutputBuffer);
                    cb(ParameterType.InputScalar); // frequency
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.OSC_RAMP_SCALAR:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.SINE_BUFFER:
                case Opcode.COSINE_BUFFER:
                case Opcode.TRIANGLE_BUFFER:
                case Opcode.SQUARE_BUFFER:
                case Opcode.SAW_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    break;

                case Opcode.SINE:
                case Opcode.COSINE:
                case Opcode.TRIANGLE:
                case Opcode.SQUARE:
                case Opcode.SAW:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    break;

                case Opcode.TRIGGER_LATCH:
                    cb(ParameterType.OutputRegister);
                    if (isInputScalar())
                    {
                        cb(ParameterType.InputScalar);
                        cb(ParameterType.InputScalar);
                    }
                    else
                    {
                        cb(ParameterType.InputBuffer);
                        if (isInputScalar())
                        {
                            cb(ParameterType.InputScalar);
                        }
                        else
                        {
                            cb(ParameterType.InputBuffer);
                        }
                    }
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.ENVELOPE_GEN__R_LINEAR_T_INTERRUPTIBLE:
                case Opcode.ENVELOPE_GEN__R_LINEAR_T_ONE_SHOT:
                case Opcode.ENVELOPE_GEN__R_LINEAR_T_RETRIGGER:
                case Opcode.ENVELOPE_GEN__R_EXP_T_INTERRUPTIBLE:
                case Opcode.ENVELOPE_GEN__R_EXP_T_ONE_SHOT:
                case Opcode.ENVELOPE_GEN__R_EXP_T_RETRIGGER:
                    cb(ParameterType.OutputBuffer); // envelope
                    if (outputs == 2)
                    {
                        cb(ParameterType.OutputRegister); // finished
                    }
                    cb(ParameterType.InputScalar); // predelay
                    cb(ParameterType.InputScalar); // attack
                    cb(ParameterType.InputScalar); // decay
                    cb(ParameterType.InputScalar); // sustain
                    cb(ParameterType.InputScalar); // hold
                    cb(ParameterType.InputScalar); // release
                    cb(ParameterType.InputScalar); // trigger
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.TIMED_TRIGGER__T_INTERRUPTIBLE:
                case Opcode.TIMED_TRIGGER__T_ONE_SHOT:
                case Opcode.TIMED_TRIGGER__T_RETRIGGER:
                    cb(ParameterType.OutputRegister); // finished
                    cb(ParameterType.OutputRegister); // attack active
                    cb(ParameterType.OutputRegister); // decay active
                    cb(ParameterType.OutputRegister); // hold active
                    cb(ParameterType.OutputRegister); // release active
                    cb(ParameterType.InputScalar); // trigger
                    cb(ParameterType.InputScalar); // predelay
                    cb(ParameterType.InputScalar); // attack
                    cb(ParameterType.InputScalar); // decay
                    cb(ParameterType.InputScalar); // hold
                    cb(ParameterType.InputScalar); // release
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.READ_VARIABLE:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputVariable);
                    break;

                case Opcode.STOP:
                    cb(ParameterType.InputScalar); // trigger: if >= 1.0 then stop executing the synth
                    break;

                case Opcode.READ_INPUT_BUFFER0: // used for DSP effects
                case Opcode.READ_INPUT_BUFFER1:
                case Opcode.READ_INPUT_BUFFER2:
                case Opcode.READ_INPUT_BUFFER3:
                case Opcode.READ_INPUT_BUFFER4:
                case Opcode.READ_INPUT_BUFFER5:
                case Opcode.READ_INPUT_BUFFER6:
                case Opcode.READ_INPUT_BUFFER7:
                    cb(ParameterType.OutputBuffer);
                    break;

                case Opcode.NOTE_TO_FREQUENCY_SCALAR:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    break;

                case Opcode.NOTE_TO_FREQUENCY_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    break;

                case Opcode.SAMPLE_AND_HOLD:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar); // value
                    cb(ParameterType.InputScalar); // trigger: if >= 1.0 then store value; else return stored value
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.DECIMATE_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.COUNTER:
                case Opcode.COUNTER_TRIGGER:
                    cb(ParameterType.OutputRegister); // result: COUNTER: counter value
                                                      //         COUNTER_TRIGGER: when counter = 0 (due to zero or max params), returns 1; otherwise 0
                    cb(ParameterType.InputScalar); // zero:     if >= 1.0 then counter = 0
                    cb(ParameterType.InputScalar); // add:      if >= 1.0 then counter += 1
                    cb(ParameterType.InputScalar); // subtract: if >= 1.0 then counter -= 1
                    cb(ParameterType.InputScalar); // max:      if >= 0.0 && counter >= max then counter = 0
                    cb(ParameterType.StateBlock); // stores the counter
                    break;

                case Opcode.GATE_BUFFER_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputBuffer);
                    break;

                case Opcode.GATE_BUFFER_SCALAR:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar);
                    break;

                case Opcode.GATE_SCALAR_SCALAR:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    break;

                case Opcode.SMALL_DELAY_FRAC:
                case Opcode.SMALL_DELAY_NON_INTERP:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar);
                    if (inputs == 3)
                    {
                        // the game ignores this value and in the files it is always 0x200,
                        // but keep it to generate the exact same bytecode when reassembling
                        cb(ParameterType.InputScalar);
                    }
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.SMALL_DELAY_FRAC_FEEDBACK:
                case Opcode.SMALL_DELAY_NON_INTERP_FEEDBACK:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.TRIGGER_DIFF:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.RANDOM_ON_INIT: // like RANDOM, but only generates the random value once, then it always returns the same value
                    cb(ParameterType.OutputRegister); // result
                    cb(ParameterType.InputScalar); // min
                    cb(ParameterType.InputScalar); // max
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.FILL_BUFFER: // sets the whole buffer to the same value
                    cb(ParameterType.OutputBuffer); // dest
                    cb(ParameterType.InputScalar); // value
                    break;

                case Opcode.AWProcess:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputBuffer);
                    cb(ParameterType.InputBuffer);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.LERP_BUFFER_BUFFER:
                    cb(ParameterType.InputOutputBuffer); // t
                    cb(ParameterType.InputBuffer); // min
                    cb(ParameterType.InputBuffer); // max
                    break;

                case Opcode.BiquadCoefficients_HighShelf_1:
                case Opcode.BiquadCoefficients_HighShelf_2:
                case Opcode.BiquadCoefficients_LowShelf_1:
                case Opcode.BiquadCoefficients_LowShelf_2:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.InputScalar);
                    break;

                case Opcode.SWITCH_NORM_BUFFER:
                case Opcode.SWITCH_INDEX_BUFFER:
                case Opcode.SWITCH_LERP_BUFFER:
                case Opcode.SWITCH_EQUAL_POWER_BUFFFER:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar);
                    for (int i = 0; i < (inputs - 2); i++)
                    {
                        cb(ParameterType.InputBuffer);
                    }
                    break;

                case Opcode.SWITCH_NORM_SCALAR:
                case Opcode.SWITCH_INDEX_SCALAR:
                case Opcode.SWITCH_LERP_SCALAR:
                case Opcode.SWITCH_EQUAL_POWER_SCALAR:
                    cb(ParameterType.OutputRegister);
                    cb(ParameterType.InputScalar);
                    for (int i = 0; i < (inputs - 1); i++)
                    {
                        cb(ParameterType.InputScalar);
                    }
                    break;

                case Opcode.AllpassProcess_BUFFER_SCALAR:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputScalar);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.AllpassProcess_BUFFER_BUFFER:
                    cb(ParameterType.InputOutputBuffer);
                    cb(ParameterType.InputBuffer);
                    cb(ParameterType.StateBlock);
                    break;

                case Opcode.FINISH:
                    break;
            }
        }

        public struct Instruction
        {
            public byte InputsOutputs { get; set; }
            public Opcode Opcode { get; set; }
            public Parameter[] Parameters { get; set; }

            public int NumberOfInputs => InputsOutputs >> 4;
            public int NumberOfOutputs => InputsOutputs & 0xF;
            public int Size => SizeOf(Opcode, NumberOfInputs, NumberOfOutputs);

            public void Encode(BinaryWriter bw)
            {
                bw.Write(InputsOutputs);
                bw.Write((byte)Opcode);
                foreach (var p in Parameters)
                {
                    bw.Write(p.Value);
                }
            }

            public override string ToString()
            {
                return ToString(null, null);
            }

            public string ToString(float[] constants, Dat10SynthVariable[] variables)
            {
                var stateBlock = Parameters.Cast<Parameter?>().SingleOrDefault(p => p.Value.IsStateBlock);
                var inputsStr = string.Join(", ", Parameters.Where(p => p.IsInput).Select(p => p.ToString(constants, variables)));
                var outputsStr = string.Join(", ", Parameters.Where(p => p.IsOutput).Select(p => p.ToString(constants, variables))) +
                                    (stateBlock.HasValue ? " " + stateBlock.Value.ToString(constants, variables) : "");
                return $"{Opcode,-34} {inputsStr,-16} => {outputsStr}";
            }
        }

        public struct Parameter
        {
            public ParameterType Type { get; set; }
            public ushort Value { get; set; }

            public bool IsInput => IsInputType(Type);
            public bool IsOutput => IsOutputType(Type);
            public bool IsStateBlock => Type == ParameterType.StateBlock;

            public Parameter(ParameterType type, ushort value)
            {
                Value = value;
                Type = type;
            }

            public override string ToString()
            {
                return ToString(null, null);
            }

            public string ToString(float[] constants, Dat10SynthVariable[] variables)
            {
                switch (Type)
                {
                    case ParameterType.InputBuffer:
                    case ParameterType.OutputBuffer:
                    case ParameterType.InputOutputBuffer:
                        return $"B{Value}";
                    case ParameterType.InputScalar:
                        if ((Value & 0xFF00) == 0x100)
                        {
                            goto case ParameterType.InputRegister;
                        }
                        else
                        {
                            var v = Value & 0xFF;
                            switch (v)
                            {
                                case 0: return "0";
                                case 1: return "1";
                                default:
                                    var index = v - 2;
                                    return constants == null || index >= constants.Length ?
                                            $"C{index}" :
                                            FloatUtil.ToString(constants[index]);
                            }
                        }
                    case ParameterType.InputRegister:
                    case ParameterType.OutputRegister:
                        return $"R{Value & 0xFF}";
                    case ParameterType.InputVariable:
                        int varIndex = Value & 0xFF;
                        return variables == null || varIndex >= variables.Length ?
                                $"V{varIndex}" :
                                RelXml.HashString(variables[varIndex].Name);
                    case ParameterType.StateBlock:
                        return $"[{Value}]";
                    case ParameterType.Ignored:
                        return $"Ignored({Value})";
                }

                throw new NotImplementedException();
            }

            public static bool IsInputType(ParameterType type)
                => type == ParameterType.InputBuffer ||
                   type == ParameterType.InputRegister ||
                   type == ParameterType.InputScalar ||
                   type == ParameterType.InputVariable ||
                   type == ParameterType.InputOutputBuffer;

            public static bool IsOutputType(ParameterType type)
                => type == ParameterType.OutputBuffer ||
                   type == ParameterType.OutputRegister ||
                   type == ParameterType.InputOutputBuffer;

            // Returns a readable string representing the ParameterType, used in error messages
            public static string TypeToStringReadable(ParameterType type)
            {
                switch (type)
                {
                    case ParameterType.InputBuffer: return "input buffer";
                    case ParameterType.InputRegister: return "input register";
                    case ParameterType.InputScalar: return "input scalar";
                    case ParameterType.InputVariable: return "input variable";
                    case ParameterType.OutputBuffer: return "output buffer";
                    case ParameterType.OutputRegister: return "output register";
                    case ParameterType.InputOutputBuffer: return "input/output buffer";
                    case ParameterType.StateBlock: return "state block";
                    case ParameterType.Ignored: return "ignored";
                    default: return "unknown parameter type";
                }
            }
        }

        public enum ParameterType
        {
            InputBuffer,
            InputRegister,
            InputScalar,
            InputVariable,
            OutputBuffer,
            OutputRegister,
            InputOutputBuffer,
            StateBlock,
            Ignored,
        }

        public enum Opcode : byte
        {
            COPY_BUFFER = 0x00,
            COPY_REGISTER = 0x01,
            CONVERT_BUFFER_TO_DENORMALIZED = 0x02,
            CONVERT_SCALAR_TO_DENORMALIZED = 0x03,
            CONVERT_BUFFER_TO_NORMALIZED = 0x04,
            CONVERT_SCALAR_TO_NORMALIZED = 0x05,
            FIRST_OF_BUFFER = 0x06,
            MULTIPLY_BUFFER_BUFFER = 0x07,
            MULTIPLY_BUFFER_SCALAR = 0x08,
            MULTIPLY_SCALAR_SCALAR = 0x09,
            SUM_BUFFER_BUFFER = 0x0A,
            SUM_BUFFER_SCALAR = 0x0B,
            SUM_SCALAR_SCALAR = 0x0C,
            SUBTRACT_BUFFER_BUFFER = 0x0D,
            SUBTRACT_BUFFER_SCALAR = 0x0E,
            SUBTRACT_SCALAR_BUFFER = 0x0F,
            SUBTRACT_SCALAR_SCALAR = 0x10,
            DIVIDE_BUFFER_BUFFER = 0x11,
            DIVIDE_BUFFER_SCALAR = 0x12,
            DIVIDE_SCALAR_SCALAR = 0x13,
            RESCALE_BUFFER_BUFFER = 0x14,
            RESCALE_BUFFER_SCALAR = 0x15,
            RESCALE_SCALAR_SCALAR = 0x16,
            HARD_KNEE_BUFFER = 0x17,
            HARD_KNEE_SCALAR_SCALAR = 0x18,
            NOISE = 0x19,
            RANDOM = 0x1A,
            ABS_BUFFER = 0x1B,
            ABS_SCALAR = 0x1C,
            FLOOR_BUFFER = 0x1D,
            FLOOR_SCALAR = 0x1E,
            CEIL_BUFFER = 0x1F,
            CEIL_SCALAR = 0x20,
            ROUND_BUFFER = 0x21,
            ROUND_SCALAR = 0x22,
            SIGN_BUFFER = 0x23,
            SIGN_SCALAR = 0x24,
            MODULO_BUFFER = 0x25,
            MODULO_SCALAR = 0x26,
            POW_SCALAR = 0x27,
            POW_BUFFER = 0x28,
            MAX_SCALAR = 0x29,
            MAX_BUFFER = 0x2A,
            COMPRESS_BUFFER = 0x2B,
            _UNUSED_2C = 0x2C, // the game doesn't handle this opcode
            LERP_BUFFER = 0x2D,
            LERP_BUFFER_2 = 0x2E,
            LERP_SCALAR = 0x2F,
            HARD_CLIP_BUFFER_BUFFER = 0x30,
            HARD_CLIP_BUFFER_SCALAR = 0x31,
            HARD_CLIP_SCALAR_SCALAR = 0x32,
            SOFT_CLIP_BUFFER_BUFFER = 0x33,
            SOFT_CLIP_BUFFER_SCALAR = 0x34,
            SOFT_CLIP_SCALAR_SCALAR = 0x35,
            ENVELOPE_FOLLOWER_BUFFER = 0x36,
            ENVELOPE_FOLLOWER_SCALAR = 0x37,
            BiquadCoefficients_LowPass_1 = 0x38,
            BiquadCoefficients_HighPass_1 = 0x39,
            BiquadCoefficients_BandPass = 0x3A,
            BiquadCoefficients_BandStop = 0x3B,
            BiquadCoefficients_LowPass_2 = 0x3C,
            BiquadCoefficients_HighPass_2 = 0x3D,
            BiquadCoefficients_PeakingEQ = 0x3E,
            BiquadProcess_2Pole = 0x3F,
            BiquadProcess_4Pole = 0x40,
            OnePole_LPF_BUFFER_BUFFER = 0x41,
            OnePole_LPF_BUFFER_SCALAR = 0x42,
            OnePole_LPF_SCALAR_SCALAR = 0x43,
            OnePole_HPF_BUFFER_BUFFER = 0x44,
            OnePole_HPF_BUFFER_SCALAR = 0x45,
            OnePole_HPF_SCALAR_SCALAR = 0x46,
            OSC_RAMP_BUFFER_BUFFER = 0x47,
            OSC_RAMP_BUFFER_SCALAR = 0x48,
            OSC_RAMP_SCALAR = 0x49,
            SINE_BUFFER = 0x4A,
            SINE = 0x4B,
            COSINE_BUFFER = 0x4C,
            COSINE = 0x4D,
            TRIANGLE_BUFFER = 0x4E,
            TRIANGLE = 0x4F,
            SQUARE_BUFFER = 0x50,
            SQUARE = 0x51,
            SAW_BUFFER = 0x52,
            SAW = 0x53,
            TRIGGER_LATCH = 0x54,
            // R = release type, T = trigger mode
            ENVELOPE_GEN__R_LINEAR_T_INTERRUPTIBLE = 0x55,  // R = 0, T = 2
            ENVELOPE_GEN__R_LINEAR_T_ONE_SHOT = 0x56,       // R = 0, T = 0
            ENVELOPE_GEN__R_LINEAR_T_RETRIGGER = 0x57,      // R = 0, T = 1
            ENVELOPE_GEN__R_EXP_T_INTERRUPTIBLE = 0x58,     // R = 1, T = 2
            ENVELOPE_GEN__R_EXP_T_ONE_SHOT = 0x59,          // R = 1, T = 0
            ENVELOPE_GEN__R_EXP_T_RETRIGGER = 0x5A,         // R = 1, T = 1
            // T = trigger mode
            TIMED_TRIGGER__T_INTERRUPTIBLE = 0x5B,  // T = 2
            TIMED_TRIGGER__T_ONE_SHOT = 0x5C,       // T = 0
            TIMED_TRIGGER__T_RETRIGGER = 0x5D,      // T = 1
            READ_VARIABLE = 0x5E,
            STOP = 0x5F,
            READ_INPUT_BUFFER0 = 0x60,
            READ_INPUT_BUFFER1 = 0x61,
            READ_INPUT_BUFFER2 = 0x62,
            READ_INPUT_BUFFER3 = 0x63,
            READ_INPUT_BUFFER4 = 0x64,
            READ_INPUT_BUFFER5 = 0x65,
            READ_INPUT_BUFFER6 = 0x66,
            READ_INPUT_BUFFER7 = 0x67,
            NOTE_TO_FREQUENCY_SCALAR = 0x68,
            NOTE_TO_FREQUENCY_BUFFER = 0x69,
            SAMPLE_AND_HOLD = 0x6A,
            DECIMATE_BUFFER = 0x6B,
            COUNTER = 0x6C,
            COUNTER_TRIGGER = 0x6D,
            GATE_BUFFER_BUFFER = 0x6E,
            GATE_BUFFER_SCALAR = 0x6F,
            GATE_SCALAR_SCALAR = 0x70,
            SMALL_DELAY_FRAC = 0x71,
            SMALL_DELAY_NON_INTERP = 0x72,
            SMALL_DELAY_FRAC_FEEDBACK = 0x73,
            SMALL_DELAY_NON_INTERP_FEEDBACK = 0x74,
            TRIGGER_DIFF = 0x75,
            RANDOM_ON_INIT = 0x76,
            FILL_BUFFER = 0x77,
            AWProcess = 0x78,
            LERP_BUFFER_BUFFER = 0x79,
            BiquadCoefficients_HighShelf_1 = 0x7A,
            BiquadCoefficients_HighShelf_2 = 0x7B,
            BiquadCoefficients_LowShelf_1 = 0x7C,
            BiquadCoefficients_LowShelf_2 = 0x7D,
            SWITCH_NORM_BUFFER = 0x7E,
            SWITCH_INDEX_BUFFER = 0x7F,
            SWITCH_LERP_BUFFER = 0x80,
            SWITCH_EQUAL_POWER_BUFFFER = 0x81,
            SWITCH_NORM_SCALAR = 0x82,
            SWITCH_INDEX_SCALAR = 0x83,
            SWITCH_LERP_SCALAR = 0x84,
            SWITCH_EQUAL_POWER_SCALAR = 0x85,
            AllpassProcess_BUFFER_SCALAR = 0x86,
            AllpassProcess_BUFFER_BUFFER = 0x87,

            FINISH = 0xFF,
        }
    }


    #endregion




    #region dat15


    public enum Dat15RelType : byte
    {
        Patch = 0,//patch
        SceneState = 1, // _scene_state, _state
        Scene = 2,//scene
        Group = 3,//group
        GroupList = 4,//group list
        DynamicMixModuleSettings = 5,//_module (rage::DynamicMixModuleSettings)
        SceneVariableModuleSettings = 6,//_scene_variable_module (rage::SceneVariableModuleSettings)
        SceneTransitionModuleSettings = 7,//_scene_transition_module (rage::SceneTransitionModuleSettings)
        VehicleCollisionModuleSettings = 8,//_scene_vehicle_collision_module (rage::VehicleCollisionModuleSettings)
        GroupMap = 9,//group map
    }

    [TC(typeof(EXP))] 
    public class Dat15RelData : RelData
    {
        public Dat15RelType Type { get; set; }
        public uint NameTableOffset { get; set; }
        public FlagsUint Flags { get; set; }

        public Dat15RelData(RelFile rel) : base(rel) { }
        public Dat15RelData(RelFile rel, Dat15RelType type) : base(rel)
        {
            Type = type;
            TypeID = (byte)type;
        }
        public Dat15RelData(RelData d, BinaryReader br) : base(d)
        {
            Type = (Dat15RelType)TypeID;

            br.BaseStream.Position = 0; //1 byte was read already (TypeID)

            NameTableOffset = ((br.ReadUInt32() >> 8) & 0xFFFFFF);
            Flags = br.ReadUInt32();
        }

        public void WriteTypeAndOffsetAndFlags(BinaryWriter bw)
        {
            var val = ((NameTableOffset & 0xFFFFFF) << 8) + TypeID;
            bw.Write(val);
            bw.Write(Flags);
        }

        public override string ToString()
        {
            return GetBaseString() + ": " + Type.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat15Patch : Dat15RelData
    {
        public short FadeIn { get; set; }
        public short FadeOut { get; set; }
        public float PreDelay { get; set; }
        public float Duration { get; set; }
        public MetaHash ApplyFactorCurve { get; set; }
        public MetaHash ApplyVariable { get; set; }
        public float ApplySmoothRate { get; set; }
        public byte MixCategoriesCount { get; set; }
        public Dat15PatchItem[] MixCategories { get; set; }

        public Dat15Patch(RelFile rel) : base(rel)
        {
            Type = Dat15RelType.Patch;
            TypeID = (byte)Type;
        }
        public Dat15Patch(RelData d, BinaryReader br) : base(d, br)
        {
            FadeIn = br.ReadInt16();
            FadeOut = br.ReadInt16();
            PreDelay = br.ReadSingle();
            Duration = br.ReadSingle();
            ApplyFactorCurve = br.ReadUInt32();
            ApplyVariable = br.ReadUInt32();
            ApplySmoothRate = br.ReadSingle();
            MixCategoriesCount = br.ReadByte();
            MixCategories = new Dat15PatchItem[MixCategoriesCount];
            for (int i = 0; i < MixCategoriesCount; i++)
            {
                MixCategories[i] = new Dat15PatchItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(FadeIn);
            bw.Write(FadeOut);
            bw.Write(PreDelay);
            bw.Write(Duration);
            bw.Write(ApplyFactorCurve);
            bw.Write(ApplyVariable);
            bw.Write(ApplySmoothRate);
            bw.Write(MixCategoriesCount);
            for (int i = 0; i < MixCategoriesCount; i++)
            {
                MixCategories[i].Write(bw);
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "FadeIn", FadeIn.ToString());
            RelXml.ValueTag(sb, indent, "FadeOut", FadeOut.ToString());
            RelXml.ValueTag(sb, indent, "PreDelay", FloatUtil.ToString(PreDelay));
            RelXml.ValueTag(sb, indent, "Duration", FloatUtil.ToString(Duration));
            RelXml.StringTag(sb, indent, "ApplyFactorCurve", RelXml.HashString(ApplyFactorCurve));
            RelXml.StringTag(sb, indent, "ApplyVariable", RelXml.HashString(ApplyVariable));
            RelXml.ValueTag(sb, indent, "ApplySmoothRate", FloatUtil.ToString(ApplySmoothRate));
            RelXml.WriteItemArray(sb, MixCategories, indent, "MixCategories");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            FadeIn = (short)Xml.GetChildIntAttribute(node, "FadeIn", "value");
            FadeOut = (short)Xml.GetChildIntAttribute(node, "FadeOut", "value");
            PreDelay = Xml.GetChildFloatAttribute(node, "PreDelay", "value");
            Duration = Xml.GetChildFloatAttribute(node, "Duration", "value");
            ApplyFactorCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "ApplyFactorCurve"));
            ApplyVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "ApplyVariable"));
            ApplySmoothRate = Xml.GetChildFloatAttribute(node, "ApplySmoothRate", "value");
            MixCategories = XmlRel.ReadItemArray<Dat15PatchItem>(node, "MixCategories");
            MixCategoriesCount = (byte)(MixCategories?.Length ?? 0);
        }
        public override MetaHash[] GetCategoryHashes()
        {
            var list = new List<MetaHash>();
            if (MixCategories != null)
            {
                foreach (var item in MixCategories)
                {
                    list.Add(item.Category);
                }
            }
            return list.ToArray();
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { ApplyFactorCurve };
        }
    }

    [TC(typeof(EXP))]
    public class Dat15PatchItem : IMetaXmlItem
    {
        public MetaHash Category { get; set; }
        public short Volume { get; set; }
        public byte VolumeInvert { get; set; }
        public short LPFCutoff { get; set; }
        public short HPFCutoff { get; set; }
        public short Pitch { get; set; }
        public float Frequency { get; set; }
        public byte PitchInvert { get; set; }
        public float Rolloff { get; set; }

        public Dat15PatchItem()
        { }
        public Dat15PatchItem(BinaryReader br)
        {
            Category = br.ReadUInt32();
            Volume = br.ReadInt16();
            VolumeInvert = br.ReadByte();
            LPFCutoff = br.ReadInt16();
            HPFCutoff = br.ReadInt16();
            Pitch = br.ReadInt16();
            Frequency = br.ReadSingle();
            PitchInvert = br.ReadByte();
            Rolloff = br.ReadSingle();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Category);
            bw.Write(Volume);
            bw.Write(VolumeInvert);
            bw.Write(LPFCutoff);
            bw.Write(HPFCutoff);
            bw.Write(Pitch);
            bw.Write(Frequency);
            bw.Write(PitchInvert);
            bw.Write(Rolloff);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Category", RelXml.HashString(Category));
            RelXml.ValueTag(sb, indent, "Volume", Volume.ToString());
            RelXml.ValueTag(sb, indent, "VolumeInvert", VolumeInvert.ToString());
            RelXml.ValueTag(sb, indent, "LPFCutoff", LPFCutoff.ToString());
            RelXml.ValueTag(sb, indent, "HPFCutoff", HPFCutoff.ToString());
            RelXml.ValueTag(sb, indent, "Pitch", Pitch.ToString());
            RelXml.ValueTag(sb, indent, "Frequency", FloatUtil.ToString(Frequency));
            RelXml.ValueTag(sb, indent, "PitchInvert", PitchInvert.ToString());
            RelXml.ValueTag(sb, indent, "Rolloff", FloatUtil.ToString(Rolloff));
        }
        public void ReadXml(XmlNode node)
        {
            Category = XmlRel.GetHash(Xml.GetChildInnerText(node, "Category"));
            Volume = (short)Xml.GetChildIntAttribute(node, "Volume", "value");
            VolumeInvert = (byte)Xml.GetChildUIntAttribute(node, "VolumeInvert", "value");
            LPFCutoff = (short)Xml.GetChildIntAttribute(node, "LPFCutoff", "value");
            HPFCutoff = (short)Xml.GetChildIntAttribute(node, "HPFCutoff", "value");
            Pitch = (short)Xml.GetChildIntAttribute(node, "Pitch", "value");
            Frequency = Xml.GetChildFloatAttribute(node, "Frequency", "value");
            PitchInvert = (byte)Xml.GetChildIntAttribute(node, "PitchInvert", "value");
            Rolloff = Xml.GetChildFloatAttribute(node, "Rolloff", "value");
        }
        public override string ToString()
        {
            return Category.ToString() + ": " +
                Volume.ToString() + ", " +
                VolumeInvert.ToString() + ", " +
                LPFCutoff.ToString() + ", " +
                HPFCutoff.ToString() + ", " +
                Pitch.ToString() + ", " +
                Frequency.ToString() + ", " +
                PitchInvert.ToString() + ", " +
                Rolloff.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat15SceneState : Dat15RelData
    {
        public byte ItemCount { get; set; }
        public Dat151HashPair[] Items { get; set; }//name hash, scene

        public Dat15SceneState(RelFile rel) : base(rel)
        {
            Type = Dat15RelType.SceneState;
            TypeID = (byte)Type;
        }
        public Dat15SceneState(RelData d, BinaryReader br) : base(d, br)
        {
            ItemCount = br.ReadByte();
            Items = new Dat151HashPair[ItemCount];
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i] = new Dat151HashPair(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(ItemCount);
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.WriteItemArray(sb, Items, indent, "Items");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Items = XmlRel.ReadItemArray<Dat151HashPair>(node, "Items");
            ItemCount = (byte)(Items?.Length ?? 0);
        }
        public override MetaHash[] GetMixerHashes()
        {
            var list = new List<MetaHash>();
            if (Items != null)
            {
                foreach (var item in Items)
                {
                    list.Add(item.SoundRef);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat15Scene : Dat15RelData
    {
        public MetaHash OnStopScene { get; set; }
        public byte PatchGroupsCount { get; set; }
        public Dat15SceneItem[] PatchGroups { get; set; }

        public Dat15Scene(RelFile rel) : base(rel)
        {
            Type = Dat15RelType.Scene;
            TypeID = (byte)Type;
        }
        public Dat15Scene(RelData d, BinaryReader br) : base(d, br)
        {
            OnStopScene = br.ReadUInt32();
            PatchGroupsCount = br.ReadByte();
            PatchGroups = new Dat15SceneItem[PatchGroupsCount];
            for (int i = 0; i < PatchGroupsCount; i++)
            {
                PatchGroups[i] = new Dat15SceneItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(OnStopScene);
            bw.Write(PatchGroupsCount);
            for (int i = 0; i < PatchGroupsCount; i++)
            {
                PatchGroups[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "OnStopScene", RelXml.HashString(OnStopScene));
            RelXml.WriteItemArray(sb, PatchGroups, indent, "PatchGroups");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            OnStopScene = XmlRel.GetHash(Xml.GetChildInnerText(node, "OnStopScene"));
            PatchGroups = XmlRel.ReadItemArray<Dat15SceneItem>(node, "PatchGroups");
            PatchGroupsCount = (byte)(PatchGroups?.Length ?? 0);
        }
        public override MetaHash[] GetMixerHashes()
        {
            var list = new List<MetaHash>();
            if (PatchGroups != null)
            {
                foreach (var item in PatchGroups)
                {
                    list.Add(item.Patch);
                    list.Add(item.Group);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public class Dat15SceneItem : IMetaXmlItem
    {
        public MetaHash Patch { get; set; }
        public MetaHash Group { get; set; }

        public Dat15SceneItem()
        { }
        public Dat15SceneItem(BinaryReader br)
        {
            Patch = br.ReadUInt32();
            Group = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Patch);
            bw.Write(Group);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Patch", RelXml.HashString(Patch));
            RelXml.StringTag(sb, indent, "Group", RelXml.HashString(Group));
        }
        public void ReadXml(XmlNode node)
        {
            Patch = XmlRel.GetHash(Xml.GetChildInnerText(node, "Patch"));
            Group = XmlRel.GetHash(Xml.GetChildInnerText(node, "Group"));
        }
        public override string ToString()
        {
            return Patch.ToString() + ": " + Group.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat15Group : Dat15RelData
    {
        public uint ReferenceCount { get; set; }
        public float FadeTime { get; set; }
        public MetaHash Map { get; set; }

        public Dat15Group(RelFile rel) : base(rel)
        {
            Type = Dat15RelType.Group;
            TypeID = (byte)Type;
        }
        public Dat15Group(RelData d, BinaryReader br) : base(d, br)
        {
            ReferenceCount = br.ReadUInt32();
            FadeTime = br.ReadSingle();
            Map = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(ReferenceCount);
            bw.Write(FadeTime);
            bw.Write(Map);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "ReferenceCount", ReferenceCount.ToString());
            RelXml.ValueTag(sb, indent, "FadeTime", FloatUtil.ToString(FadeTime));
            RelXml.StringTag(sb, indent, "Map", RelXml.HashString(Map));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            ReferenceCount = Xml.GetChildUIntAttribute(node, "ReferenceCount", "value");
            FadeTime = Xml.GetChildFloatAttribute(node, "FadeTime", "value");
            Map = XmlRel.GetHash(Xml.GetChildInnerText(node, "Map"));
        }
        public override MetaHash[] GetMixerHashes()
        {
            return new[] { Map };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat15GroupList : Dat15RelData
    {
        public byte GroupCount { get; set; }
        public MetaHash[] Groups { get; set; }

        public Dat15GroupList(RelFile rel) : base(rel)
        {
            Type = Dat15RelType.GroupList;
            TypeID = (byte)Type;
        }
        public Dat15GroupList(RelData d, BinaryReader br) : base(d, br)
        {
            GroupCount = br.ReadByte();
            Groups = new MetaHash[GroupCount];
            for (int i = 0; i < GroupCount; i++)
            {
                Groups[i] = br.ReadUInt32();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(GroupCount);
            for (int i = 0; i < GroupCount; i++)
            {
                bw.Write(Groups[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.WriteHashItemArray(sb, Groups, indent, "Groups");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Groups = XmlRel.ReadHashItemArray(node, "Groups");
            GroupCount = (byte)(Groups?.Length ?? 0);
        }
        public override MetaHash[] GetMixerHashes()
        {
            return Groups;
        }
    }

    [TC(typeof(EXP))] 
    public class Dat15DynamicMixModuleSettings : Dat15RelData
    {
        public ushort FadeIn { get; set; }
        public ushort FadeOut { get; set; }
        public MetaHash ApplyVariable { get; set; }
        public float Duration { get; set; }
        public MetaHash ModuleTypeSettings { get; set; }

        public Dat15DynamicMixModuleSettings(RelFile rel) : base(rel)
        {
            Type = Dat15RelType.DynamicMixModuleSettings;
            TypeID = (byte)Type;
        }
        public Dat15DynamicMixModuleSettings(RelData d, BinaryReader br) : base(d, br)
        {
            FadeIn = br.ReadUInt16();
            FadeOut = br.ReadUInt16();
            ApplyVariable = br.ReadUInt32();
            Duration = br.ReadUInt32();
            ModuleTypeSettings = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(FadeIn);
            bw.Write(FadeOut);
            bw.Write(ApplyVariable);
            bw.Write(Duration);
            bw.Write(ModuleTypeSettings);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "FadeIn", FadeIn.ToString());
            RelXml.ValueTag(sb, indent, "FadeOut", FadeOut.ToString());
            RelXml.StringTag(sb, indent, "ApplyVariable", RelXml.HashString(ApplyVariable));
            RelXml.ValueTag(sb, indent, "Duration", Duration.ToString());
            RelXml.StringTag(sb, indent, "ModuleTypeSettings", RelXml.HashString(ModuleTypeSettings));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            FadeIn = (ushort)Xml.GetChildUIntAttribute(node, "FadeIn", "value");
            FadeOut = (ushort)Xml.GetChildUIntAttribute(node, "FadeOut", "value");
            ApplyVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "ApplyVariable"));
            Duration = (ushort)Xml.GetChildUIntAttribute(node, "Duration", "value");
            ModuleTypeSettings = XmlRel.GetHash(Xml.GetChildInnerText(node, "ModuleTypeSettings"));
        }
        public override MetaHash[] GetMixerHashes()
        {
            return new[] { ModuleTypeSettings };
        }
    }

    [TC(typeof(EXP))]
    public class Dat15SceneVariableModuleSettings : Dat15RelData
    {
        public MetaHash SceneVariable { get; set; }
        public MetaHash InputOutputCurve { get; set; }
        public byte Input { get; set; }
        public float ScaleMin { get; set; }
        public float ScaleMax { get; set; }

        public Dat15SceneVariableModuleSettings(RelFile rel) : base(rel)
        {
            Type = Dat15RelType.SceneVariableModuleSettings;
            TypeID = (byte)Type;
        }
        public Dat15SceneVariableModuleSettings(RelData d, BinaryReader br) : base(d, br)
        {
            SceneVariable = br.ReadUInt32();
            InputOutputCurve = br.ReadUInt32();
            Input = br.ReadByte();
            ScaleMin = br.ReadSingle();
            ScaleMax = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(SceneVariable);
            bw.Write(InputOutputCurve);
            bw.Write(Input);
            bw.Write(ScaleMin);
            bw.Write(ScaleMax);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.StringTag(sb, indent, "SceneVariable", RelXml.HashString(SceneVariable));
            RelXml.StringTag(sb, indent, "InputOutputCurve", RelXml.HashString(InputOutputCurve));
            RelXml.ValueTag(sb, indent, "Input", Input.ToString());
            RelXml.ValueTag(sb, indent, "ScaleMin", ScaleMin.ToString());
            RelXml.ValueTag(sb, indent, "ScaleMax", ScaleMax.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            SceneVariable = XmlRel.GetHash(Xml.GetChildInnerText(node, "SceneVariable"));
            InputOutputCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "InputOutputCurve"));
            Input = (byte)Xml.GetChildUIntAttribute(node, "Input", "value");
            ScaleMin = Xml.GetChildFloatAttribute(node, "ScaleMin", "value");
            ScaleMax = Xml.GetChildFloatAttribute(node, "ScaleMax", "value");
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { InputOutputCurve };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat15SceneTransitionModuleSettings : Dat15RelData
    {
        public byte Input { get; set; }
        public float Threshold { get; set; }
        public MetaHash Transition { get; set; }

        public Dat15SceneTransitionModuleSettings(RelFile rel) : base(rel)
        {
            Type = Dat15RelType.SceneTransitionModuleSettings;
            TypeID = (byte)Type;
        }
        public Dat15SceneTransitionModuleSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Input = br.ReadByte();
            Threshold = br.ReadSingle();
            Transition = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(Input);
            bw.Write(Threshold);
            bw.Write(Transition);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Input", Input.ToString());
            RelXml.ValueTag(sb, indent, "Threshold", FloatUtil.ToString(Threshold));
            RelXml.StringTag(sb, indent, "Transition", RelXml.HashString(Transition));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Input = (byte)Xml.GetChildUIntAttribute(node, "Input", "value");
            Threshold = Xml.GetChildFloatAttribute(node, "Threshold", "value");
            Transition = XmlRel.GetHash(Xml.GetChildInnerText(node, "Transition"));
        }
    }

    [TC(typeof(EXP))] 
    public class Dat15VehicleCollisionModuleSettings : Dat15RelData
    {
        public byte Input { get; set; }
        public MetaHash Transition { get; set; }

        public Dat15VehicleCollisionModuleSettings(RelFile rel) : base(rel)
        {
            Type = Dat15RelType.VehicleCollisionModuleSettings;
            TypeID = (byte)Type;
        }
        public Dat15VehicleCollisionModuleSettings(RelData d, BinaryReader br) : base(d, br)
        {
            Input = br.ReadByte();
            Transition = br.ReadUInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(Input);
            bw.Write(Transition);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "Input", Input.ToString());
            RelXml.StringTag(sb, indent, "Transition", RelXml.HashString(Transition));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Input = (byte)Xml.GetChildUIntAttribute(node, "Input", "value");
            Transition = XmlRel.GetHash(Xml.GetChildInnerText(node, "Transition"));
        }
        public override MetaHash[] GetSoundHashes()
        {
            return new[] { Transition };
        }
    }

    [TC(typeof(EXP))] 
    public class Dat15GroupMap : Dat15RelData
    {
        public ushort ItemCount { get; set; }
        public Dat151GroupMapItem[] Items { get; set; }

        public Dat15GroupMap(RelFile rel) : base(rel)
        {
            Type = Dat15RelType.GroupMap;
            TypeID = (byte)Type;
        }
        public Dat15GroupMap(RelData d, BinaryReader br) : base(d, br)
        {
            ItemCount = br.ReadUInt16();
            Items = new Dat151GroupMapItem[ItemCount];
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i] = new Dat151GroupMapItem(br);
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(ItemCount);
            for (int i = 0; i < ItemCount; i++)
            {
                Items[i].Write(bw);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.WriteItemArray(sb, Items, indent, "Items");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            Items = XmlRel.ReadItemArray<Dat151GroupMapItem>(node, "Items");
            ItemCount = (ushort)(Items?.Length ?? 0);
        }
        public override MetaHash[] GetCategoryHashes()
        {
            var list = new List<MetaHash>();
            if (Items != null)
            {
                foreach (var item in Items)
                {
                    list.Add(item.Category);
                    list.Add(item.MapToCategory);
                }
            }
            return list.ToArray();
        }
    }

    [TC(typeof(EXP))]
    public struct Dat151GroupMapItem : IMetaXmlItem
    {
        public MetaHash Category { get; set; }
        public MetaHash MapToCategory { get; set; }

        public Dat151GroupMapItem(BinaryReader br)
        {
            Category = br.ReadUInt32();
            MapToCategory = br.ReadUInt32();
        }
        public void Write(BinaryWriter bw)
        {
            bw.Write(Category);
            bw.Write(MapToCategory);
        }
        public void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.StringTag(sb, indent, "Category", RelXml.HashString(Category));
            RelXml.StringTag(sb, indent, "MapToCategory", RelXml.HashString(MapToCategory));
        }
        public void ReadXml(XmlNode node)
        {
            Category = XmlRel.GetHash(Xml.GetChildInnerText(node, "Category"));
            MapToCategory = XmlRel.GetHash(Xml.GetChildInnerText(node, "MapToCategory"));
        }
        public override string ToString()
        {
            return Category.ToString() + ": " + MapToCategory.ToString();
        }
    }

    #endregion




    #region dat16


    public enum Dat16RelType : byte
    {
        //BaseCurve = 0,
        ConstantCurve = 1,
        LinearCurve = 2,
        LinearDbCurve = 3,
        PiecewiseLinearCurve = 4,
        EqualPowerCurve = 5,
        ValueTableCurve = 6,
        ExponentialCurve = 7,
        DecayingExponentialCurve = 8,
        DecayingSquaredExponentialCurve = 9,
        SineCurve = 10,
        //OneOverXCurve = 11,
        OneOverXSquaredCurve = 12,
        DefaultDistanceAttenuationCurve = 13,
        //DefaultDistanceAttenuationClampedCurve = 14,
        DistanceAttenuationValueTableCurve = 15,
        //CurveSet = 16,
        //BezierCurve = 17,
    }

    [TC(typeof(EXP))] 
    public class Dat16RelData : RelData
    {
        public Dat16RelType Type { get; set; }
        public uint NameTableOffset { get; set; }
        public FlagsUint Flags { get; set; }

        public Dat16RelData(RelFile rel) : base(rel) { }
        public Dat16RelData(RelFile rel, Dat16RelType type) : base(rel)
        {
            Type = type;
            TypeID = (byte)type;
        }
        public Dat16RelData(RelData d, BinaryReader br) : base(d)
        {
            Type = (Dat16RelType)TypeID;

            br.BaseStream.Position = 0; //1 byte was read already (TypeID)

            NameTableOffset = ((br.ReadUInt32() >> 8) & 0xFFFFFF);
            Flags = br.ReadUInt32();
        }

        public void WriteTypeAndOffsetAndFlags(BinaryWriter bw)
        {
            var val = ((NameTableOffset & 0xFFFFFF) << 8) + TypeID;
            bw.Write(val);
            bw.Write(Flags);
        }

        public override string ToString()
        {
            return GetBaseString() + ": " + Type.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat16ConstantCurve : Dat16RelData
    {
        public float MinInput { get; set; }
        public float MaxInput { get; set; }
        public float Value { get; set; }

        public Dat16ConstantCurve(RelFile rel) : base(rel)
        {
            Type = Dat16RelType.ConstantCurve;
            TypeID = (byte)Type;
        }
        public Dat16ConstantCurve(RelData d, BinaryReader br) : base(d, br)
        {
            MinInput = br.ReadSingle();
            MaxInput = br.ReadSingle();
            Value = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(MinInput);
            bw.Write(MaxInput);
            bw.Write(Value);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinInput", FloatUtil.ToString(MinInput));
            RelXml.ValueTag(sb, indent, "MaxInput", FloatUtil.ToString(MaxInput));
            RelXml.ValueTag(sb, indent, "Value", FloatUtil.ToString(Value));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinInput = Xml.GetChildFloatAttribute(node, "MinInput", "value");
            MaxInput = Xml.GetChildFloatAttribute(node, "MaxInput", "value");
            Value = Xml.GetChildFloatAttribute(node, "Value", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat16LinearCurve : Dat16RelData
    {
        public float MinInput { get; set; }
        public float MaxInput { get; set; }
        public float LeftHandPairX { get; set; }
        public float LeftHandPairY { get; set; }
        public float RightHandPairX { get; set; }
        public float RightHandPairY { get; set; }

        public Dat16LinearCurve(RelFile rel) : base(rel)
        {
            Type = Dat16RelType.LinearCurve;
            TypeID = (byte)Type;
        }
        public Dat16LinearCurve(RelData d, BinaryReader br) : base(d, br)
        {
            MinInput = br.ReadSingle();
            MaxInput = br.ReadSingle();
            LeftHandPairX = br.ReadSingle();
            LeftHandPairY = br.ReadSingle();
            RightHandPairX = br.ReadSingle();
            RightHandPairY = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(MinInput);
            bw.Write(MaxInput);
            bw.Write(LeftHandPairX);
            bw.Write(LeftHandPairY);
            bw.Write(RightHandPairX);
            bw.Write(RightHandPairY);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinInput", FloatUtil.ToString(MinInput));
            RelXml.ValueTag(sb, indent, "MaxInput", FloatUtil.ToString(MaxInput));
            RelXml.ValueTag(sb, indent, "LeftHandPairX", FloatUtil.ToString(LeftHandPairX));
            RelXml.ValueTag(sb, indent, "LeftHandPairY", FloatUtil.ToString(LeftHandPairY));
            RelXml.ValueTag(sb, indent, "RightHandPairX", FloatUtil.ToString(RightHandPairX));
            RelXml.ValueTag(sb, indent, "RightHandPairY", FloatUtil.ToString(RightHandPairY));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinInput = Xml.GetChildFloatAttribute(node, "MinInput", "value");
            MaxInput = Xml.GetChildFloatAttribute(node, "MaxInput", "value");
            LeftHandPairX = Xml.GetChildFloatAttribute(node, "LeftHandPairX", "value");
            LeftHandPairY = Xml.GetChildFloatAttribute(node, "LeftHandPairY", "value");
            RightHandPairX = Xml.GetChildFloatAttribute(node, "RightHandPairX", "value");
            RightHandPairY = Xml.GetChildFloatAttribute(node, "RightHandPairY", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat16LinearDbCurve : Dat16RelData
    {
        public float MinInput { get; set; }
        public float MaxInput { get; set; }
        public float LeftHandPairX { get; set; }
        public float LeftHandPairY { get; set; }
        public float RightHandPairX { get; set; }
        public float RightHandPairY { get; set; }

        public Dat16LinearDbCurve(RelFile rel) : base(rel)
        {
            Type = Dat16RelType.LinearDbCurve;
            TypeID = (byte)Type;
        }
        public Dat16LinearDbCurve(RelData d, BinaryReader br) : base(d, br)
        {
            MinInput = br.ReadSingle();
            MaxInput = br.ReadSingle();
            LeftHandPairX = br.ReadSingle();
            LeftHandPairY = br.ReadSingle();
            RightHandPairX = br.ReadSingle();
            RightHandPairY = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(MinInput);
            bw.Write(MaxInput);
            bw.Write(LeftHandPairX);
            bw.Write(LeftHandPairY);
            bw.Write(RightHandPairX);
            bw.Write(RightHandPairY);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinInput", FloatUtil.ToString(MinInput));
            RelXml.ValueTag(sb, indent, "MaxInput", FloatUtil.ToString(MaxInput));
            RelXml.ValueTag(sb, indent, "LeftHandPairX", FloatUtil.ToString(LeftHandPairX));
            RelXml.ValueTag(sb, indent, "LeftHandPairY", FloatUtil.ToString(LeftHandPairY));
            RelXml.ValueTag(sb, indent, "RightHandPairX", FloatUtil.ToString(RightHandPairX));
            RelXml.ValueTag(sb, indent, "RightHandPairY", FloatUtil.ToString(RightHandPairY));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinInput = Xml.GetChildFloatAttribute(node, "MinInput", "value");
            MaxInput = Xml.GetChildFloatAttribute(node, "MaxInput", "value");
            LeftHandPairX = Xml.GetChildFloatAttribute(node, "LeftHandPairX", "value");
            LeftHandPairY = Xml.GetChildFloatAttribute(node, "LeftHandPairY", "value");
            RightHandPairX = Xml.GetChildFloatAttribute(node, "RightHandPairX", "value");
            RightHandPairY = Xml.GetChildFloatAttribute(node, "RightHandPairY", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat16PiecewiseLinearCurve : Dat16RelData
    {
        public float MinInput { get; set; }
        public float MaxInput { get; set; }
        public uint NumPoints { get; set; }
        public Vector2[] Points { get; set; }

        public Dat16PiecewiseLinearCurve(RelFile rel) : base(rel)
        {
            Type = Dat16RelType.PiecewiseLinearCurve;
            TypeID = (byte)Type;
        }
        public Dat16PiecewiseLinearCurve(RelData d, BinaryReader br) : base(d, br)
        {
            MinInput = br.ReadSingle();
            MaxInput = br.ReadSingle();
            NumPoints = br.ReadUInt32();
            Points = new Vector2[NumPoints];
            for (int i = 0; i < NumPoints; i++)
            {
                Points[i] = new Vector2(br.ReadSingle(), br.ReadSingle());
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(MinInput);
            bw.Write(MaxInput);
            bw.Write(NumPoints);
            for (int i = 0; i < NumPoints; i++)
            {
                bw.Write(Points[i].X);
                bw.Write(Points[i].Y);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinInput", FloatUtil.ToString(MinInput));
            RelXml.ValueTag(sb, indent, "MaxInput", FloatUtil.ToString(MaxInput));
            RelXml.WriteRawArray(sb, Points, indent, "Points", "", RelXml.FormatVector2, 1);
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinInput = Xml.GetChildFloatAttribute(node, "MinInput", "value");
            MaxInput = Xml.GetChildFloatAttribute(node, "MaxInput", "value");
            Points = Xml.GetChildRawVector2Array(node, "Points");
            NumPoints = (uint)(Points?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))] 
    public class Dat16EqualPowerCurve : Dat16RelData
    {
        public float MinInput { get; set; }
        public float MaxInput { get; set; }
        public int Flip { get; set; }

        public Dat16EqualPowerCurve(RelFile rel) : base(rel)
        {
            Type = Dat16RelType.EqualPowerCurve;
            TypeID = (byte)Type;
        }
        public Dat16EqualPowerCurve(RelData d, BinaryReader br) : base(d, br)
        {
            MinInput = br.ReadSingle();
            MaxInput = br.ReadSingle();
            Flip = br.ReadInt32();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(MinInput);
            bw.Write(MaxInput);
            bw.Write(Flip);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinInput", FloatUtil.ToString(MinInput));
            RelXml.ValueTag(sb, indent, "MaxInput", FloatUtil.ToString(MaxInput));
            RelXml.ValueTag(sb, indent, "Flip", Flip.ToString());
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinInput = Xml.GetChildFloatAttribute(node, "MinInput", "value");
            MaxInput = Xml.GetChildFloatAttribute(node, "MaxInput", "value");
            Flip = Xml.GetChildIntAttribute(node, "Flip", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat16ValueTableCurve : Dat16RelData
    {
        public float MinInput { get; set; }
        public float MaxInput { get; set; }
        public int ValueCount { get; set; }
        public float[] Values { get; set; }

        public Dat16ValueTableCurve(RelFile rel) : base(rel)
        {
            Type = Dat16RelType.ValueTableCurve;
            TypeID = (byte)Type;
        }
        public Dat16ValueTableCurve(RelData d, BinaryReader br) : base(d, br)
        {
            MinInput = br.ReadSingle();
            MaxInput = br.ReadSingle();
            ValueCount = br.ReadInt32();
            Values = new float[ValueCount];
            for (int i = 0; i < ValueCount; i++)
            {
                Values[i] = br.ReadSingle();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(MinInput);
            bw.Write(MaxInput);
            bw.Write(ValueCount);
            for (int i = 0; i < ValueCount; i++)
            {
                bw.Write(Values[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinInput", FloatUtil.ToString(MinInput));
            RelXml.ValueTag(sb, indent, "MaxInput", FloatUtil.ToString(MaxInput));
            RelXml.WriteRawArray(sb, Values, indent, "Values", "", FloatUtil.ToString, 1);
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinInput = Xml.GetChildFloatAttribute(node, "MinInput", "value");
            MaxInput = Xml.GetChildFloatAttribute(node, "MaxInput", "value");
            Values = Xml.GetChildRawFloatArray(node, "Values");
            ValueCount = (Values?.Length ?? 0);
        }
    }

    [TC(typeof(EXP))] 
    public class Dat16ExponentialCurve : Dat16RelData
    {
        public float MinInput { get; set; }
        public float MaxInput { get; set; }
        public int Flip { get; set; }
        public float Exponent { get; set; }

        public Dat16ExponentialCurve(RelFile rel) : base(rel)
        {
            Type = Dat16RelType.ExponentialCurve;
            TypeID = (byte)Type;
        }
        public Dat16ExponentialCurve(RelData d, BinaryReader br) : base(d, br)
        {
            MinInput = br.ReadSingle();
            MaxInput = br.ReadSingle();
            Flip = br.ReadInt32();
            Exponent = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(MinInput);
            bw.Write(MaxInput);
            bw.Write(Flip);
            bw.Write(Exponent);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinInput", FloatUtil.ToString(MinInput));
            RelXml.ValueTag(sb, indent, "MaxInput", FloatUtil.ToString(MaxInput));
            RelXml.ValueTag(sb, indent, "Flip", Flip.ToString());
            RelXml.ValueTag(sb, indent, "Exponent", FloatUtil.ToString(Exponent));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinInput = Xml.GetChildFloatAttribute(node, "MinInput", "value");
            MaxInput = Xml.GetChildFloatAttribute(node, "MaxInput", "value");
            Flip = Xml.GetChildIntAttribute(node, "Flip", "value");
            Exponent = Xml.GetChildFloatAttribute(node, "Exponent", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat16DecayingExponentialCurve : Dat16RelData
    {
        public float MinInput { get; set; }
        public float MaxInput { get; set; }
        public float HorizontalScaling { get; set; }

        public Dat16DecayingExponentialCurve(RelFile rel) : base(rel)
        {
            Type = Dat16RelType.DecayingExponentialCurve;
            TypeID = (byte)Type;
        }
        public Dat16DecayingExponentialCurve(RelData d, BinaryReader br) : base(d, br)
        {
            MinInput = br.ReadSingle();
            MaxInput = br.ReadSingle();
            HorizontalScaling = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(MinInput);
            bw.Write(MaxInput);
            bw.Write(HorizontalScaling);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinInput", FloatUtil.ToString(MinInput));
            RelXml.ValueTag(sb, indent, "MaxInput", FloatUtil.ToString(MaxInput));
            RelXml.ValueTag(sb, indent, "HorizontalScaling", FloatUtil.ToString(HorizontalScaling));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinInput = Xml.GetChildFloatAttribute(node, "MinInput", "value");
            MaxInput = Xml.GetChildFloatAttribute(node, "MaxInput", "value");
            HorizontalScaling = Xml.GetChildFloatAttribute(node, "HorizontalScaling", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat16DecayingSquaredExponentialCurve : Dat16RelData
    {
        public float MinInput { get; set; }
        public float MaxInput { get; set; }
        public float HorizontalScaling { get; set; }

        public Dat16DecayingSquaredExponentialCurve(RelFile rel) : base(rel)
        {
            Type = Dat16RelType.DecayingSquaredExponentialCurve;
            TypeID = (byte)Type;
        }
        public Dat16DecayingSquaredExponentialCurve(RelData d, BinaryReader br) : base(d, br)
        {
            MinInput = br.ReadSingle();
            MaxInput = br.ReadSingle();
            HorizontalScaling = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(MinInput);
            bw.Write(MaxInput);
            bw.Write(HorizontalScaling);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinInput", FloatUtil.ToString(MinInput));
            RelXml.ValueTag(sb, indent, "MaxInput", FloatUtil.ToString(MaxInput));
            RelXml.ValueTag(sb, indent, "HorizontalScaling", FloatUtil.ToString(HorizontalScaling));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinInput = Xml.GetChildFloatAttribute(node, "MinInput", "value");
            MaxInput = Xml.GetChildFloatAttribute(node, "MaxInput", "value");
            HorizontalScaling = Xml.GetChildFloatAttribute(node, "HorizontalScaling", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat16SineCurve : Dat16RelData
    {
        public float MinInput { get; set; }
        public float MaxInput { get; set; }
        public float StartPhase { get; set; }
        public float EndPhase { get; set; }
        public float Frequency { get; set; }
        public float VerticalScaling { get; set; }
        public float VerticalOffset { get; set; }

        public Dat16SineCurve(RelFile rel) : base(rel)
        {
            Type = Dat16RelType.SineCurve;
            TypeID = (byte)Type;
        }
        public Dat16SineCurve(RelData d, BinaryReader br) : base(d, br)
        {
            MinInput = br.ReadSingle();
            MaxInput = br.ReadSingle();
            StartPhase = br.ReadSingle();
            EndPhase = br.ReadSingle();
            Frequency = br.ReadSingle();
            VerticalScaling = br.ReadSingle();
            VerticalOffset = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(MinInput);
            bw.Write(MaxInput);
            bw.Write(StartPhase);
            bw.Write(EndPhase);
            bw.Write(Frequency);
            bw.Write(VerticalScaling);
            bw.Write(VerticalOffset);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinInput", FloatUtil.ToString(MinInput));
            RelXml.ValueTag(sb, indent, "MaxInput", FloatUtil.ToString(MaxInput));
            RelXml.ValueTag(sb, indent, "StartPhase", FloatUtil.ToString(StartPhase));
            RelXml.ValueTag(sb, indent, "EndPhase", FloatUtil.ToString(EndPhase));
            RelXml.ValueTag(sb, indent, "Frequency", FloatUtil.ToString(Frequency));
            RelXml.ValueTag(sb, indent, "VerticalScaling", FloatUtil.ToString(VerticalScaling));
            RelXml.ValueTag(sb, indent, "VerticalOffset", FloatUtil.ToString(VerticalOffset));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinInput = Xml.GetChildFloatAttribute(node, "MinInput", "value");
            MaxInput = Xml.GetChildFloatAttribute(node, "MaxInput", "value");
            StartPhase = Xml.GetChildFloatAttribute(node, "StartPhase", "value");
            EndPhase = Xml.GetChildFloatAttribute(node, "EndPhase", "value");
            Frequency = Xml.GetChildFloatAttribute(node, "Frequency", "value");
            VerticalScaling = Xml.GetChildFloatAttribute(node, "VerticalScaling", "value");
            VerticalOffset = Xml.GetChildFloatAttribute(node, "VerticalOffset", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat16OneOverXSquaredCurve : Dat16RelData
    {
        public float MinInput { get; set; }
        public float MaxInput { get; set; }
        public float HorizontalScaling { get; set; }

        public Dat16OneOverXSquaredCurve(RelFile rel) : base(rel)
        {
            Type = Dat16RelType.OneOverXSquaredCurve;
            TypeID = (byte)Type;
        }
        public Dat16OneOverXSquaredCurve(RelData d, BinaryReader br) : base(d, br)
        {
            MinInput = br.ReadSingle();
            MaxInput = br.ReadSingle();
            HorizontalScaling = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(MinInput);
            bw.Write(MaxInput);
            bw.Write(HorizontalScaling);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinInput", FloatUtil.ToString(MinInput));
            RelXml.ValueTag(sb, indent, "MaxInput", FloatUtil.ToString(MaxInput));
            RelXml.ValueTag(sb, indent, "HorizontalScaling", FloatUtil.ToString(HorizontalScaling));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinInput = Xml.GetChildFloatAttribute(node, "MinInput", "value");
            MaxInput = Xml.GetChildFloatAttribute(node, "MaxInput", "value");
            HorizontalScaling = Xml.GetChildFloatAttribute(node, "HorizontalScaling", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat16DefaultDistanceAttenuationCurve : Dat16RelData
    {
        public float MinInput { get; set; }
        public float MaxInput { get; set; }

        public Dat16DefaultDistanceAttenuationCurve(RelFile rel) : base(rel)
        {
            Type = Dat16RelType.DefaultDistanceAttenuationCurve;
            TypeID = (byte)Type;
        }
        public Dat16DefaultDistanceAttenuationCurve(RelData d, BinaryReader br) : base(d, br)
        {
            MinInput = br.ReadSingle();
            MaxInput = br.ReadSingle();
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(MinInput);
            bw.Write(MaxInput);
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinInput", FloatUtil.ToString(MinInput));
            RelXml.ValueTag(sb, indent, "MaxInput", FloatUtil.ToString(MaxInput));
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinInput = Xml.GetChildFloatAttribute(node, "MinInput", "value");
            MaxInput = Xml.GetChildFloatAttribute(node, "MaxInput", "value");
        }
    }

    [TC(typeof(EXP))] 
    public class Dat16DistanceAttenuationValueTableCurve : Dat16RelData
    {
        public float MinInput { get; set; }
        public float MaxInput { get; set; }
        public int ValueCount { get; set; }
        public float[] Values { get; set; }

        public Dat16DistanceAttenuationValueTableCurve(RelFile rel) : base(rel)
        {
            Type = Dat16RelType.DistanceAttenuationValueTableCurve;
            TypeID = (byte)Type;
        }
        public Dat16DistanceAttenuationValueTableCurve(RelData d, BinaryReader br) : base(d, br)
        {
            MinInput = br.ReadSingle();
            MaxInput = br.ReadSingle();
            ValueCount = br.ReadInt32();
            Values = new float[ValueCount];
            for (int i = 0; i < ValueCount; i++)
            {
                Values[i] = br.ReadSingle();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(MinInput);
            bw.Write(MaxInput);
            bw.Write(ValueCount);
            for (int i = 0; i < ValueCount; i++)
            {
                bw.Write(Values[i]);
            }
        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "MinInput", FloatUtil.ToString(MinInput));
            RelXml.ValueTag(sb, indent, "MaxInput", FloatUtil.ToString(MaxInput));
            RelXml.WriteRawArray(sb, Values, indent, "Values", "", FloatUtil.ToString, 1);
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            MinInput = Xml.GetChildFloatAttribute(node, "MinInput", "value");
            MaxInput = Xml.GetChildFloatAttribute(node, "MaxInput", "value");
            Values = Xml.GetChildRawFloatArray(node, "Values");
            ValueCount = (Values?.Length ?? 0);
        }
    }


    #endregion




    #region dat22


    public enum Dat22RelType : byte
    {
        Category = 0,
    }

    [TC(typeof(EXP))] 
    public class Dat22RelData : RelData
    {
        public Dat22RelType Type { get; set; }
        public uint NameTableOffset { get; set; }
        public FlagsUint Flags { get; set; }

        public Dat22RelData(RelFile rel) : base(rel) { }
        public Dat22RelData(RelFile rel, Dat22RelType type) : base(rel)
        {
            Type = type;
            TypeID = (byte)type;
        }
        public Dat22RelData(RelData d, BinaryReader br) : base(d)
        {
            Type = (Dat22RelType)TypeID;

            br.BaseStream.Position = 0; //1 byte was read already (TypeID)

            NameTableOffset = ((br.ReadUInt32() >> 8) & 0xFFFFFF);
            Flags = br.ReadUInt32();
        }

        public void WriteTypeAndOffsetAndFlags(BinaryWriter bw)
        {
            var val = ((NameTableOffset & 0xFFFFFF) << 8) + TypeID;
            bw.Write(val);
            bw.Write(Flags);
        }

        public override string ToString()
        {
            return GetBaseString() + ": " + Type.ToString();
        }
    }

    [TC(typeof(EXP))] 
    public class Dat22Category : Dat22RelData
    {
        public short ParentOverrides { get; set; }
        public short Volume { get; set; }
        public short Pitch { get; set; }
        public short LPFCutoff { get; set; }
        public MetaHash LPFDistanceCurve { get; set; }
        public short HPFCutoff { get; set; }
        public MetaHash HPFDistanceCurve { get; set; }
        public short DistanceRollOffScale { get; set; }
        public short PlateauRollOffScale { get; set; }
        public short OcclusionDamping { get; set; }
        public short EnvironmentalFilterDamping { get; set; }
        public short SourceReverbDamping { get; set; }
        public short DistanceReverbDamping { get; set; }
        public short InteriorReverbDamping { get; set; }
        public short EnvironmentalLoudness { get; set; }
        public short UnderwaterWetLevel { get; set; }
        public short StonedWetLevel { get; set; }
        public byte Timer { get; set; }
        public byte SubCategoryCount { get; set; }
        public MetaHash[] SubCategories { get; set; }

        public Dat22Category(RelFile rel) : base(rel)
        {
            Type = Dat22RelType.Category;
            TypeID = (byte)Type;
        }
        public Dat22Category(RelData d, BinaryReader br) : base(d, br)
        {
            ParentOverrides = br.ReadInt16();
            Volume = br.ReadInt16();
            Pitch = br.ReadInt16();
            LPFCutoff = br.ReadInt16();
            LPFDistanceCurve = br.ReadUInt32();
            HPFCutoff = br.ReadInt16();
            HPFDistanceCurve = br.ReadUInt32();
            DistanceRollOffScale = br.ReadInt16();
            PlateauRollOffScale = br.ReadInt16();
            OcclusionDamping = br.ReadInt16();
            EnvironmentalFilterDamping = br.ReadInt16();
            SourceReverbDamping = br.ReadInt16();
            DistanceReverbDamping = br.ReadInt16();
            InteriorReverbDamping = br.ReadInt16();
            EnvironmentalLoudness = br.ReadInt16();
            UnderwaterWetLevel = br.ReadInt16();
            StonedWetLevel = br.ReadInt16();
            Timer = br.ReadByte();
            SubCategoryCount = br.ReadByte();
            SubCategories = new MetaHash[SubCategoryCount];
            for (int i = 0; i < SubCategoryCount; i++)
            {
                SubCategories[i] = br.ReadUInt32();
            }
        }
        public override void Write(BinaryWriter bw)
        {
            WriteTypeAndOffsetAndFlags(bw);

            bw.Write(ParentOverrides);
            bw.Write(Volume);
            bw.Write(Pitch);
            bw.Write(LPFCutoff);
            bw.Write(LPFDistanceCurve);
            bw.Write(HPFCutoff);
            bw.Write(HPFDistanceCurve);
            bw.Write(DistanceRollOffScale);
            bw.Write(PlateauRollOffScale);
            bw.Write(OcclusionDamping);
            bw.Write(EnvironmentalFilterDamping);
            bw.Write(SourceReverbDamping);
            bw.Write(DistanceReverbDamping);
            bw.Write(InteriorReverbDamping);
            bw.Write(EnvironmentalLoudness);
            bw.Write(UnderwaterWetLevel);
            bw.Write(StonedWetLevel);
            bw.Write(Timer);
            bw.Write(SubCategoryCount);
            for (int i = 0; i < SubCategoryCount; i++)
            {
                bw.Write(SubCategories[i]);
            }

        }
        public override void WriteXml(StringBuilder sb, int indent)
        {
            RelXml.ValueTag(sb, indent, "Flags", "0x" + Flags.Hex);
            RelXml.ValueTag(sb, indent, "ParentOverrides", ParentOverrides.ToString());
            RelXml.ValueTag(sb, indent, "Volume", Volume.ToString());
            RelXml.ValueTag(sb, indent, "Pitch", Pitch.ToString());
            RelXml.ValueTag(sb, indent, "LPFCutoff", LPFCutoff.ToString());
            RelXml.StringTag(sb, indent, "LPFDistanceCurve", RelXml.HashString(LPFDistanceCurve));
            RelXml.ValueTag(sb, indent, "HPFCutoff", HPFCutoff.ToString());
            RelXml.StringTag(sb, indent, "HPFDistanceCurve", RelXml.HashString(HPFDistanceCurve));
            RelXml.ValueTag(sb, indent, "DistanceRollOffScale", DistanceRollOffScale.ToString());
            RelXml.ValueTag(sb, indent, "PlateauRollOffScale", PlateauRollOffScale.ToString());
            RelXml.ValueTag(sb, indent, "OcclusionDamping", OcclusionDamping.ToString());
            RelXml.ValueTag(sb, indent, "EnvironmentalFilterDamping", EnvironmentalFilterDamping.ToString());
            RelXml.ValueTag(sb, indent, "SourceReverbDamping", SourceReverbDamping.ToString());
            RelXml.ValueTag(sb, indent, "DistanceReverbDamping", DistanceReverbDamping.ToString());
            RelXml.ValueTag(sb, indent, "InteriorReverbDamping", InteriorReverbDamping.ToString());
            RelXml.ValueTag(sb, indent, "EnvironmentalLoudness", EnvironmentalLoudness.ToString());
            RelXml.ValueTag(sb, indent, "UnderwaterWetLevel", UnderwaterWetLevel.ToString());
            RelXml.ValueTag(sb, indent, "StonedWetLevel", StonedWetLevel.ToString());
            RelXml.ValueTag(sb, indent, "Timer", Timer.ToString());
            RelXml.WriteHashItemArray(sb, SubCategories, indent, "SubCategories");
        }
        public override void ReadXml(XmlNode node)
        {
            Flags = Xml.GetChildUIntAttribute(node, "Flags", "value");
            ParentOverrides = (short)Xml.GetChildIntAttribute(node, "ParentOverrides", "value");
            Volume = (short)Xml.GetChildIntAttribute(node, "Volume", "value");
            Pitch = (short)Xml.GetChildIntAttribute(node, "Pitch", "value");
            LPFCutoff = (short)Xml.GetChildIntAttribute(node, "LPFCutoff", "value");
            LPFDistanceCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "LPFDistanceCurve"));
            HPFCutoff = (short)Xml.GetChildIntAttribute(node, "HPFCutoff", "value");
            HPFDistanceCurve = XmlRel.GetHash(Xml.GetChildInnerText(node, "HPFDistanceCurve"));
            DistanceRollOffScale = (short)Xml.GetChildIntAttribute(node, "DistanceRollOffScale", "value");
            PlateauRollOffScale = (short)Xml.GetChildIntAttribute(node, "PlateauRollOffScale", "value");
            OcclusionDamping = (short)Xml.GetChildIntAttribute(node, "OcclusionDamping", "value");
            EnvironmentalFilterDamping = (short)Xml.GetChildIntAttribute(node, "EnvironmentalFilterDamping", "value");
            SourceReverbDamping = (short)Xml.GetChildIntAttribute(node, "SourceReverbDamping", "value");
            DistanceReverbDamping = (short)Xml.GetChildIntAttribute(node, "DistanceReverbDamping", "value");
            InteriorReverbDamping = (short)Xml.GetChildIntAttribute(node, "InteriorReverbDamping", "value");
            EnvironmentalLoudness = (short)Xml.GetChildIntAttribute(node, "EnvironmentalLoudness", "value");
            UnderwaterWetLevel = (short)Xml.GetChildIntAttribute(node, "UnderwaterWetLevel", "value");
            StonedWetLevel = (short)Xml.GetChildIntAttribute(node, "StonedWetLevel", "value");
            Timer = (byte)Xml.GetChildUIntAttribute(node, "Timer", "value");
            SubCategories = XmlRel.ReadHashItemArray(node, "SubCategories");
            SubCategoryCount = (byte)(SubCategories?.Length ?? 0);
        }
        public override MetaHash[] GetCurveHashes()
        {
            return new[] { LPFDistanceCurve, HPFDistanceCurve };
        }
        public override MetaHash[] GetCategoryHashes()
        {
            return SubCategories;
        }
    }


    #endregion













    public class RelXml : MetaXmlBase
    {

        public static string GetXml(RelFile rel)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine(XmlHeader);

            if ((rel != null) && (rel.RelDatasSorted != null))
            {
                int indent = 0;
                int cindent = 1;
                var iindent = 2;
                var name = "Dat" + ((uint)rel.RelType).ToString();

                OpenTag(sb, indent, name);

                ValueTag(sb, cindent, "Version", rel.DataUnkVal.ToString());

                if (rel.IsAudioConfig)
                {
                    ValueTag(sb, cindent, "IsAudioConfig", "true");
                    ValueTag(sb, cindent, "IndexStringFlags", rel.IndexStringFlags.ToString());
                }

                if (rel.NameTable != null)
                {
                    OpenTag(sb, cindent, "ContainerPaths");

                    foreach (var ntval in rel.NameTable)
                    {
                        StringTag(sb, iindent, "Item", ntval);
                    }

                    CloseTag(sb, cindent, "ContainerPaths");
                }

                OpenTag(sb, cindent, "Items");

                foreach (var item in rel.RelDatasSorted)
                {
                    GetXml(item, sb, iindent);
                }

                CloseTag(sb, cindent, "Items");

                CloseTag(sb, indent, name);

            }

            return sb.ToString();
        }

        public static void GetXml(RelData item, StringBuilder sb, int iindent)
        {
            var icindent = iindent + 1;
            var rel = item.Rel;
            var typeid = item.TypeID.ToString();
            switch (rel.RelType)
            {
                case RelDatFileType.Dat54DataEntries:
                    typeid = ((Dat54SoundType)item.TypeID).ToString();
                    break;
                case RelDatFileType.Dat149:
                case RelDatFileType.Dat150:
                case RelDatFileType.Dat151:
                    typeid = ((Dat151RelType)item.TypeID).ToString();
                    break;
                case RelDatFileType.Dat4:
                    if (rel.IsAudioConfig) typeid = ((Dat4ConfigType)item.TypeID).ToString();
                    else typeid = ((Dat4SpeechType)item.TypeID).ToString();
                    break;
                case RelDatFileType.Dat10ModularSynth:
                    typeid = ((Dat10RelType)item.TypeID).ToString();
                    break;
                case RelDatFileType.Dat15DynamicMixer:
                    typeid = ((Dat15RelType)item.TypeID).ToString();
                    break;
                case RelDatFileType.Dat16Curves:
                    typeid = ((Dat16RelType)item.TypeID).ToString();
                    break;
                case RelDatFileType.Dat22Categories:
                    typeid = ((Dat22RelType)item.TypeID).ToString();
                    break;
                default:
                    break;
            }

            var ntoffset = "";
            var dat151item = item as Dat151RelData;
            if (dat151item != null)
            {
                ntoffset = " ntOffset=\"" + dat151item.NameTableOffset.ToString() + "\"";
            }
            var dat4config = item as Dat4ConfigData;
            if (dat4config != null)
            {
                ntoffset = " ntOffset=\"" + dat4config.NameTableOffset.ToString() + "\"";
            }
            var dat4Speech = item as Dat4SpeechData;
            if (dat4Speech != null)
            {
                if (dat4Speech.Type == Dat4SpeechType.Container)
                {
                    ntoffset = " ntOffset=\"" + dat4Speech.NameTableOffset.ToString() + "\"";
                }
            }
            var dat10item = item as Dat10RelData;
            if (dat10item != null)
            {
                ntoffset = " ntOffset=\"" + dat10item.NameTableOffset.ToString() + "\"";
            }
            var dat15item = item as Dat15RelData;
            if (dat15item != null)
            {
                ntoffset = " ntOffset=\"" + dat15item.NameTableOffset.ToString() + "\"";
            }
            var dat16item = item as Dat16RelData;
            if (dat16item != null)
            {
                ntoffset = " ntOffset=\"" + dat16item.NameTableOffset.ToString() + "\"";
            }
            var dat22item = item as Dat22RelData;
            if (dat22item != null)
            {
                ntoffset = " ntOffset=\"" + dat22item.NameTableOffset.ToString() + "\"";
            }

            OpenTag(sb, iindent, "Item type=\"" + typeid + "\"" + ntoffset);

            StringTag(sb, icindent, "Name", item.Name ?? RelXml.HashString(item.NameHash));

            item.WriteXml(sb, icindent);

            CloseTag(sb, iindent, "Item");

        }
        public static string GetXml(RelData item, int indent = 0)
        {
            var sb = new StringBuilder();
            GetXml(item, sb, indent);
            return sb.ToString();
        }

    }

    public class XmlRel
    {

        public static RelFile GetRel(string xml)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xml);
            return GetRel(doc);
        }

        public static RelFile GetRel(XmlDocument doc)
        {

            var node = doc.DocumentElement;
            var reltypestr = node.Name.Substring(3);
            var reltypeint = uint.Parse(reltypestr);
            var reltype = (RelDatFileType)reltypeint;

            switch (reltype)
            {
                case RelDatFileType.Dat4://TODO!
                case RelDatFileType.Dat54DataEntries://TODO!
                    break;// return null; //TODO
            }

            RelFile rel = new RelFile();
            rel.RelType = reltype;
            rel.DataUnkVal = Xml.GetChildUIntAttribute(node, "Version", "value");
            rel.IsAudioConfig = Xml.GetChildBoolAttribute(node, "IsAudioConfig", "value");
            if (rel.IsAudioConfig)
            {
                rel.IndexStringFlags = Xml.GetChildUIntAttribute(node, "IndexStringFlags", "value");
            }
            var ntnode = node.SelectSingleNode("ContainerPaths");
            if (ntnode != null)
            {
                var ntstrs = new List<string>();
                var ntitems = ntnode.SelectNodes("Item");
                foreach (XmlNode ntitem in ntitems)
                {
                    ntstrs.Add(ntitem.InnerText);
                }
                rel.NameTable = ntstrs.ToArray();
                rel.NameTableCount = (uint)ntstrs.Count;
            }

            var itemsnode = node.SelectSingleNode("Items");
            if (itemsnode != null)
            {
                var itemslist = new List<RelData>();
                var items = itemsnode.SelectNodes("Item");
                foreach (XmlNode item in items)
                {
                    var ntoffset = Xml.GetUIntAttribute(item, "ntOffset");
                    var typestr = Xml.GetStringAttribute(item, "type");
                    var typeid = -1;
                    switch (reltype)
                    {
                        case RelDatFileType.Dat54DataEntries:
                            Dat54SoundType st;
                            if (Enum.TryParse(typestr, out st))
                            {
                                typeid = (int)st;
                            }
                            break;
                        case RelDatFileType.Dat149:
                        case RelDatFileType.Dat150:
                        case RelDatFileType.Dat151:
                            Dat151RelType rt;
                            if (Enum.TryParse(typestr, out rt))
                            {
                                typeid = (int)rt;
                            }
                            break;
                        case RelDatFileType.Dat4:
                            if (rel.IsAudioConfig)
                            {
                                Dat4ConfigType ct;
                                if (Enum.TryParse(typestr, out ct))
                                {
                                    typeid = (int)ct;
                                }
                            }
                            else
                            {
                                Dat4SpeechType spt;
                                if (Enum.TryParse(typestr, out spt))
                                {
                                    typeid = (int)spt;
                                }
                            }
                            break;
                        case RelDatFileType.Dat10ModularSynth:
                            Dat10RelType mst;
                            if (Enum.TryParse(typestr, out mst))
                            {
                                typeid = (int)mst;
                            }
                            break;
                        case RelDatFileType.Dat15DynamicMixer:
                            Dat15RelType dmt;
                            if (Enum.TryParse(typestr, out dmt))
                            {
                                typeid = (int)dmt;
                            }
                            break;
                        case RelDatFileType.Dat16Curves:
                            Dat16RelType cvt;
                            if (Enum.TryParse(typestr, out cvt))
                            {
                                typeid = (int)cvt;
                            }
                            break;
                        case RelDatFileType.Dat22Categories:
                            Dat22RelType cat;
                            if (Enum.TryParse(typestr, out cat))
                            {
                                typeid = (int)cat;
                            }
                            break;
                    }
                    if (typeid < 0)
                    {
                        if (!int.TryParse(typestr, out typeid))
                        {
                            continue;//couldn't determine type!
                        }
                    }


                    RelData rd = rel.CreateRelData(reltype, typeid);
                    rd.Name = Xml.GetChildInnerText(item, "Name");
                    rd.NameHash = XmlRel.GetHash(rd.Name);
                    rd.ReadXml(item);
                    itemslist.Add(rd);


                    var dat151data = rd as Dat151RelData;
                    if (dat151data != null)
                    {
                        dat151data.NameTableOffset = ntoffset;
                    }
                    var dat4config = rd as Dat4ConfigData;
                    if (dat4config != null)
                    {
                        dat4config.NameTableOffset = ntoffset;
                    }
                    var dat4speech = rd as Dat4SpeechData;
                    if (dat4speech != null)
                    {
                        dat4speech.NameTableOffset = ntoffset;
                    }
                    var dat10item = rd as Dat10RelData;
                    if (dat10item != null)
                    {
                        dat10item.NameTableOffset = ntoffset;
                    }
                    var dat15item = rd as Dat15RelData;
                    if (dat15item != null)
                    {
                        dat15item.NameTableOffset = ntoffset;
                    }
                    var dat16item = rd as Dat16RelData;
                    if (dat16item != null)
                    {
                        dat16item.NameTableOffset = ntoffset;
                    }
                    var dat22item = rd as Dat22RelData;
                    if (dat22item != null)
                    {
                        dat22item.NameTableOffset = ntoffset;
                    }
                }

                rel.RelDatas = itemslist.ToArray();//this one will get sorted on save
                rel.RelDatasSorted = itemslist.ToArray();
            }


            return rel;
        }


        public static MetaHash GetHash(string str)
        {
            if (string.IsNullOrEmpty(str))
            {
                return 0;
            }
            if (str.StartsWith("hash_"))
            {
                return Convert.ToUInt32(str.Substring(5), 16);
            }
            else
            {
                JenkIndex.Ensure(str);
                return JenkHash.GenHash(str);
            }
        }



        public static T[] ReadItemArray<T>(XmlNode node, string name) where T : IMetaXmlItem, new()
        {
            var vnode2 = node.SelectSingleNode(name);
            if (vnode2 != null)
            {
                var inodes = vnode2.SelectNodes("Item");
                if (inodes?.Count > 0)
                {
                    var vlist = new List<T>();
                    foreach (XmlNode inode in inodes)
                    {
                        var v = new T();
                        v.ReadXml(inode);
                        vlist.Add(v);
                    }
                    return vlist.ToArray();
                }
            }
            return null;
        }
        public static MetaHash[] ReadHashItemArray(XmlNode node, string name)
        {
            var vnode = node.SelectSingleNode(name);
            if (vnode != null)
            {
                var inodes = vnode.SelectNodes("Item");
                if (inodes?.Count > 0)
                {
                    var vlist = new List<MetaHash>();
                    foreach (XmlNode inode in inodes)
                    {
                        vlist.Add(GetHash(inode.InnerText));
                    }
                    return vlist.ToArray();
                }
            }
            return null;
        }
    }
}
